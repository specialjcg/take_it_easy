## ðŸ“„ package.json
```json
{
  "name": "vite-template-solid",
  "version": "0.0.0",
  "description": "",
  "type": "module",
  "scripts": {
    "start": "vite",
    "dev": "vite",
    "build": "vite build",
    "serve": "vite preview",
    "test": "vitest"
  },
  "license": "MIT",
  "devDependencies": {
    "@protobuf-ts/plugin": "^2.11.0",
    "@solidjs/testing-library": "^0.8.10",
    "@testing-library/jest-dom": "^6.6.3",
    "jsdom": "^25.0.1",
    "typescript": "^5.7.2",
    "vite": "^6.0.0",
    "vite-plugin-solid": "2.11.2",
    "vitest": "^3.0.0"
  },
  "dependencies": {
    "@protobuf-ts/grpcweb-transport": "^2.11.0",
    "@protobuf-ts/runtime": "^2.11.0",
    "@protobuf-ts/runtime-rpc": "^2.11.0",
    "solid-js": "^1.9.5"
  }
}
```

## ðŸ“„ vite.config.ts
```ts
import { defineConfig } from 'vite';
import solid from 'vite-plugin-solid';

export default defineConfig({
  plugins: [solid()],
  server: {
    port: 3000,
    proxy: {
      // Proxy pour gRPC-Web - redirige vers votre serveur Rust
      '/takeiteasygame.v1.SessionService': {
        target: 'http://localhost:50051',
        changeOrigin: true,
        headers: {
          'Content-Type': 'application/grpc-web+proto'
        }
      },
      '/takeiteasygame.v1.GameService': {
        target: 'http://localhost:50051',
        changeOrigin: true,
        headers: {
          'Content-Type': 'application/grpc-web+proto'
        }
      }
    }
  },
  define: {
    // Variables d'environnement pour le dÃ©veloppement
    __GRPC_WEB_ENDPOINT__: JSON.stringify('http://localhost:50051'),
  },
  optimizeDeps: {
    // Inclure les dÃ©pendances gRPC-Web dans l'optimisation
    include: [
      '@protobuf-ts/runtime',
      '@protobuf-ts/runtime-rpc',
      '@protobuf-ts/grpcweb-transport'
    ]
  }
});```

## ðŸ“„ tsconfig.json
```json
{
  "compilerOptions": {
    "strict": true,
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "types": ["vite/client", "@testing-library/jest-dom"]
  }
}
```

## ðŸ“„ src/todo-list.tsx
```tsx
import { For } from 'solid-js';
import { createStore } from 'solid-js/store';

type Todo = { id: number; text: string; completed: boolean };

export const TodoList = () => {
  let input!: HTMLInputElement;
  const [todos, setTodos] = createStore<Todo[]>([]);
  const addTodo = (text: string) => {
    setTodos(todos.length, { id: todos.length, text, completed: false });
  };
  const toggleTodo = (id: number) => {
    setTodos(id, 'completed', (c) => !c);
  };

  return (
    <>
      <div>
        <input placeholder="new todo here" ref={input} />
        <button
          onClick={() => {
            if (!input.value.trim()) return;
            addTodo(input.value);
            input.value = '';
          }}
        >
          Add Todo
        </button>
      </div>
      <div>
        <For each={todos}>
          {(todo) => {
            const { id, text } = todo;
            return (
              <div>
                <input
                  type="checkbox"
                  checked={todo.completed}
                  onchange={[toggleTodo, id]}
                />
                <span
                  style={{
                    'text-decoration': todo.completed ? 'line-through' : 'none',
                  }}
                >
                  {text}
                </span>
              </div>
            );
          }}
        </For>
      </div>
    </>
  );
};
```

## ðŸ“„ src/generated/session_service.client.ts
```ts
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { SessionService } from "./session_service";
import type { GetSessionStateResponse } from "./session_service";
import type { GetSessionStateRequest } from "./session_service";
import type { SetReadyResponse } from "./session_service";
import type { SetReadyRequest } from "./session_service";
import type { JoinSessionResponse } from "./session_service";
import type { JoinSessionRequest } from "./session_service";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { CreateSessionResponse } from "./session_service";
import type { CreateSessionRequest } from "./session_service";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service takeiteasygame.v1.SessionService
 */
export interface ISessionServiceClient {
    /**
     * @generated from protobuf rpc: CreateSession
     */
    createSession(input: CreateSessionRequest, options?: RpcOptions): UnaryCall<CreateSessionRequest, CreateSessionResponse>;
    /**
     * @generated from protobuf rpc: JoinSession
     */
    joinSession(input: JoinSessionRequest, options?: RpcOptions): UnaryCall<JoinSessionRequest, JoinSessionResponse>;
    /**
     * @generated from protobuf rpc: SetReady
     */
    setReady(input: SetReadyRequest, options?: RpcOptions): UnaryCall<SetReadyRequest, SetReadyResponse>;
    /**
     * @generated from protobuf rpc: GetSessionState
     */
    getSessionState(input: GetSessionStateRequest, options?: RpcOptions): UnaryCall<GetSessionStateRequest, GetSessionStateResponse>;
}
/**
 * @generated from protobuf service takeiteasygame.v1.SessionService
 */
export class SessionServiceClient implements ISessionServiceClient, ServiceInfo {
    typeName = SessionService.typeName;
    methods = SessionService.methods;
    options = SessionService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * @generated from protobuf rpc: CreateSession
     */
    createSession(input: CreateSessionRequest, options?: RpcOptions): UnaryCall<CreateSessionRequest, CreateSessionResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateSessionRequest, CreateSessionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: JoinSession
     */
    joinSession(input: JoinSessionRequest, options?: RpcOptions): UnaryCall<JoinSessionRequest, JoinSessionResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<JoinSessionRequest, JoinSessionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: SetReady
     */
    setReady(input: SetReadyRequest, options?: RpcOptions): UnaryCall<SetReadyRequest, SetReadyResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetReadyRequest, SetReadyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: GetSessionState
     */
    getSessionState(input: GetSessionStateRequest, options?: RpcOptions): UnaryCall<GetSessionStateRequest, GetSessionStateResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSessionStateRequest, GetSessionStateResponse>("unary", this._transport, method, opt, input);
    }
}
```

## ðŸ“„ src/generated/game_service.ts
```ts
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GameState } from "./common";
import { Error } from "./common";
/**
 * @generated from protobuf message takeiteasygame.v1.MakeMoveRequest
 */
export interface MakeMoveRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
    /**
     * @generated from protobuf field: string move_data = 3
     */
    moveData: string; // JSON du mouvement
    /**
     * @generated from protobuf field: int64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message takeiteasygame.v1.MakeMoveResponse
 */
export interface MakeMoveResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: takeiteasygame.v1.MakeMoveSuccess success = 1
         */
        success: MakeMoveSuccess;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: takeiteasygame.v1.Error error = 2
         */
        error: Error;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message takeiteasygame.v1.MakeMoveSuccess
 */
export interface MakeMoveSuccess {
    /**
     * @generated from protobuf field: takeiteasygame.v1.GameState new_game_state = 1
     */
    newGameState?: GameState;
    /**
     * @generated from protobuf field: string mcts_response = 2
     */
    mctsResponse: string; // RÃ©ponse de l'IA si applicable
    /**
     * @generated from protobuf field: int32 points_earned = 3
     */
    pointsEarned: number;
    /**
     * @generated from protobuf field: bool is_game_over = 4
     */
    isGameOver: boolean;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GetAvailableMovesRequest
 */
export interface GetAvailableMovesRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GetAvailableMovesResponse
 */
export interface GetAvailableMovesResponse {
    /**
     * @generated from protobuf field: repeated string available_moves = 1
     */
    availableMoves: string[]; // JSON des mouvements possibles
    /**
     * @generated from protobuf field: takeiteasygame.v1.Error error = 2
     */
    error?: Error;
}
// @generated message type with reflection information, may provide speed optimized methods
class MakeMoveRequest$Type extends MessageType<MakeMoveRequest> {
    constructor() {
        super("takeiteasygame.v1.MakeMoveRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "move_data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MakeMoveRequest>): MakeMoveRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.playerId = "";
        message.moveData = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<MakeMoveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveRequest): MakeMoveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 2:
                    message.playerId = reader.string();
                    break;
                case /* string move_data */ 3:
                    message.moveData = reader.string();
                    break;
                case /* int64 timestamp */ 4:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MakeMoveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 2; */
        if (message.playerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
        /* string move_data = 3; */
        if (message.moveData !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.moveData);
        /* int64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveRequest
 */
export const MakeMoveRequest = new MakeMoveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MakeMoveResponse$Type extends MessageType<MakeMoveResponse> {
    constructor() {
        super("takeiteasygame.v1.MakeMoveResponse", [
            { no: 1, name: "success", kind: "message", oneof: "result", T: () => MakeMoveSuccess },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<MakeMoveResponse>): MakeMoveResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MakeMoveResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveResponse): MakeMoveResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.MakeMoveSuccess success */ 1:
                    message.result = {
                        oneofKind: "success",
                        success: MakeMoveSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
                    };
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: Error.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MakeMoveResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.MakeMoveSuccess success = 1; */
        if (message.result.oneofKind === "success")
            MakeMoveSuccess.internalBinaryWrite(message.result.success, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* takeiteasygame.v1.Error error = 2; */
        if (message.result.oneofKind === "error")
            Error.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveResponse
 */
export const MakeMoveResponse = new MakeMoveResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MakeMoveSuccess$Type extends MessageType<MakeMoveSuccess> {
    constructor() {
        super("takeiteasygame.v1.MakeMoveSuccess", [
            { no: 1, name: "new_game_state", kind: "message", T: () => GameState },
            { no: 2, name: "mcts_response", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "points_earned", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "is_game_over", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MakeMoveSuccess>): MakeMoveSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mctsResponse = "";
        message.pointsEarned = 0;
        message.isGameOver = false;
        if (value !== undefined)
            reflectionMergePartial<MakeMoveSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveSuccess): MakeMoveSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.GameState new_game_state */ 1:
                    message.newGameState = GameState.internalBinaryRead(reader, reader.uint32(), options, message.newGameState);
                    break;
                case /* string mcts_response */ 2:
                    message.mctsResponse = reader.string();
                    break;
                case /* int32 points_earned */ 3:
                    message.pointsEarned = reader.int32();
                    break;
                case /* bool is_game_over */ 4:
                    message.isGameOver = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MakeMoveSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.GameState new_game_state = 1; */
        if (message.newGameState)
            GameState.internalBinaryWrite(message.newGameState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string mcts_response = 2; */
        if (message.mctsResponse !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mctsResponse);
        /* int32 points_earned = 3; */
        if (message.pointsEarned !== 0)
            writer.tag(3, WireType.Varint).int32(message.pointsEarned);
        /* bool is_game_over = 4; */
        if (message.isGameOver !== false)
            writer.tag(4, WireType.Varint).bool(message.isGameOver);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveSuccess
 */
export const MakeMoveSuccess = new MakeMoveSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAvailableMovesRequest$Type extends MessageType<GetAvailableMovesRequest> {
    constructor() {
        super("takeiteasygame.v1.GetAvailableMovesRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAvailableMovesRequest>): GetAvailableMovesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<GetAvailableMovesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAvailableMovesRequest): GetAvailableMovesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 2:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAvailableMovesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 2; */
        if (message.playerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetAvailableMovesRequest
 */
export const GetAvailableMovesRequest = new GetAvailableMovesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAvailableMovesResponse$Type extends MessageType<GetAvailableMovesResponse> {
    constructor() {
        super("takeiteasygame.v1.GetAvailableMovesResponse", [
            { no: 1, name: "available_moves", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<GetAvailableMovesResponse>): GetAvailableMovesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.availableMoves = [];
        if (value !== undefined)
            reflectionMergePartial<GetAvailableMovesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAvailableMovesResponse): GetAvailableMovesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string available_moves */ 1:
                    message.availableMoves.push(reader.string());
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAvailableMovesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string available_moves = 1; */
        for (let i = 0; i < message.availableMoves.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.availableMoves[i]);
        /* takeiteasygame.v1.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetAvailableMovesResponse
 */
export const GetAvailableMovesResponse = new GetAvailableMovesResponse$Type();
/**
 * @generated ServiceType for protobuf service takeiteasygame.v1.GameService
 */
export const GameService = new ServiceType("takeiteasygame.v1.GameService", [
    { name: "MakeMove", options: {}, I: MakeMoveRequest, O: MakeMoveResponse },
    { name: "GetAvailableMoves", options: {}, I: GetAvailableMovesRequest, O: GetAvailableMovesResponse }
]);
```

## ðŸ“„ src/generated/session_service.ts
```ts
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GameState } from "./common";
import { Error } from "./common";
import { Player } from "./common";
// ============================================================================
// MESSAGES SESSION SERVICE
// ============================================================================

/**
 * @generated from protobuf message takeiteasygame.v1.CreateSessionRequest
 */
export interface CreateSessionRequest {
    /**
     * @generated from protobuf field: string player_name = 1
     */
    playerName: string;
    /**
     * @generated from protobuf field: int32 max_players = 2
     */
    maxPlayers: number;
    /**
     * @generated from protobuf field: string game_mode = 3
     */
    gameMode: string;
}
/**
 * @generated from protobuf message takeiteasygame.v1.CreateSessionSuccess
 */
export interface CreateSessionSuccess {
    /**
     * @generated from protobuf field: string session_code = 1
     */
    sessionCode: string;
    /**
     * @generated from protobuf field: string session_id = 2
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 3
     */
    playerId: string;
    /**
     * @generated from protobuf field: takeiteasygame.v1.Player player = 4
     */
    player?: Player;
}
/**
 * @generated from protobuf message takeiteasygame.v1.CreateSessionResponse
 */
export interface CreateSessionResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: takeiteasygame.v1.CreateSessionSuccess success = 1
         */
        success: CreateSessionSuccess;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: takeiteasygame.v1.Error error = 2
         */
        error: Error;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message takeiteasygame.v1.JoinSessionRequest
 */
export interface JoinSessionRequest {
    /**
     * @generated from protobuf field: string session_code = 1
     */
    sessionCode: string;
    /**
     * @generated from protobuf field: string player_name = 2
     */
    playerName: string;
}
/**
 * @generated from protobuf message takeiteasygame.v1.JoinSessionSuccess
 */
export interface JoinSessionSuccess {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
    /**
     * @generated from protobuf field: takeiteasygame.v1.GameState game_state = 3
     */
    gameState?: GameState;
}
/**
 * @generated from protobuf message takeiteasygame.v1.JoinSessionResponse
 */
export interface JoinSessionResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: takeiteasygame.v1.JoinSessionSuccess success = 1
         */
        success: JoinSessionSuccess;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: takeiteasygame.v1.Error error = 2
         */
        error: Error;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message takeiteasygame.v1.SetReadyRequest
 */
export interface SetReadyRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
    /**
     * @generated from protobuf field: bool ready = 3
     */
    ready: boolean;
}
/**
 * @generated from protobuf message takeiteasygame.v1.SetReadyResponse
 */
export interface SetReadyResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: takeiteasygame.v1.Error error = 2
     */
    error?: Error;
    /**
     * @generated from protobuf field: bool game_started = 3
     */
    gameStarted: boolean;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GetSessionStateRequest
 */
export interface GetSessionStateRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GetSessionStateResponse
 */
export interface GetSessionStateResponse {
    /**
     * @generated from protobuf field: takeiteasygame.v1.GameState game_state = 1
     */
    gameState?: GameState;
    /**
     * @generated from protobuf field: takeiteasygame.v1.Error error = 2
     */
    error?: Error;
}
// @generated message type with reflection information, may provide speed optimized methods
class CreateSessionRequest$Type extends MessageType<CreateSessionRequest> {
    constructor() {
        super("takeiteasygame.v1.CreateSessionRequest", [
            { no: 1, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "max_players", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "game_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateSessionRequest>): CreateSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerName = "";
        message.maxPlayers = 0;
        message.gameMode = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionRequest): CreateSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_name */ 1:
                    message.playerName = reader.string();
                    break;
                case /* int32 max_players */ 2:
                    message.maxPlayers = reader.int32();
                    break;
                case /* string game_mode */ 3:
                    message.gameMode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_name = 1; */
        if (message.playerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerName);
        /* int32 max_players = 2; */
        if (message.maxPlayers !== 0)
            writer.tag(2, WireType.Varint).int32(message.maxPlayers);
        /* string game_mode = 3; */
        if (message.gameMode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.gameMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.CreateSessionRequest
 */
export const CreateSessionRequest = new CreateSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSessionSuccess$Type extends MessageType<CreateSessionSuccess> {
    constructor() {
        super("takeiteasygame.v1.CreateSessionSuccess", [
            { no: 1, name: "session_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<CreateSessionSuccess>): CreateSessionSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionCode = "";
        message.sessionId = "";
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSessionSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionSuccess): CreateSessionSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_code */ 1:
                    message.sessionCode = reader.string();
                    break;
                case /* string session_id */ 2:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 3:
                    message.playerId = reader.string();
                    break;
                case /* takeiteasygame.v1.Player player */ 4:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSessionSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_code = 1; */
        if (message.sessionCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionCode);
        /* string session_id = 2; */
        if (message.sessionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 3; */
        if (message.playerId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.playerId);
        /* takeiteasygame.v1.Player player = 4; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.CreateSessionSuccess
 */
export const CreateSessionSuccess = new CreateSessionSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSessionResponse$Type extends MessageType<CreateSessionResponse> {
    constructor() {
        super("takeiteasygame.v1.CreateSessionResponse", [
            { no: 1, name: "success", kind: "message", oneof: "result", T: () => CreateSessionSuccess },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<CreateSessionResponse>): CreateSessionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CreateSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionResponse): CreateSessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.CreateSessionSuccess success */ 1:
                    message.result = {
                        oneofKind: "success",
                        success: CreateSessionSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
                    };
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: Error.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.CreateSessionSuccess success = 1; */
        if (message.result.oneofKind === "success")
            CreateSessionSuccess.internalBinaryWrite(message.result.success, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* takeiteasygame.v1.Error error = 2; */
        if (message.result.oneofKind === "error")
            Error.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.CreateSessionResponse
 */
export const CreateSessionResponse = new CreateSessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JoinSessionRequest$Type extends MessageType<JoinSessionRequest> {
    constructor() {
        super("takeiteasygame.v1.JoinSessionRequest", [
            { no: 1, name: "session_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JoinSessionRequest>): JoinSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionCode = "";
        message.playerName = "";
        if (value !== undefined)
            reflectionMergePartial<JoinSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinSessionRequest): JoinSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_code */ 1:
                    message.sessionCode = reader.string();
                    break;
                case /* string player_name */ 2:
                    message.playerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_code = 1; */
        if (message.sessionCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionCode);
        /* string player_name = 2; */
        if (message.playerName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.JoinSessionRequest
 */
export const JoinSessionRequest = new JoinSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JoinSessionSuccess$Type extends MessageType<JoinSessionSuccess> {
    constructor() {
        super("takeiteasygame.v1.JoinSessionSuccess", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "game_state", kind: "message", T: () => GameState }
        ]);
    }
    create(value?: PartialMessage<JoinSessionSuccess>): JoinSessionSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<JoinSessionSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinSessionSuccess): JoinSessionSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 2:
                    message.playerId = reader.string();
                    break;
                case /* takeiteasygame.v1.GameState game_state */ 3:
                    message.gameState = GameState.internalBinaryRead(reader, reader.uint32(), options, message.gameState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinSessionSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 2; */
        if (message.playerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
        /* takeiteasygame.v1.GameState game_state = 3; */
        if (message.gameState)
            GameState.internalBinaryWrite(message.gameState, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.JoinSessionSuccess
 */
export const JoinSessionSuccess = new JoinSessionSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JoinSessionResponse$Type extends MessageType<JoinSessionResponse> {
    constructor() {
        super("takeiteasygame.v1.JoinSessionResponse", [
            { no: 1, name: "success", kind: "message", oneof: "result", T: () => JoinSessionSuccess },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<JoinSessionResponse>): JoinSessionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<JoinSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinSessionResponse): JoinSessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.JoinSessionSuccess success */ 1:
                    message.result = {
                        oneofKind: "success",
                        success: JoinSessionSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
                    };
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: Error.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.JoinSessionSuccess success = 1; */
        if (message.result.oneofKind === "success")
            JoinSessionSuccess.internalBinaryWrite(message.result.success, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* takeiteasygame.v1.Error error = 2; */
        if (message.result.oneofKind === "error")
            Error.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.JoinSessionResponse
 */
export const JoinSessionResponse = new JoinSessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetReadyRequest$Type extends MessageType<SetReadyRequest> {
    constructor() {
        super("takeiteasygame.v1.SetReadyRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ready", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetReadyRequest>): SetReadyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.playerId = "";
        message.ready = false;
        if (value !== undefined)
            reflectionMergePartial<SetReadyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReadyRequest): SetReadyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 2:
                    message.playerId = reader.string();
                    break;
                case /* bool ready */ 3:
                    message.ready = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetReadyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 2; */
        if (message.playerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
        /* bool ready = 3; */
        if (message.ready !== false)
            writer.tag(3, WireType.Varint).bool(message.ready);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.SetReadyRequest
 */
export const SetReadyRequest = new SetReadyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetReadyResponse$Type extends MessageType<SetReadyResponse> {
    constructor() {
        super("takeiteasygame.v1.SetReadyResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error", kind: "message", T: () => Error },
            { no: 3, name: "game_started", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetReadyResponse>): SetReadyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.gameStarted = false;
        if (value !== undefined)
            reflectionMergePartial<SetReadyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReadyResponse): SetReadyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* bool game_started */ 3:
                    message.gameStarted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetReadyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* takeiteasygame.v1.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool game_started = 3; */
        if (message.gameStarted !== false)
            writer.tag(3, WireType.Varint).bool(message.gameStarted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.SetReadyResponse
 */
export const SetReadyResponse = new SetReadyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSessionStateRequest$Type extends MessageType<GetSessionStateRequest> {
    constructor() {
        super("takeiteasygame.v1.GetSessionStateRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSessionStateRequest>): GetSessionStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        if (value !== undefined)
            reflectionMergePartial<GetSessionStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSessionStateRequest): GetSessionStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSessionStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetSessionStateRequest
 */
export const GetSessionStateRequest = new GetSessionStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSessionStateResponse$Type extends MessageType<GetSessionStateResponse> {
    constructor() {
        super("takeiteasygame.v1.GetSessionStateResponse", [
            { no: 1, name: "game_state", kind: "message", T: () => GameState },
            { no: 2, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<GetSessionStateResponse>): GetSessionStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSessionStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSessionStateResponse): GetSessionStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.GameState game_state */ 1:
                    message.gameState = GameState.internalBinaryRead(reader, reader.uint32(), options, message.gameState);
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSessionStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.GameState game_state = 1; */
        if (message.gameState)
            GameState.internalBinaryWrite(message.gameState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* takeiteasygame.v1.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetSessionStateResponse
 */
export const GetSessionStateResponse = new GetSessionStateResponse$Type();
/**
 * @generated ServiceType for protobuf service takeiteasygame.v1.SessionService
 */
export const SessionService = new ServiceType("takeiteasygame.v1.SessionService", [
    { name: "CreateSession", options: {}, I: CreateSessionRequest, O: CreateSessionResponse },
    { name: "JoinSession", options: {}, I: JoinSessionRequest, O: JoinSessionResponse },
    { name: "SetReady", options: {}, I: SetReadyRequest, O: SetReadyResponse },
    { name: "GetSessionState", options: {}, I: GetSessionStateRequest, O: GetSessionStateResponse }
]);
```

## ðŸ“„ src/generated/common.ts
```ts
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "common.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Types communs partagÃ©s entre services
 *
 * @generated from protobuf message takeiteasygame.v1.Player
 */
export interface Player {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: int32 score = 3
     */
    score: number;
    /**
     * @generated from protobuf field: bool is_ready = 4
     */
    isReady: boolean;
    /**
     * @generated from protobuf field: bool is_connected = 5
     */
    isConnected: boolean;
    /**
     * @generated from protobuf field: int64 joined_at = 6
     */
    joinedAt: bigint;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GameState
 */
export interface GameState {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: repeated takeiteasygame.v1.Player players = 2
     */
    players: Player[];
    /**
     * @generated from protobuf field: string current_player_id = 3
     */
    currentPlayerId: string;
    /**
     * @generated from protobuf field: takeiteasygame.v1.SessionState state = 4
     */
    state: SessionState;
    /**
     * @generated from protobuf field: string board_state = 5
     */
    boardState: string; // JSON serialized board
    /**
     * @generated from protobuf field: int32 turn_number = 6
     */
    turnNumber: number;
}
/**
 * @generated from protobuf message takeiteasygame.v1.Error
 */
export interface Error {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: map<string, string> details = 3
     */
    details: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf enum takeiteasygame.v1.SessionState
 */
export enum SessionState {
    /**
     * @generated from protobuf enum value: WAITING = 0;
     */
    WAITING = 0,
    /**
     * @generated from protobuf enum value: IN_PROGRESS = 1;
     */
    IN_PROGRESS = 1,
    /**
     * @generated from protobuf enum value: FINISHED = 2;
     */
    FINISHED = 2,
    /**
     * @generated from protobuf enum value: CANCELLED = 3;
     */
    CANCELLED = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Player$Type extends MessageType<Player> {
    constructor() {
        super("takeiteasygame.v1.Player", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "is_ready", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "joined_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Player>): Player {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.score = 0;
        message.isReady = false;
        message.isConnected = false;
        message.joinedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<Player>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Player): Player {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 score */ 3:
                    message.score = reader.int32();
                    break;
                case /* bool is_ready */ 4:
                    message.isReady = reader.bool();
                    break;
                case /* bool is_connected */ 5:
                    message.isConnected = reader.bool();
                    break;
                case /* int64 joined_at */ 6:
                    message.joinedAt = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 score = 3; */
        if (message.score !== 0)
            writer.tag(3, WireType.Varint).int32(message.score);
        /* bool is_ready = 4; */
        if (message.isReady !== false)
            writer.tag(4, WireType.Varint).bool(message.isReady);
        /* bool is_connected = 5; */
        if (message.isConnected !== false)
            writer.tag(5, WireType.Varint).bool(message.isConnected);
        /* int64 joined_at = 6; */
        if (message.joinedAt !== 0n)
            writer.tag(6, WireType.Varint).int64(message.joinedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.Player
 */
export const Player = new Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameState$Type extends MessageType<GameState> {
    constructor() {
        super("takeiteasygame.v1.GameState", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "players", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Player },
            { no: 3, name: "current_player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "state", kind: "enum", T: () => ["takeiteasygame.v1.SessionState", SessionState] },
            { no: 5, name: "board_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "turn_number", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GameState>): GameState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.players = [];
        message.currentPlayerId = "";
        message.state = 0;
        message.boardState = "";
        message.turnNumber = 0;
        if (value !== undefined)
            reflectionMergePartial<GameState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameState): GameState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* repeated takeiteasygame.v1.Player players */ 2:
                    message.players.push(Player.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string current_player_id */ 3:
                    message.currentPlayerId = reader.string();
                    break;
                case /* takeiteasygame.v1.SessionState state */ 4:
                    message.state = reader.int32();
                    break;
                case /* string board_state */ 5:
                    message.boardState = reader.string();
                    break;
                case /* int32 turn_number */ 6:
                    message.turnNumber = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* repeated takeiteasygame.v1.Player players = 2; */
        for (let i = 0; i < message.players.length; i++)
            Player.internalBinaryWrite(message.players[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string current_player_id = 3; */
        if (message.currentPlayerId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.currentPlayerId);
        /* takeiteasygame.v1.SessionState state = 4; */
        if (message.state !== 0)
            writer.tag(4, WireType.Varint).int32(message.state);
        /* string board_state = 5; */
        if (message.boardState !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.boardState);
        /* int32 turn_number = 6; */
        if (message.turnNumber !== 0)
            writer.tag(6, WireType.Varint).int32(message.turnNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GameState
 */
export const GameState = new GameState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Error$Type extends MessageType<Error> {
    constructor() {
        super("takeiteasygame.v1.Error", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "details", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Error>): Error {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.message = "";
        message.details = {};
        if (value !== undefined)
            reflectionMergePartial<Error>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Error): Error {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* map<string, string> details */ 3:
                    this.binaryReadMap3(message.details, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Error["details"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Error["details"] | undefined, val: Error["details"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for takeiteasygame.v1.Error.details");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Error, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* map<string, string> details = 3; */
        for (let k of globalThis.Object.keys(message.details))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.details[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.Error
 */
export const Error = new Error$Type();
```

## ðŸ“„ src/generated/game_service.client.ts
```ts
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { GameService } from "./game_service";
import type { GetAvailableMovesResponse } from "./game_service";
import type { GetAvailableMovesRequest } from "./game_service";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { MakeMoveResponse } from "./game_service";
import type { MakeMoveRequest } from "./game_service";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service takeiteasygame.v1.GameService
 */
export interface IGameServiceClient {
    /**
     * Faire un mouvement
     *
     * @generated from protobuf rpc: MakeMove
     */
    makeMove(input: MakeMoveRequest, options?: RpcOptions): UnaryCall<MakeMoveRequest, MakeMoveResponse>;
    /**
     * Obtenir les mouvements disponibles
     *
     * @generated from protobuf rpc: GetAvailableMoves
     */
    getAvailableMoves(input: GetAvailableMovesRequest, options?: RpcOptions): UnaryCall<GetAvailableMovesRequest, GetAvailableMovesResponse>;
}
/**
 * @generated from protobuf service takeiteasygame.v1.GameService
 */
export class GameServiceClient implements IGameServiceClient, ServiceInfo {
    typeName = GameService.typeName;
    methods = GameService.methods;
    options = GameService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Faire un mouvement
     *
     * @generated from protobuf rpc: MakeMove
     */
    makeMove(input: MakeMoveRequest, options?: RpcOptions): UnaryCall<MakeMoveRequest, MakeMoveResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<MakeMoveRequest, MakeMoveResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Obtenir les mouvements disponibles
     *
     * @generated from protobuf rpc: GetAvailableMoves
     */
    getAvailableMoves(input: GetAvailableMovesRequest, options?: RpcOptions): UnaryCall<GetAvailableMovesRequest, GetAvailableMovesResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetAvailableMovesRequest, GetAvailableMovesResponse>("unary", this._transport, method, opt, input);
    }
}
```

## ðŸ“„ src/index.tsx
```tsx
// src/index.tsx
import { render } from 'solid-js/web';
import MultiplayerApp from './components/MultiplayerApp';

const root = document.getElementById('root');

if (import.meta.env.DEV && !(root instanceof HTMLElement)) {
  throw new Error(
      'Root element not found. Did you forget to add it to your index.html? Or maybe the id attribute got misspelled?',
  );
}

render(() => <MultiplayerApp />, root!);```

## ðŸ“„ src/todo-list.test.tsx
```tsx
import { render, fireEvent } from '@solidjs/testing-library';

import { TodoList } from './todo-list';
import { describe, expect, test } from 'vitest';

describe('<TodoList />', () => {
  test('it will render an text input and a button', () => {
    const { getByPlaceholderText, getByText } = render(() => <TodoList />);
    expect(getByPlaceholderText('new todo here')).toBeInTheDocument();
    expect(getByText('Add Todo')).toBeInTheDocument();
  });

  test('it will add a new todo', async () => {
    const { getByPlaceholderText, getByText } = render(() => <TodoList />);
    const input = getByPlaceholderText('new todo here') as HTMLInputElement;
    const button = getByText('Add Todo');
    input.value = 'test new todo';
    fireEvent.click(button as HTMLInputElement);
    expect(input.value).toBe('');
    expect(getByText(/test new todo/)).toBeInTheDocument();
  });

  test('it will mark a todo as completed', async () => {
    const { getByPlaceholderText, findByRole, getByText } = render(() => (
      <TodoList />
    ));
    const input = getByPlaceholderText('new todo here') as HTMLInputElement;
    const button = getByText('Add Todo') as HTMLButtonElement;
    input.value = 'mark new todo as completed';
    fireEvent.click(button);
    const completed = (await findByRole('checkbox')) as HTMLInputElement;
    expect(completed?.checked).toBe(false);
    fireEvent.click(completed);
    expect(completed?.checked).toBe(true);
    const text = getByText('mark new todo as completed') as HTMLSpanElement;
    expect(text).toHaveStyle({ 'text-decoration': 'line-through' });
  });
});
```

## ðŸ“„ src/components/MultiplayerApp.tsx
```tsx
// src/components/MultiplayerApp.tsx - Interface multiplayer avec gRPC
import { Component, createSignal, createEffect, onMount, Show, For, onCleanup } from 'solid-js';
import { gameClient } from '../services/GameClient';

// Import des types gÃ©nÃ©rÃ©s depuis vos fichiers
import { SessionState } from '../generated/common';
import type { Player as ProtoPlayer, GameState as ProtoGameState } from '../generated/common';

// Types pour l'Ã©tat local (adaptÃ©s de vos protos)
interface Player {
    id: string;
    name: string;
    score: number;
    isReady: boolean;
    isConnected: boolean;
    joinedAt: string;
}

interface GameState {
    sessionCode: string;
    state: SessionState;
    players: Player[];
    boardState: string;
    currentTurn?: string;
}

interface Session {
    playerId: string;
    sessionCode: string;
    sessionId: string; // Ajout du sessionId pour les appels gRPC
}

const MultiplayerApp: Component = () => {
    // Signaux SolidJS
    const [playerName, setPlayerName] = createSignal('');
    const [sessionCode, setSessionCode] = createSignal('');
    const [gameState, setGameState] = createSignal<GameState | null>(null);
    const [session, setSession] = createSignal<Session | null>(null);
    const [loading, setLoading] = createSignal(false);
    const [error, setError] = createSignal('');
    const [statusMessage, setStatusMessage] = createSignal('');

    // Polling pour l'Ã©tat du jeu
    let pollInterval: number | undefined;

    // DÃ©marrer le polling quand on rejoint une session
    createEffect(() => {
        const currentSession = session();
        if (currentSession) {
            // RÃ©activer le polling pour synchroniser les joueurs
            startPolling(currentSession.sessionId);
            console.log('Polling activÃ© pour session:', currentSession.sessionCode, 'ID:', currentSession.sessionId);
        } else {
            stopPolling();
        }
    });

    // Nettoyage au dÃ©montage
    onCleanup(() => {
        stopPolling();
        gameClient.dispose();
    });

    // Fonctions utilitaires
    const isPlayerReady = () => {
        const state = gameState();
        const currentSession = session();
        if (!state || !currentSession) return false;

        const player = state.players.find(p => p.id === currentSession.playerId);
        return player?.isReady || false;
    };

    const isCurrentPlayer = (playerId: string) => {
        const currentSession = session();
        return currentSession?.playerId === playerId;
    };

    const getPlayerStatus = (player: Player) => {
        if (player.isReady) {
            return "âœ… PrÃªt";
        }
        return "â³ En attente";
    };

    const getSessionStateLabel = (state: SessionState) => {
        switch (state) {
            case SessionState.WAITING: return "En attente";
            case SessionState.IN_PROGRESS: return "En cours";
            case SessionState.FINISHED: return "TerminÃ©e";
            case SessionState.CANCELLED: return "AnnulÃ©e";
            default: return "Inconnue";
        }
    };

    // Actions gRPC
    const createSession = async () => {
        if (!playerName().trim()) {
            setError('Veuillez entrer votre nom');
            return;
        }

        setLoading(true);
        setError('');

        const result = await gameClient.createSession(playerName());

        if (result.success) {
            setSession({
                playerId: result.playerId!,
                sessionCode: result.sessionCode!,
                sessionId: result.sessionId! // Stocker le sessionId aussi
            });

            // Convertir la rÃ©ponse gRPC en Ã©tat local
            if (result.sessionState) {
                setGameState(convertSessionState(result.sessionState));
            } else {
                // CrÃ©er un Ã©tat initial si pas de sessionState
                setGameState({
                    sessionCode: result.sessionCode!,
                    state: SessionState.WAITING,
                    players: [{
                        id: result.playerId!,
                        name: playerName(),
                        score: 0,
                        isReady: true, // Le crÃ©ateur est automatiquement prÃªt
                        isConnected: true,
                        joinedAt: Date.now().toString()
                    }],
                    boardState: "{}"
                });
            }

            setStatusMessage(`Session crÃ©Ã©e ! Code: ${result.sessionCode}`);
        } else {
            setError(result.error || 'Erreur lors de la crÃ©ation');
        }

        setLoading(false);
    };

    const joinSession = async () => {
        if (!playerName().trim() || !sessionCode().trim()) {
            setError('Veuillez entrer votre nom et le code de session');
            return;
        }

        setLoading(true);
        setError('');

        const result = await gameClient.joinSession(sessionCode(), playerName());

        if (result.success) {
            setSession({
                playerId: result.playerId!,
                sessionCode: result.sessionCode!,
                sessionId: result.sessionId! // Stocker le sessionId aussi
            });

            if (result.sessionState) {
                setGameState(convertSessionState(result.sessionState));
            } else {
                // CrÃ©er un Ã©tat initial si pas de sessionState
                setGameState({
                    sessionCode: result.sessionCode!,
                    state: SessionState.WAITING,
                    players: [{
                        id: result.playerId!,
                        name: playerName(),
                        score: 0,
                        isReady: false, // Le nouveau joueur n'est pas encore prÃªt
                        isConnected: true,
                        joinedAt: Date.now().toString()
                    }],
                    boardState: "{}"
                });
            }

            setStatusMessage(`Rejoint la session ${result.sessionCode}`);
        } else {
            setError(result.error || 'Erreur lors du join');
        }

        setLoading(false);
    };

    const setReady = async () => {
        const currentSession = session();
        if (!currentSession) return;

        setLoading(true);

        // Note: Utiliser sessionId pour les appels gRPC
        const result = await gameClient.setPlayerReady(
            currentSession.sessionId, // Utiliser sessionId maintenant
            currentSession.playerId
        );

        if (result.success) {
            // Mettre Ã  jour l'Ã©tat local directement
            setGameState(prev => {
                if (!prev) return null;
                return {
                    ...prev,
                    players: prev.players.map(p =>
                        p.id === currentSession.playerId
                            ? { ...p, isReady: true }
                            : p
                    )
                };
            });

            setStatusMessage('Vous Ãªtes maintenant prÃªt !');

            // VÃ©rifier si la partie a commencÃ©
            if (result.gameStarted) {
                setGameState(prev => prev ? { ...prev, state: SessionState.IN_PROGRESS } : null);
                setStatusMessage('La partie commence !');
            }
        } else {
            setError(result.error || 'Erreur');
        }

        setLoading(false);
    };

    const leaveSession = async () => {
        const currentSession = session();
        if (currentSession) {
            await gameClient.leaveSession(currentSession.sessionId, currentSession.playerId); // Utiliser sessionId
        }

        setSession(null);
        setGameState(null);
        setError('');
        setStatusMessage('');
        setSessionCode('');
    };

    // Polling de l'Ã©tat du jeu
    const startPolling = (sessionId: string) => {
        stopPolling();

        const poll = async () => {
            try {
                const result = await gameClient.getSessionState(sessionId);
                if (result.success && result.sessionState) {
                    setGameState(convertSessionState(result.sessionState));
                } else if (result.error) {
                    console.warn('Erreur polling:', result.error);
                    // Ne pas afficher l'erreur Ã  l'utilisateur pour Ã©viter le spam
                }
            } catch (error) {
                console.warn('Erreur polling:', error);
                // En cas d'erreur rÃ©pÃ©tÃ©e, on peut arrÃªter le polling
            }
        };

        // Poll immÃ©diat puis toutes les 2 secondes
        poll();
        pollInterval = window.setInterval(poll, 2000);
    };

    const stopPolling = () => {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = undefined;
        }
    };

    // Convertir SessionState gRPC vers Ã©tat local
    const convertSessionState = (sessionState: ProtoGameState): GameState => {
        return {
            sessionCode: sessionState.sessionId || '', // Note: sessionId dans le proto
            state: sessionState.state,
            players: sessionState.players.map((p: ProtoPlayer) => ({
                id: p.id,
                name: p.name,
                score: p.score,
                isReady: p.isReady,
                isConnected: p.isConnected,
                joinedAt: p.joinedAt.toString() // bigint vers string
            })),
            boardState: sessionState.boardState || '{}',
            currentTurn: sessionState.currentPlayerId
        };
    };

    // Rendu des joueurs
    const renderPlayers = () => {
        const state = gameState();
        if (!state) return null;

        return (
            <div class="players-section">
                <h3>Joueurs ({state.players.length})</h3>
                <div class="players-list">
                    <For each={state.players}>
                        {(player) => (
                            <div
                                class={`player-card ${isCurrentPlayer(player.id) ? 'current-player' : ''}`}
                            >
                                <div class="player-info">
                  <span class="player-name">
                    {player.name}
                      {isCurrentPlayer(player.id) && <span class="you-indicator"> (Vous)</span>}
                  </span>
                                    <span class="player-score">Score: {player.score}</span>
                                </div>
                                <div class="player-status">
                                    {getPlayerStatus(player)}
                                </div>
                            </div>
                        )}
                    </For>
                </div>

                {/* Section bouton "Je suis prÃªt" */}
                <Show when={gameState()?.state === SessionState.WAITING}>
                    <div class="ready-section">
                        <Show when={!isPlayerReady()}>
                            <button
                                onClick={setReady}
                                disabled={loading()}
                                class="ready-button"
                            >
                                Je suis prÃªt !
                            </button>
                        </Show>
                        <Show when={isPlayerReady()}>
                            <div class="ready-status">
                                âœ… Vous Ãªtes prÃªt ! En attente des autres joueurs...
                            </div>
                        </Show>
                    </div>
                </Show>
            </div>
        );
    };

    // Rendu du plateau de jeu
    const renderGameBoard = () => {
        const state = gameState();
        if (!state) return null;

        return (
            <div class="game-board-section">
                <h3>ðŸŽ® Plateau de Jeu</h3>

                <div class="game-status">
                    <strong>Ã‰tat: {getSessionStateLabel(state.state)}</strong>
                    <Show when={state.currentTurn}>
                        <span class="current-turn">Tour de: <strong>{state.currentTurn}</strong></span>
                    </Show>
                </div>

                <Show when={state.state === SessionState.WAITING}>
                    <div class="waiting-message">
                        <p>â³ En attente que tous les joueurs soient prÃªts...</p>
                        <p>DÃ¨s que tous les joueurs seront prÃªts, le plateau hexagonal apparaÃ®tra !</p>
                    </div>
                </Show>

                <Show when={state.state === SessionState.IN_PROGRESS}>
                    <div class="active-game">
                        <GameBoard gameState={state} />
                    </div>
                </Show>

                <Show when={state.boardState && state.boardState !== "{}"}>
                    <div class="board-preview">
                        <h4>Ã‰tat du plateau (debug) :</h4>
                        <pre class="board-data">
              {JSON.stringify(JSON.parse(state.boardState), null, 2)}
            </pre>
                    </div>
                </Show>
            </div>
        );
    };

    // Composant plateau de jeu hexagonal
    const GameBoard = (props: { gameState: GameState }) => {
        let canvasRef: HTMLCanvasElement;
        let nextTileCanvasRef: HTMLCanvasElement;

        const [nextTile, setNextTile] = createSignal<string | null>(null);
        const [plateauTiles, setPlateauTiles] = createSignal<string[]>(new Array(19).fill(''));

        // Positions hexagonales (identiques Ã  votre App.tsx)
        const hexPositions = [
            [-2, 2], [-2.3, 4], [-2.65, 6], [-1, 1], [-1.3, 3], [-1.6, 5], [-1.95, 7],
            [0, 0],
            [-0.3, 2], [-0.6, 4], [-0.9, 6], [-1.25, 8],
            [0.7, 1], [0.4, 3], [0.1, 5], [-0.2, 7],
            [1.4, 2], [1.1, 4], [0.8, 6],
        ];

        const hexRadius = 35; // Plus petit pour le multiplayer
        const hexWidth = Math.sqrt(3) * hexRadius;
        const hexHeight = 2 * hexRadius;
        const offsetY = 0.45 * hexHeight;

        const drawHexagon = (ctx: CanvasRenderingContext2D, x: number, y: number, radius: number) => {
            const angleStep = Math.PI / 3;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = angleStep * i;
                const xOffset = x + radius * Math.cos(angle);
                const yOffset = y + radius * Math.sin(angle);
                if (i === 0) ctx.moveTo(xOffset, yOffset);
                else ctx.lineTo(xOffset, yOffset);
            }
            ctx.closePath();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        };

        const drawHexagonalGrid = (ctx: CanvasRenderingContext2D, images: string[], canvas: HTMLCanvasElement, onClick?: (index: number) => void) => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#1e1e1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const gridOriginX = canvas.width / 2 - hexWidth;
            const gridOriginY = canvas.height / 2 - 2 * offsetY;

            const clickableAreas: { x: number; y: number; index: number }[] = [];

            hexPositions.forEach(([q, r], index) => {
                const x = gridOriginX + q * hexWidth + r * (hexWidth / 6) + 50;
                const y = gridOriginY + r * offsetY - 50;

                // Dessiner l'hexagone
                drawHexagon(ctx, x, y, hexRadius);

                // Dessiner l'image si elle existe
                if (images[index]) {
                    const img = new Image();
                    img.src = images[index];
                    img.onload = () => {
                        const scaledWidth = img.width / 3;
                        const scaledHeight = img.height / 3;
                        ctx.drawImage(img, x - scaledWidth / 2, y - scaledHeight / 2, scaledWidth, scaledHeight);
                        drawHexagon(ctx, x, y, hexRadius);
                    };
                }

                if (onClick) {
                    clickableAreas.push({ x, y, index });
                }
            });

            if (onClick) {
                canvas.onclick = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickY = e.clientY - rect.top;

                    for (const area of clickableAreas) {
                        const dx = clickX - area.x;
                        const dy = clickY - area.y;
                        if (Math.sqrt(dx * dx + dy * dy) < hexRadius) {
                            onClick(area.index);
                            break;
                        }
                    }
                };
            }
        };

        const handleTileClick = (index: number) => {
            const currentSession = session();
            if (!currentSession) return;

            // VÃ©rifier si c'est le tour du joueur
            if (props.gameState.currentTurn !== currentSession.playerId) {
                setStatusMessage("Ce n'est pas votre tour !");
                return;
            }

            // TODO: ImplÃ©menter le mouvement via gRPC
            console.log(`Clic sur la position ${index}`);
            setStatusMessage(`Mouvement sur la position ${index}`);
        };

        createEffect(() => {
            if (canvasRef) {
                const ctx = canvasRef.getContext('2d');
                if (ctx) {
                    const currentSession = session();
                    const canClick = currentSession && props.gameState.currentTurn === currentSession.playerId;
                    drawHexagonalGrid(ctx, plateauTiles(), canvasRef, canClick ? handleTileClick : undefined);
                }
            }
        });

        createEffect(() => {
            if (nextTileCanvasRef && nextTile()) {
                const ctx = nextTileCanvasRef.getContext('2d');
                if (ctx) {
                    ctx.clearRect(0, 0, nextTileCanvasRef.width, nextTileCanvasRef.height);
                    const img = new Image();
                    img.src = nextTile()!;
                    img.onload = () => {
                        const scale = 0.4;
                        const w = img.width * scale;
                        const h = img.height * scale;
                        ctx.drawImage(img, (120 - w) / 2, (120 - h) / 2, w, h);
                    };
                }
            }
        });

        return (
            <div class="game-board-container">
                <div class="game-controls">
                    <div class="next-tile-section">
                        <h4>Prochaine tuile</h4>
                        <canvas
                            ref={nextTileCanvasRef!}
                            width="120"
                            height="120"
                            class="next-tile-canvas"
                        />
                        <button
                            onClick={() => setNextTile(`/api/tiles/random-${Math.floor(Math.random() * 10)}.png`)}
                            class="generate-tile-button"
                        >
                            ðŸŽ² GÃ©nÃ©rer tuile
                        </button>
                    </div>

                    <div class="turn-info">
                        <Show when={props.gameState.currentTurn}>
                            <div class="current-turn-display">
                                <h4>Tour actuel</h4>
                                <p class="turn-player">
                                    {props.gameState.players.find(p => p.id === props.gameState.currentTurn)?.name || 'Inconnu'}
                                </p>
                                <Show when={session()?.playerId === props.gameState.currentTurn}>
                                    <div class="your-turn">ðŸŽ¯ Ã€ votre tour !</div>
                                </Show>
                            </div>
                        </Show>
                    </div>
                </div>

                <div class="board-canvas-container">
                    <canvas
                        ref={canvasRef!}
                        width="500"
                        height="500"
                        class="game-canvas"
                    />
                    <div class="canvas-instructions">
                        <Show when={session()?.playerId === props.gameState.currentTurn}>
                            <p>âœ¨ Cliquez sur un hexagone pour placer votre tuile</p>
                        </Show>
                        <Show when={session()?.playerId !== props.gameState.currentTurn}>
                            <p>â³ En attente du tour de l'autre joueur...</p>
                        </Show>
                    </div>
                </div>
            </div>
        );
    };

    return (
        <div class="multiplayer-app">
            <h1>ðŸŽ® Take It Easy - Multiplayer</h1>

            {/* Messages d'erreur et de statut */}
            <Show when={error()}>
                <div class="error-message">{error()}</div>
            </Show>

            <Show when={statusMessage()}>
                <div class="status-message">{statusMessage()}</div>
            </Show>

            {/* Interface de connexion */}
            <Show when={!session()}>
                <div class="connection-section">
                    <div class="input-group">
                        <label for="player-name">Nom du joueur :</label>
                        <input
                            id="player-name"
                            type="text"
                            class="player-name-input"
                            value={playerName()}
                            onInput={(e) => setPlayerName(e.target.value)}
                            placeholder="Entrez votre nom"
                            maxLength={20}
                        />
                    </div>

                    <div class="actions">
                        <button
                            onClick={createSession}
                            disabled={loading()}
                            class="create-button"
                        >
                            {loading() ? 'CrÃ©ation...' : 'CrÃ©er une nouvelle session'}
                        </button>

                        <div class="join-section">
                            <input
                                type="text"
                                class="session-code-input"
                                value={sessionCode()}
                                onInput={(e) => setSessionCode(e.target.value.toUpperCase())}
                                placeholder="CODE"
                                maxLength={6}
                            />
                            <button
                                onClick={joinSession}
                                disabled={loading()}
                                class="join-button"
                            >
                                {loading() ? 'Connexion...' : 'Rejoindre'}
                            </button>
                        </div>
                    </div>
                </div>
            </Show>

            {/* Interface de jeu */}
            <Show when={session()}>
                <div class="session-info">
                    <div class="session-details">
                        <h2>ðŸŽ® Session: {session()?.sessionCode}</h2>
                        <p>Joueur: <strong>{playerName()}</strong></p>
                        <p class="player-id">ID: {session()?.playerId}</p>
                    </div>
                    <button onClick={leaveSession} class="leave-button">
                        Quitter la session
                    </button>
                </div>

                {renderPlayers()}
                {renderGameBoard()}
            </Show>

            {/* Styles CSS intÃ©grÃ©s */}
            <style jsx>{`
                .multiplayer-app {
                    max-width: 900px;
                    margin: 0 auto;
                    padding: 20px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    min-height: 100vh;
                    color: white;
                }

                h1 {
                    text-align: center;
                    margin-bottom: 30px;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                }

                .connection-section {
                    background: rgba(255,255,255,0.95);
                    color: #333;
                    padding: 30px;
                    border-radius: 16px;
                    margin-bottom: 20px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.1);
                }

                .input-group {
                    margin-bottom: 20px;
                }

                .input-group label {
                    display: block;
                    margin-bottom: 8px;
                    font-weight: 600;
                    color: #555;
                }

                .player-name-input, .session-code-input {
                    width: 100%;
                    padding: 14px;
                    border: 2px solid #e0e6ed;
                    border-radius: 10px;
                    font-size: 16px;
                    transition: all 0.3s ease;
                }

                .player-name-input:focus, .session-code-input:focus {
                    outline: none;
                    border-color: #667eea;
                    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
                }

                .session-code-input {
                    text-transform: uppercase;
                    letter-spacing: 3px;
                    text-align: center;
                    font-weight: bold;
                    font-size: 18px;
                }

                .actions {
                    display: flex;
                    flex-direction: column;
                    gap: 15px;
                }

                .join-section {
                    display: flex;
                    gap: 12px;
                }

                .join-section input {
                    flex: 1;
                }

                button {
                    padding: 14px 28px;
                    border: none;
                    border-radius: 10px;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }

                .create-button {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                }

                .join-button {
                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                    color: white;
                }

                .leave-button {
                    background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                    color: #333;
                }

                .ready-button {
                    background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
                    color: #333;
                    font-size: 18px;
                    padding: 16px 32px;
                }

                button:hover:not(:disabled) {
                    transform: translateY(-2px);
                    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
                }

                button:disabled {
                    opacity: 0.6;
                    cursor: not-allowed;
                    transform: none;
                }

                .session-info {
                    background: rgba(255,255,255,0.1);
                    backdrop-filter: blur(10px);
                    padding: 24px;
                    border-radius: 16px;
                    margin-bottom: 24px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border: 1px solid rgba(255,255,255,0.2);
                }

                .session-details h2 {
                    margin: 0 0 8px 0;
                    font-size: 24px;
                }

                .session-details p {
                    margin: 4px 0;
                    opacity: 0.9;
                }

                .player-id {
                    font-size: 12px;
                    font-family: monospace;
                    opacity: 0.7;
                }

                .status-message {
                    background: rgba(16, 185, 129, 0.2);
                    color: #10b981;
                    padding: 12px;
                    border-radius: 8px;
                    margin: 10px 0;
                    border: 1px solid rgba(16, 185, 129, 0.3);
                    backdrop-filter: blur(10px);
                }

                .error-message {
                    background: rgba(239, 68, 68, 0.2);
                    color: #ef4444;
                    padding: 12px;
                    border-radius: 8px;
                    margin: 10px 0;
                    border: 1px solid rgba(239, 68, 68, 0.3);
                    backdrop-filter: blur(10px);
                }

                /* Styles pour les joueurs */
                .players-section {
                    background: rgba(255,255,255,0.1);
                    backdrop-filter: blur(10px);
                    padding: 24px;
                    border-radius: 16px;
                    margin: 24px 0;
                    border: 1px solid rgba(255,255,255,0.2);
                }

                .players-section h3 {
                    margin: 0 0 20px 0;
                    font-size: 20px;
                }

                .players-list {
                    display: flex;
                    flex-direction: column;
                    gap: 12px;
                    margin: 20px 0;
                }

                .player-card {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 16px;
                    background: rgba(255,255,255,0.1);
                    border-radius: 12px;
                    border: 1px solid rgba(255,255,255,0.2);
                    backdrop-filter: blur(5px);
                }

                .player-card.current-player {
                    border: 2px solid #a8edea;
                    background: rgba(168, 237, 234, 0.2);
                }

                .player-info {
                    display: flex;
                    flex-direction: column;
                    gap: 4px;
                }

                .player-name {
                    font-weight: bold;
                    font-size: 16px;
                }

                .you-indicator {
                    color: #a8edea;
                    font-size: 12px;
                }

                .player-score {
                    font-size: 14px;
                    opacity: 0.8;
                }

                .player-status {
                    font-size: 14px;
                    font-weight: bold;
                }

                .ready-section {
                    text-align: center;
                    margin: 24px 0;
                    padding: 20px;
                    border-radius: 12px;
                    background: rgba(255,255,255,0.05);
                }

                .ready-status {
                    background: rgba(16, 185, 129, 0.2);
                    color: #10b981;
                    padding: 16px;
                    border-radius: 8px;
                    font-weight: bold;
                    border: 1px solid rgba(16, 185, 129, 0.3);
                }

                /* Styles pour le plateau de jeu */
                .game-board-section {
                    background: rgba(255,255,255,0.1);
                    backdrop-filter: blur(10px);
                    padding: 24px;
                    border-radius: 16px;
                    margin: 24px 0;
                    border: 1px solid rgba(255,255,255,0.2);
                }

                .game-board-section h3 {
                    margin: 0 0 16px 0;
                    font-size: 20px;
                }

                .game-status {
                    background: rgba(255,255,255,0.1);
                    padding: 12px;
                    border-radius: 8px;
                    margin-bottom: 16px;
                    text-align: center;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }

                .current-turn {
                    color: #a8edea;
                    font-weight: bold;
                }

                .waiting-message {
                    text-align: center;
                    font-style: italic;
                    opacity: 0.8;
                    margin: 20px 0;
                }

                .active-game {
                    margin: 20px 0;
                }

                .game-board-container {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 20px;
                    margin: 20px 0;
                }

                .game-controls {
                    display: flex;
                    gap: 30px;
                    align-items: flex-start;
                    background: rgba(255,255,255,0.05);
                    padding: 20px;
                    border-radius: 12px;
                }

                .next-tile-section {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 10px;
                }

                .next-tile-section h4 {
                    margin: 0;
                    color: #a8edea;
                }

                .next-tile-canvas {
                    border: 2px solid rgba(255,255,255,0.2);
                    border-radius: 8px;
                    background: #1e1e1e;
                }

                .generate-tile-button {
                    background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    font-size: 14px;
                    cursor: pointer;
                    transition: all 0.2s;
                }

                .generate-tile-button:hover {
                    transform: translateY(-1px);
                    box-shadow: 0 4px 12px rgba(255, 216, 155, 0.3);
                }

                .turn-info {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    min-width: 150px;
                }

                .current-turn-display h4 {
                    margin: 0 0 8px 0;
                    color: #a8edea;
                }

                .turn-player {
                    font-size: 18px;
                    font-weight: bold;
                    color: white;
                    margin: 0;
                    text-align: center;
                }

                .your-turn {
                    background: rgba(168, 237, 234, 0.2);
                    color: #a8edea;
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-weight: bold;
                    margin-top: 8px;
                    text-align: center;
                    border: 1px solid #a8edea;
                    animation: pulse 2s infinite;
                }

                @keyframes pulse {
                    0% { opacity: 1; }
                    50% { opacity: 0.7; }
                    100% { opacity: 1; }
                }

                .board-canvas-container {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 15px;
                }

                .game-canvas {
                    border: 3px solid rgba(255,255,255,0.2);
                    border-radius: 12px;
                    background: #1e1e1e;
                    cursor: pointer;
                    transition: all 0.3s ease;
                }

                .game-canvas:hover {
                    border-color: #a8edea;
                    box-shadow: 0 0 20px rgba(168, 237, 234, 0.3);
                }

                .canvas-instructions {
                    text-align: center;
                    font-style: italic;
                    color: rgba(255,255,255,0.8);
                }

                .canvas-instructions p {
                    margin: 0;
                    padding: 8px 16px;
                    background: rgba(255,255,255,0.05);
                    border-radius: 6px;
                    border: 1px solid rgba(255,255,255,0.1);
                }

                .board-preview {
                    margin-top: 20px;
                }

                .board-preview h4 {
                    margin: 0 0 12px 0;
                    font-size: 16px;
                }

                .board-data {
                    background: rgba(0,0,0,0.3);
                    color: #e2e8f0;
                    padding: 16px;
                    border-radius: 8px;
                    font-size: 12px;
                    max-height: 200px;
                    overflow-y: auto;
                    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                    border: 1px solid rgba(255,255,255,0.1);
                }

                /* Responsive */
                @media (max-width: 600px) {
                    .multiplayer-app {
                        padding: 12px;
                    }

                    .join-section {
                        flex-direction: column;
                    }

                    .session-info {
                        flex-direction: column;
                        gap: 16px;
                        text-align: center;
                    }

                    button {
                        padding: 12px 20px;
                        font-size: 14px;
                    }
                }
            `}</style>
        </div>
    );
};

export default MultiplayerApp;```

## ðŸ“„ src/services/GameClient.ts
```ts
// src/services/GameClient.ts - Client gRPC-Web unifiÃ© pour Take It Easy
import { GrpcWebFetchTransport } from '@protobuf-ts/grpcweb-transport';
import { SessionServiceClient } from '../generated/session_service.client';
import { GameServiceClient } from '../generated/game_service.client';
import {
    CreateSessionRequest,
    JoinSessionRequest,
    SetReadyRequest,
    GetSessionStateRequest
} from '../generated/session_service';
import type { GameState } from '../generated/common';

export class GameClient {
    private sessionClient: SessionServiceClient;
    private gameClient: GameServiceClient;
    private transport: GrpcWebFetchTransport;

    constructor() {
        // Test direct au serveur Rust pour Ã©viter les problÃ¨mes de proxy
        this.transport = new GrpcWebFetchTransport({
            baseUrl: 'http://localhost:50051', // Direct vers le serveur Rust
            fetchInit: {
                mode: 'cors', // Activer CORS
                credentials: 'omit' // Pas de credentials pour Ã©viter les conflits
            },
            // Configuration gRPC-Web spÃ©cifique
            format: "binary",
            compress: false,
            timeout: 10000, // 10 secondes de timeout
            // Headers explicites
            meta: {
                'content-type': 'application/grpc-web+proto',
                'accept': 'application/grpc-web+proto'
            }
        });

        this.sessionClient = new SessionServiceClient(this.transport);
        this.gameClient = new GameServiceClient(this.transport);
    }

    // CrÃ©er une nouvelle session
    async createSession(playerName: string) {
        try {
            const request: CreateSessionRequest = {
                playerName: playerName,
                maxPlayers: 4, // Valeur par dÃ©faut
                gameMode: "multiplayer"
            };

            const { response } = await this.sessionClient.createSession(request);

            if (response.result.oneofKind === "success") {
                const success = response.result.success;
                return {
                    success: true,
                    sessionCode: success.sessionCode,
                    sessionId: success.sessionId, // Ajouter sessionId
                    playerId: success.playerId,
                    sessionState: success.player ? {
                        sessionId: success.sessionId,
                        players: [success.player],
                        currentPlayerId: success.playerId,
                        state: 0, // WAITING
                        boardState: "{}",
                        turnNumber: 0
                    } as GameState : undefined
                };
            } else if (response.result.oneofKind === "error") {
                return {
                    success: false,
                    error: response.result.error.message
                };
            }

            return {
                success: false,
                error: "RÃ©ponse invalide du serveur"
            };
        } catch (error) {
            console.error('Erreur crÃ©ation session:', error);
            return {
                success: false,
                error: this.extractErrorMessage(error)
            };
        }
    }

    // Rejoindre une session existante
    async joinSession(sessionCode: string, playerName: string) {
        try {
            const request: JoinSessionRequest = {
                sessionCode: sessionCode.toUpperCase(),
                playerName: playerName
            };

            const { response } = await this.sessionClient.joinSession(request);

            if (response.result.oneofKind === "success") {
                const success = response.result.success;
                return {
                    success: true,
                    sessionCode: sessionCode,
                    sessionId: success.sessionId, // Ajouter sessionId
                    playerId: success.playerId,
                    sessionState: success.gameState
                };
            } else if (response.result.oneofKind === "error") {
                return {
                    success: false,
                    error: response.result.error.message
                };
            }

            return {
                success: false,
                error: "RÃ©ponse invalide du serveur"
            };
        } catch (error) {
            console.error('Erreur join session:', error);
            return {
                success: false,
                error: this.extractErrorMessage(error)
            };
        }
    }

    // Marquer un joueur comme prÃªt
    async setPlayerReady(sessionId: string, playerId: string) {
        try {
            const request: SetReadyRequest = {
                sessionId: sessionId,
                playerId: playerId,
                ready: true
            };

            const { response } = await this.sessionClient.setReady(request);

            if (response.success) {
                return {
                    success: true,
                    gameStarted: response.gameStarted
                };
            } else if (response.error) {
                return {
                    success: false,
                    error: response.error.message
                };
            }

            return {
                success: false,
                error: "Ã‰chec de la requÃªte"
            };
        } catch (error) {
            console.error('Erreur set ready:', error);
            return {
                success: false,
                error: this.extractErrorMessage(error)
            };
        }
    }

    // Obtenir l'Ã©tat d'une session
    async getSessionState(sessionId: string) {
        try {
            const request: GetSessionStateRequest = {
                sessionId: sessionId
            };

            const { response } = await this.sessionClient.getSessionState(request);

            if (response.gameState) {
                return {
                    success: true,
                    sessionState: response.gameState
                };
            } else if (response.error) {
                return {
                    success: false,
                    error: response.error.message
                };
            }

            return {
                success: false,
                error: "Aucun Ã©tat de session retournÃ©"
            };
        } catch (error) {
            console.error('Erreur get session state:', error);
            return {
                success: false,
                error: this.extractErrorMessage(error)
            };
        }
    }

    // Quitter une session
    async leaveSession(sessionId: string, playerId: string) {
        try {
            // Note: Vous devez implÃ©menter une mÃ©thode LeaveSession dans votre .proto
            // Pour l'instant, on retourne simplement success
            return { success: true };
        } catch (error) {
            console.error('Erreur leave session:', error);
            return {
                success: false,
                error: this.extractErrorMessage(error)
            };
        }
    }

    // Extraire le message d'erreur
    private extractErrorMessage(error: any): string {
        if (error?.message) {
            return error.message;
        }
        if (typeof error === 'string') {
            return error;
        }
        return 'Erreur de connexion au serveur';
    }

    // Fermer les connexions
    dispose() {
        // Nettoyage si nÃ©cessaire
    }
}

// Instance singleton
export const gameClient = new GameClient();```

## ðŸ“¡ Frontend Generated: src/generated/session_service.client.ts (extrait)
```typescript
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { SessionService } from "./session_service";
import type { GetSessionStateResponse } from "./session_service";
import type { GetSessionStateRequest } from "./session_service";
import type { SetReadyResponse } from "./session_service";
import type { SetReadyRequest } from "./session_service";
import type { JoinSessionResponse } from "./session_service";
import type { JoinSessionRequest } from "./session_service";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { CreateSessionResponse } from "./session_service";
import type { CreateSessionRequest } from "./session_service";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service takeiteasygame.v1.SessionService
 */
export interface ISessionServiceClient {
    /**
     * @generated from protobuf rpc: CreateSession
     */
    createSession(input: CreateSessionRequest, options?: RpcOptions): UnaryCall<CreateSessionRequest, CreateSessionResponse>;
    /**
     * @generated from protobuf rpc: JoinSession
     */
    joinSession(input: JoinSessionRequest, options?: RpcOptions): UnaryCall<JoinSessionRequest, JoinSessionResponse>;
    /**
// ... (fichier tronquÃ©)
```

## ðŸ“¡ Frontend Generated: src/generated/game_service.ts (extrait)
```typescript
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GameState } from "./common";
import { Error } from "./common";
/**
 * @generated from protobuf message takeiteasygame.v1.MakeMoveRequest
 */
export interface MakeMoveRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
    /**
     * @generated from protobuf field: string move_data = 3
     */
// ... (fichier tronquÃ©)
```

## ðŸ“¡ Frontend Generated: src/generated/session_service.ts (extrait)
```typescript
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GameState } from "./common";
import { Error } from "./common";
import { Player } from "./common";
// ============================================================================
// MESSAGES SESSION SERVICE
// ============================================================================

/**
 * @generated from protobuf message takeiteasygame.v1.CreateSessionRequest
 */
export interface CreateSessionRequest {
    /**
     * @generated from protobuf field: string player_name = 1
     */
    playerName: string;
    /**
     * @generated from protobuf field: int32 max_players = 2
// ... (fichier tronquÃ©)
```

## ðŸ“„ package.json
```json
{
  "name": "vite-template-solid",
  "version": "0.0.0",
  "description": "",
  "type": "module",
  "scripts": {
    "start": "vite",
    "dev": "vite",
    "build": "vite build",
    "serve": "vite preview",
    "test": "vitest"
  },
  "license": "MIT",
  "devDependencies": {
    "@protobuf-ts/plugin": "^2.11.0",
    "@solidjs/testing-library": "^0.8.10",
    "@testing-library/jest-dom": "^6.6.3",
    "jsdom": "^25.0.1",
    "typescript": "^5.7.2",
    "vite": "^6.0.0",
    "vite-plugin-solid": "2.11.2",
    "vitest": "^3.0.0"
  },
  "dependencies": {
    "@protobuf-ts/grpcweb-transport": "^2.11.0",
    "@protobuf-ts/runtime": "^2.11.0",
    "@protobuf-ts/runtime-rpc": "^2.11.0",
    "solid-js": "^1.9.5"
  }
}
```

## ðŸ“„ vite.config.ts
```ts
import { defineConfig } from 'vite';
import solid from 'vite-plugin-solid';

export default defineConfig({
  plugins: [solid()],
  server: {
    port: 3000,
    proxy: {
      // Proxy pour gRPC-Web - redirige vers votre serveur Rust
      '/takeiteasygame.v1.SessionService': {
        target: 'http://localhost:50051',
        changeOrigin: true,
        headers: {
          'Content-Type': 'application/grpc-web+proto'
        }
      },
      '/takeiteasygame.v1.GameService': {
        target: 'http://localhost:50051',
        changeOrigin: true,
        headers: {
          'Content-Type': 'application/grpc-web+proto'
        }
      }
    }
  },
  define: {
    // Variables d'environnement pour le dÃ©veloppement
    __GRPC_WEB_ENDPOINT__: JSON.stringify('http://localhost:50051'),
  },
  optimizeDeps: {
    // Inclure les dÃ©pendances gRPC-Web dans l'optimisation
    include: [
      '@protobuf-ts/runtime',
      '@protobuf-ts/runtime-rpc',
      '@protobuf-ts/grpcweb-transport'
    ]
  }
});```

## ðŸ“„ tsconfig.json
```json
{
  "compilerOptions": {
    "strict": true,
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "types": ["vite/client", "@testing-library/jest-dom"]
  }
}
```

## ðŸ“„ src/todo-list.tsx
```tsx
import { For } from 'solid-js';
import { createStore } from 'solid-js/store';

type Todo = { id: number; text: string; completed: boolean };

export const TodoList = () => {
  let input!: HTMLInputElement;
  const [todos, setTodos] = createStore<Todo[]>([]);
  const addTodo = (text: string) => {
    setTodos(todos.length, { id: todos.length, text, completed: false });
  };
  const toggleTodo = (id: number) => {
    setTodos(id, 'completed', (c) => !c);
  };

  return (
    <>
      <div>
        <input placeholder="new todo here" ref={input} />
        <button
          onClick={() => {
            if (!input.value.trim()) return;
            addTodo(input.value);
            input.value = '';
          }}
        >
          Add Todo
        </button>
      </div>
      <div>
        <For each={todos}>
          {(todo) => {
            const { id, text } = todo;
            return (
              <div>
                <input
                  type="checkbox"
                  checked={todo.completed}
                  onchange={[toggleTodo, id]}
                />
                <span
                  style={{
                    'text-decoration': todo.completed ? 'line-through' : 'none',
                  }}
                >
                  {text}
                </span>
              </div>
            );
          }}
        </For>
      </div>
    </>
  );
};
```

## ðŸ“„ src/generated/session_service.client.ts
```ts
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { SessionService } from "./session_service";
import type { GetSessionStateResponse } from "./session_service";
import type { GetSessionStateRequest } from "./session_service";
import type { SetReadyResponse } from "./session_service";
import type { SetReadyRequest } from "./session_service";
import type { JoinSessionResponse } from "./session_service";
import type { JoinSessionRequest } from "./session_service";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { CreateSessionResponse } from "./session_service";
import type { CreateSessionRequest } from "./session_service";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service takeiteasygame.v1.SessionService
 */
export interface ISessionServiceClient {
    /**
     * @generated from protobuf rpc: CreateSession
     */
    createSession(input: CreateSessionRequest, options?: RpcOptions): UnaryCall<CreateSessionRequest, CreateSessionResponse>;
    /**
     * @generated from protobuf rpc: JoinSession
     */
    joinSession(input: JoinSessionRequest, options?: RpcOptions): UnaryCall<JoinSessionRequest, JoinSessionResponse>;
    /**
     * @generated from protobuf rpc: SetReady
     */
    setReady(input: SetReadyRequest, options?: RpcOptions): UnaryCall<SetReadyRequest, SetReadyResponse>;
    /**
     * @generated from protobuf rpc: GetSessionState
     */
    getSessionState(input: GetSessionStateRequest, options?: RpcOptions): UnaryCall<GetSessionStateRequest, GetSessionStateResponse>;
}
/**
 * @generated from protobuf service takeiteasygame.v1.SessionService
 */
export class SessionServiceClient implements ISessionServiceClient, ServiceInfo {
    typeName = SessionService.typeName;
    methods = SessionService.methods;
    options = SessionService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * @generated from protobuf rpc: CreateSession
     */
    createSession(input: CreateSessionRequest, options?: RpcOptions): UnaryCall<CreateSessionRequest, CreateSessionResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateSessionRequest, CreateSessionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: JoinSession
     */
    joinSession(input: JoinSessionRequest, options?: RpcOptions): UnaryCall<JoinSessionRequest, JoinSessionResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<JoinSessionRequest, JoinSessionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: SetReady
     */
    setReady(input: SetReadyRequest, options?: RpcOptions): UnaryCall<SetReadyRequest, SetReadyResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetReadyRequest, SetReadyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: GetSessionState
     */
    getSessionState(input: GetSessionStateRequest, options?: RpcOptions): UnaryCall<GetSessionStateRequest, GetSessionStateResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSessionStateRequest, GetSessionStateResponse>("unary", this._transport, method, opt, input);
    }
}
```

## ðŸ“„ src/generated/game_service.ts
```ts
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GameState } from "./common";
import { Error } from "./common";
/**
 * @generated from protobuf message takeiteasygame.v1.MakeMoveRequest
 */
export interface MakeMoveRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
    /**
     * @generated from protobuf field: string move_data = 3
     */
    moveData: string; // JSON du mouvement
    /**
     * @generated from protobuf field: int64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message takeiteasygame.v1.MakeMoveResponse
 */
export interface MakeMoveResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: takeiteasygame.v1.MakeMoveSuccess success = 1
         */
        success: MakeMoveSuccess;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: takeiteasygame.v1.Error error = 2
         */
        error: Error;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message takeiteasygame.v1.MakeMoveSuccess
 */
export interface MakeMoveSuccess {
    /**
     * @generated from protobuf field: takeiteasygame.v1.GameState new_game_state = 1
     */
    newGameState?: GameState;
    /**
     * @generated from protobuf field: string mcts_response = 2
     */
    mctsResponse: string; // RÃ©ponse de l'IA si applicable
    /**
     * @generated from protobuf field: int32 points_earned = 3
     */
    pointsEarned: number;
    /**
     * @generated from protobuf field: bool is_game_over = 4
     */
    isGameOver: boolean;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GetAvailableMovesRequest
 */
export interface GetAvailableMovesRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GetAvailableMovesResponse
 */
export interface GetAvailableMovesResponse {
    /**
     * @generated from protobuf field: repeated string available_moves = 1
     */
    availableMoves: string[]; // JSON des mouvements possibles
    /**
     * @generated from protobuf field: takeiteasygame.v1.Error error = 2
     */
    error?: Error;
}
// @generated message type with reflection information, may provide speed optimized methods
class MakeMoveRequest$Type extends MessageType<MakeMoveRequest> {
    constructor() {
        super("takeiteasygame.v1.MakeMoveRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "move_data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MakeMoveRequest>): MakeMoveRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.playerId = "";
        message.moveData = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<MakeMoveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveRequest): MakeMoveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 2:
                    message.playerId = reader.string();
                    break;
                case /* string move_data */ 3:
                    message.moveData = reader.string();
                    break;
                case /* int64 timestamp */ 4:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MakeMoveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 2; */
        if (message.playerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
        /* string move_data = 3; */
        if (message.moveData !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.moveData);
        /* int64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveRequest
 */
export const MakeMoveRequest = new MakeMoveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MakeMoveResponse$Type extends MessageType<MakeMoveResponse> {
    constructor() {
        super("takeiteasygame.v1.MakeMoveResponse", [
            { no: 1, name: "success", kind: "message", oneof: "result", T: () => MakeMoveSuccess },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<MakeMoveResponse>): MakeMoveResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MakeMoveResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveResponse): MakeMoveResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.MakeMoveSuccess success */ 1:
                    message.result = {
                        oneofKind: "success",
                        success: MakeMoveSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
                    };
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: Error.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MakeMoveResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.MakeMoveSuccess success = 1; */
        if (message.result.oneofKind === "success")
            MakeMoveSuccess.internalBinaryWrite(message.result.success, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* takeiteasygame.v1.Error error = 2; */
        if (message.result.oneofKind === "error")
            Error.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveResponse
 */
export const MakeMoveResponse = new MakeMoveResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MakeMoveSuccess$Type extends MessageType<MakeMoveSuccess> {
    constructor() {
        super("takeiteasygame.v1.MakeMoveSuccess", [
            { no: 1, name: "new_game_state", kind: "message", T: () => GameState },
            { no: 2, name: "mcts_response", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "points_earned", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "is_game_over", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MakeMoveSuccess>): MakeMoveSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mctsResponse = "";
        message.pointsEarned = 0;
        message.isGameOver = false;
        if (value !== undefined)
            reflectionMergePartial<MakeMoveSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveSuccess): MakeMoveSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.GameState new_game_state */ 1:
                    message.newGameState = GameState.internalBinaryRead(reader, reader.uint32(), options, message.newGameState);
                    break;
                case /* string mcts_response */ 2:
                    message.mctsResponse = reader.string();
                    break;
                case /* int32 points_earned */ 3:
                    message.pointsEarned = reader.int32();
                    break;
                case /* bool is_game_over */ 4:
                    message.isGameOver = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MakeMoveSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.GameState new_game_state = 1; */
        if (message.newGameState)
            GameState.internalBinaryWrite(message.newGameState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string mcts_response = 2; */
        if (message.mctsResponse !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mctsResponse);
        /* int32 points_earned = 3; */
        if (message.pointsEarned !== 0)
            writer.tag(3, WireType.Varint).int32(message.pointsEarned);
        /* bool is_game_over = 4; */
        if (message.isGameOver !== false)
            writer.tag(4, WireType.Varint).bool(message.isGameOver);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveSuccess
 */
export const MakeMoveSuccess = new MakeMoveSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAvailableMovesRequest$Type extends MessageType<GetAvailableMovesRequest> {
    constructor() {
        super("takeiteasygame.v1.GetAvailableMovesRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAvailableMovesRequest>): GetAvailableMovesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<GetAvailableMovesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAvailableMovesRequest): GetAvailableMovesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 2:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAvailableMovesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 2; */
        if (message.playerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetAvailableMovesRequest
 */
export const GetAvailableMovesRequest = new GetAvailableMovesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAvailableMovesResponse$Type extends MessageType<GetAvailableMovesResponse> {
    constructor() {
        super("takeiteasygame.v1.GetAvailableMovesResponse", [
            { no: 1, name: "available_moves", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<GetAvailableMovesResponse>): GetAvailableMovesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.availableMoves = [];
        if (value !== undefined)
            reflectionMergePartial<GetAvailableMovesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAvailableMovesResponse): GetAvailableMovesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string available_moves */ 1:
                    message.availableMoves.push(reader.string());
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAvailableMovesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string available_moves = 1; */
        for (let i = 0; i < message.availableMoves.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.availableMoves[i]);
        /* takeiteasygame.v1.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetAvailableMovesResponse
 */
export const GetAvailableMovesResponse = new GetAvailableMovesResponse$Type();
/**
 * @generated ServiceType for protobuf service takeiteasygame.v1.GameService
 */
export const GameService = new ServiceType("takeiteasygame.v1.GameService", [
    { name: "MakeMove", options: {}, I: MakeMoveRequest, O: MakeMoveResponse },
    { name: "GetAvailableMoves", options: {}, I: GetAvailableMovesRequest, O: GetAvailableMovesResponse }
]);
```

## ðŸ“„ src/generated/session_service.ts
```ts
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GameState } from "./common";
import { Error } from "./common";
import { Player } from "./common";
// ============================================================================
// MESSAGES SESSION SERVICE
// ============================================================================

/**
 * @generated from protobuf message takeiteasygame.v1.CreateSessionRequest
 */
export interface CreateSessionRequest {
    /**
     * @generated from protobuf field: string player_name = 1
     */
    playerName: string;
    /**
     * @generated from protobuf field: int32 max_players = 2
     */
    maxPlayers: number;
    /**
     * @generated from protobuf field: string game_mode = 3
     */
    gameMode: string;
}
/**
 * @generated from protobuf message takeiteasygame.v1.CreateSessionSuccess
 */
export interface CreateSessionSuccess {
    /**
     * @generated from protobuf field: string session_code = 1
     */
    sessionCode: string;
    /**
     * @generated from protobuf field: string session_id = 2
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 3
     */
    playerId: string;
    /**
     * @generated from protobuf field: takeiteasygame.v1.Player player = 4
     */
    player?: Player;
}
/**
 * @generated from protobuf message takeiteasygame.v1.CreateSessionResponse
 */
export interface CreateSessionResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: takeiteasygame.v1.CreateSessionSuccess success = 1
         */
        success: CreateSessionSuccess;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: takeiteasygame.v1.Error error = 2
         */
        error: Error;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message takeiteasygame.v1.JoinSessionRequest
 */
export interface JoinSessionRequest {
    /**
     * @generated from protobuf field: string session_code = 1
     */
    sessionCode: string;
    /**
     * @generated from protobuf field: string player_name = 2
     */
    playerName: string;
}
/**
 * @generated from protobuf message takeiteasygame.v1.JoinSessionSuccess
 */
export interface JoinSessionSuccess {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
    /**
     * @generated from protobuf field: takeiteasygame.v1.GameState game_state = 3
     */
    gameState?: GameState;
}
/**
 * @generated from protobuf message takeiteasygame.v1.JoinSessionResponse
 */
export interface JoinSessionResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: takeiteasygame.v1.JoinSessionSuccess success = 1
         */
        success: JoinSessionSuccess;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: takeiteasygame.v1.Error error = 2
         */
        error: Error;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message takeiteasygame.v1.SetReadyRequest
 */
export interface SetReadyRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
    /**
     * @generated from protobuf field: bool ready = 3
     */
    ready: boolean;
}
/**
 * @generated from protobuf message takeiteasygame.v1.SetReadyResponse
 */
export interface SetReadyResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: takeiteasygame.v1.Error error = 2
     */
    error?: Error;
    /**
     * @generated from protobuf field: bool game_started = 3
     */
    gameStarted: boolean;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GetSessionStateRequest
 */
export interface GetSessionStateRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GetSessionStateResponse
 */
export interface GetSessionStateResponse {
    /**
     * @generated from protobuf field: takeiteasygame.v1.GameState game_state = 1
     */
    gameState?: GameState;
    /**
     * @generated from protobuf field: takeiteasygame.v1.Error error = 2
     */
    error?: Error;
}
// @generated message type with reflection information, may provide speed optimized methods
class CreateSessionRequest$Type extends MessageType<CreateSessionRequest> {
    constructor() {
        super("takeiteasygame.v1.CreateSessionRequest", [
            { no: 1, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "max_players", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "game_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateSessionRequest>): CreateSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerName = "";
        message.maxPlayers = 0;
        message.gameMode = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionRequest): CreateSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_name */ 1:
                    message.playerName = reader.string();
                    break;
                case /* int32 max_players */ 2:
                    message.maxPlayers = reader.int32();
                    break;
                case /* string game_mode */ 3:
                    message.gameMode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_name = 1; */
        if (message.playerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerName);
        /* int32 max_players = 2; */
        if (message.maxPlayers !== 0)
            writer.tag(2, WireType.Varint).int32(message.maxPlayers);
        /* string game_mode = 3; */
        if (message.gameMode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.gameMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.CreateSessionRequest
 */
export const CreateSessionRequest = new CreateSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSessionSuccess$Type extends MessageType<CreateSessionSuccess> {
    constructor() {
        super("takeiteasygame.v1.CreateSessionSuccess", [
            { no: 1, name: "session_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<CreateSessionSuccess>): CreateSessionSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionCode = "";
        message.sessionId = "";
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSessionSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionSuccess): CreateSessionSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_code */ 1:
                    message.sessionCode = reader.string();
                    break;
                case /* string session_id */ 2:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 3:
                    message.playerId = reader.string();
                    break;
                case /* takeiteasygame.v1.Player player */ 4:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSessionSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_code = 1; */
        if (message.sessionCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionCode);
        /* string session_id = 2; */
        if (message.sessionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 3; */
        if (message.playerId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.playerId);
        /* takeiteasygame.v1.Player player = 4; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.CreateSessionSuccess
 */
export const CreateSessionSuccess = new CreateSessionSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSessionResponse$Type extends MessageType<CreateSessionResponse> {
    constructor() {
        super("takeiteasygame.v1.CreateSessionResponse", [
            { no: 1, name: "success", kind: "message", oneof: "result", T: () => CreateSessionSuccess },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<CreateSessionResponse>): CreateSessionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CreateSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionResponse): CreateSessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.CreateSessionSuccess success */ 1:
                    message.result = {
                        oneofKind: "success",
                        success: CreateSessionSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
                    };
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: Error.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.CreateSessionSuccess success = 1; */
        if (message.result.oneofKind === "success")
            CreateSessionSuccess.internalBinaryWrite(message.result.success, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* takeiteasygame.v1.Error error = 2; */
        if (message.result.oneofKind === "error")
            Error.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.CreateSessionResponse
 */
export const CreateSessionResponse = new CreateSessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JoinSessionRequest$Type extends MessageType<JoinSessionRequest> {
    constructor() {
        super("takeiteasygame.v1.JoinSessionRequest", [
            { no: 1, name: "session_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JoinSessionRequest>): JoinSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionCode = "";
        message.playerName = "";
        if (value !== undefined)
            reflectionMergePartial<JoinSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinSessionRequest): JoinSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_code */ 1:
                    message.sessionCode = reader.string();
                    break;
                case /* string player_name */ 2:
                    message.playerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_code = 1; */
        if (message.sessionCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionCode);
        /* string player_name = 2; */
        if (message.playerName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.JoinSessionRequest
 */
export const JoinSessionRequest = new JoinSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JoinSessionSuccess$Type extends MessageType<JoinSessionSuccess> {
    constructor() {
        super("takeiteasygame.v1.JoinSessionSuccess", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "game_state", kind: "message", T: () => GameState }
        ]);
    }
    create(value?: PartialMessage<JoinSessionSuccess>): JoinSessionSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<JoinSessionSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinSessionSuccess): JoinSessionSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 2:
                    message.playerId = reader.string();
                    break;
                case /* takeiteasygame.v1.GameState game_state */ 3:
                    message.gameState = GameState.internalBinaryRead(reader, reader.uint32(), options, message.gameState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinSessionSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 2; */
        if (message.playerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
        /* takeiteasygame.v1.GameState game_state = 3; */
        if (message.gameState)
            GameState.internalBinaryWrite(message.gameState, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.JoinSessionSuccess
 */
export const JoinSessionSuccess = new JoinSessionSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JoinSessionResponse$Type extends MessageType<JoinSessionResponse> {
    constructor() {
        super("takeiteasygame.v1.JoinSessionResponse", [
            { no: 1, name: "success", kind: "message", oneof: "result", T: () => JoinSessionSuccess },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<JoinSessionResponse>): JoinSessionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<JoinSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinSessionResponse): JoinSessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.JoinSessionSuccess success */ 1:
                    message.result = {
                        oneofKind: "success",
                        success: JoinSessionSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
                    };
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: Error.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.JoinSessionSuccess success = 1; */
        if (message.result.oneofKind === "success")
            JoinSessionSuccess.internalBinaryWrite(message.result.success, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* takeiteasygame.v1.Error error = 2; */
        if (message.result.oneofKind === "error")
            Error.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.JoinSessionResponse
 */
export const JoinSessionResponse = new JoinSessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetReadyRequest$Type extends MessageType<SetReadyRequest> {
    constructor() {
        super("takeiteasygame.v1.SetReadyRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ready", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetReadyRequest>): SetReadyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.playerId = "";
        message.ready = false;
        if (value !== undefined)
            reflectionMergePartial<SetReadyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReadyRequest): SetReadyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 2:
                    message.playerId = reader.string();
                    break;
                case /* bool ready */ 3:
                    message.ready = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetReadyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 2; */
        if (message.playerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
        /* bool ready = 3; */
        if (message.ready !== false)
            writer.tag(3, WireType.Varint).bool(message.ready);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.SetReadyRequest
 */
export const SetReadyRequest = new SetReadyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetReadyResponse$Type extends MessageType<SetReadyResponse> {
    constructor() {
        super("takeiteasygame.v1.SetReadyResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error", kind: "message", T: () => Error },
            { no: 3, name: "game_started", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetReadyResponse>): SetReadyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.gameStarted = false;
        if (value !== undefined)
            reflectionMergePartial<SetReadyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReadyResponse): SetReadyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* bool game_started */ 3:
                    message.gameStarted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetReadyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* takeiteasygame.v1.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool game_started = 3; */
        if (message.gameStarted !== false)
            writer.tag(3, WireType.Varint).bool(message.gameStarted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.SetReadyResponse
 */
export const SetReadyResponse = new SetReadyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSessionStateRequest$Type extends MessageType<GetSessionStateRequest> {
    constructor() {
        super("takeiteasygame.v1.GetSessionStateRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSessionStateRequest>): GetSessionStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        if (value !== undefined)
            reflectionMergePartial<GetSessionStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSessionStateRequest): GetSessionStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSessionStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetSessionStateRequest
 */
export const GetSessionStateRequest = new GetSessionStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSessionStateResponse$Type extends MessageType<GetSessionStateResponse> {
    constructor() {
        super("takeiteasygame.v1.GetSessionStateResponse", [
            { no: 1, name: "game_state", kind: "message", T: () => GameState },
            { no: 2, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<GetSessionStateResponse>): GetSessionStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSessionStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSessionStateResponse): GetSessionStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.GameState game_state */ 1:
                    message.gameState = GameState.internalBinaryRead(reader, reader.uint32(), options, message.gameState);
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSessionStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.GameState game_state = 1; */
        if (message.gameState)
            GameState.internalBinaryWrite(message.gameState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* takeiteasygame.v1.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetSessionStateResponse
 */
export const GetSessionStateResponse = new GetSessionStateResponse$Type();
/**
 * @generated ServiceType for protobuf service takeiteasygame.v1.SessionService
 */
export const SessionService = new ServiceType("takeiteasygame.v1.SessionService", [
    { name: "CreateSession", options: {}, I: CreateSessionRequest, O: CreateSessionResponse },
    { name: "JoinSession", options: {}, I: JoinSessionRequest, O: JoinSessionResponse },
    { name: "SetReady", options: {}, I: SetReadyRequest, O: SetReadyResponse },
    { name: "GetSessionState", options: {}, I: GetSessionStateRequest, O: GetSessionStateResponse }
]);
```

## ðŸ“„ src/generated/common.ts
```ts
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "common.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Types communs partagÃ©s entre services
 *
 * @generated from protobuf message takeiteasygame.v1.Player
 */
export interface Player {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: int32 score = 3
     */
    score: number;
    /**
     * @generated from protobuf field: bool is_ready = 4
     */
    isReady: boolean;
    /**
     * @generated from protobuf field: bool is_connected = 5
     */
    isConnected: boolean;
    /**
     * @generated from protobuf field: int64 joined_at = 6
     */
    joinedAt: bigint;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GameState
 */
export interface GameState {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: repeated takeiteasygame.v1.Player players = 2
     */
    players: Player[];
    /**
     * @generated from protobuf field: string current_player_id = 3
     */
    currentPlayerId: string;
    /**
     * @generated from protobuf field: takeiteasygame.v1.SessionState state = 4
     */
    state: SessionState;
    /**
     * @generated from protobuf field: string board_state = 5
     */
    boardState: string; // JSON serialized board
    /**
     * @generated from protobuf field: int32 turn_number = 6
     */
    turnNumber: number;
}
/**
 * @generated from protobuf message takeiteasygame.v1.Error
 */
export interface Error {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: map<string, string> details = 3
     */
    details: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf enum takeiteasygame.v1.SessionState
 */
export enum SessionState {
    /**
     * @generated from protobuf enum value: WAITING = 0;
     */
    WAITING = 0,
    /**
     * @generated from protobuf enum value: IN_PROGRESS = 1;
     */
    IN_PROGRESS = 1,
    /**
     * @generated from protobuf enum value: FINISHED = 2;
     */
    FINISHED = 2,
    /**
     * @generated from protobuf enum value: CANCELLED = 3;
     */
    CANCELLED = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Player$Type extends MessageType<Player> {
    constructor() {
        super("takeiteasygame.v1.Player", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "is_ready", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "joined_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Player>): Player {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.score = 0;
        message.isReady = false;
        message.isConnected = false;
        message.joinedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<Player>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Player): Player {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 score */ 3:
                    message.score = reader.int32();
                    break;
                case /* bool is_ready */ 4:
                    message.isReady = reader.bool();
                    break;
                case /* bool is_connected */ 5:
                    message.isConnected = reader.bool();
                    break;
                case /* int64 joined_at */ 6:
                    message.joinedAt = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 score = 3; */
        if (message.score !== 0)
            writer.tag(3, WireType.Varint).int32(message.score);
        /* bool is_ready = 4; */
        if (message.isReady !== false)
            writer.tag(4, WireType.Varint).bool(message.isReady);
        /* bool is_connected = 5; */
        if (message.isConnected !== false)
            writer.tag(5, WireType.Varint).bool(message.isConnected);
        /* int64 joined_at = 6; */
        if (message.joinedAt !== 0n)
            writer.tag(6, WireType.Varint).int64(message.joinedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.Player
 */
export const Player = new Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameState$Type extends MessageType<GameState> {
    constructor() {
        super("takeiteasygame.v1.GameState", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "players", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Player },
            { no: 3, name: "current_player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "state", kind: "enum", T: () => ["takeiteasygame.v1.SessionState", SessionState] },
            { no: 5, name: "board_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "turn_number", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GameState>): GameState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.players = [];
        message.currentPlayerId = "";
        message.state = 0;
        message.boardState = "";
        message.turnNumber = 0;
        if (value !== undefined)
            reflectionMergePartial<GameState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameState): GameState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* repeated takeiteasygame.v1.Player players */ 2:
                    message.players.push(Player.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string current_player_id */ 3:
                    message.currentPlayerId = reader.string();
                    break;
                case /* takeiteasygame.v1.SessionState state */ 4:
                    message.state = reader.int32();
                    break;
                case /* string board_state */ 5:
                    message.boardState = reader.string();
                    break;
                case /* int32 turn_number */ 6:
                    message.turnNumber = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* repeated takeiteasygame.v1.Player players = 2; */
        for (let i = 0; i < message.players.length; i++)
            Player.internalBinaryWrite(message.players[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string current_player_id = 3; */
        if (message.currentPlayerId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.currentPlayerId);
        /* takeiteasygame.v1.SessionState state = 4; */
        if (message.state !== 0)
            writer.tag(4, WireType.Varint).int32(message.state);
        /* string board_state = 5; */
        if (message.boardState !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.boardState);
        /* int32 turn_number = 6; */
        if (message.turnNumber !== 0)
            writer.tag(6, WireType.Varint).int32(message.turnNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GameState
 */
export const GameState = new GameState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Error$Type extends MessageType<Error> {
    constructor() {
        super("takeiteasygame.v1.Error", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "details", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<Error>): Error {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.message = "";
        message.details = {};
        if (value !== undefined)
            reflectionMergePartial<Error>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Error): Error {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* map<string, string> details */ 3:
                    this.binaryReadMap3(message.details, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Error["details"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Error["details"] | undefined, val: Error["details"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for takeiteasygame.v1.Error.details");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Error, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* map<string, string> details = 3; */
        for (let k of globalThis.Object.keys(message.details))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.details[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.Error
 */
export const Error = new Error$Type();
```

## ðŸ“„ src/generated/game_service.client.ts
```ts
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { GameService } from "./game_service";
import type { GetAvailableMovesResponse } from "./game_service";
import type { GetAvailableMovesRequest } from "./game_service";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { MakeMoveResponse } from "./game_service";
import type { MakeMoveRequest } from "./game_service";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service takeiteasygame.v1.GameService
 */
export interface IGameServiceClient {
    /**
     * Faire un mouvement
     *
     * @generated from protobuf rpc: MakeMove
     */
    makeMove(input: MakeMoveRequest, options?: RpcOptions): UnaryCall<MakeMoveRequest, MakeMoveResponse>;
    /**
     * Obtenir les mouvements disponibles
     *
     * @generated from protobuf rpc: GetAvailableMoves
     */
    getAvailableMoves(input: GetAvailableMovesRequest, options?: RpcOptions): UnaryCall<GetAvailableMovesRequest, GetAvailableMovesResponse>;
}
/**
 * @generated from protobuf service takeiteasygame.v1.GameService
 */
export class GameServiceClient implements IGameServiceClient, ServiceInfo {
    typeName = GameService.typeName;
    methods = GameService.methods;
    options = GameService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Faire un mouvement
     *
     * @generated from protobuf rpc: MakeMove
     */
    makeMove(input: MakeMoveRequest, options?: RpcOptions): UnaryCall<MakeMoveRequest, MakeMoveResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<MakeMoveRequest, MakeMoveResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Obtenir les mouvements disponibles
     *
     * @generated from protobuf rpc: GetAvailableMoves
     */
    getAvailableMoves(input: GetAvailableMovesRequest, options?: RpcOptions): UnaryCall<GetAvailableMovesRequest, GetAvailableMovesResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetAvailableMovesRequest, GetAvailableMovesResponse>("unary", this._transport, method, opt, input);
    }
}
```

## ðŸ“„ src/index.tsx
```tsx
// src/index.tsx
import { render } from 'solid-js/web';
import MultiplayerApp from './components/MultiplayerApp';

const root = document.getElementById('root');

if (import.meta.env.DEV && !(root instanceof HTMLElement)) {
  throw new Error(
      'Root element not found. Did you forget to add it to your index.html? Or maybe the id attribute got misspelled?',
  );
}

render(() => <MultiplayerApp />, root!);```

## ðŸ“„ src/todo-list.test.tsx
```tsx
import { render, fireEvent } from '@solidjs/testing-library';

import { TodoList } from './todo-list';
import { describe, expect, test } from 'vitest';

describe('<TodoList />', () => {
  test('it will render an text input and a button', () => {
    const { getByPlaceholderText, getByText } = render(() => <TodoList />);
    expect(getByPlaceholderText('new todo here')).toBeInTheDocument();
    expect(getByText('Add Todo')).toBeInTheDocument();
  });

  test('it will add a new todo', async () => {
    const { getByPlaceholderText, getByText } = render(() => <TodoList />);
    const input = getByPlaceholderText('new todo here') as HTMLInputElement;
    const button = getByText('Add Todo');
    input.value = 'test new todo';
    fireEvent.click(button as HTMLInputElement);
    expect(input.value).toBe('');
    expect(getByText(/test new todo/)).toBeInTheDocument();
  });

  test('it will mark a todo as completed', async () => {
    const { getByPlaceholderText, findByRole, getByText } = render(() => (
      <TodoList />
    ));
    const input = getByPlaceholderText('new todo here') as HTMLInputElement;
    const button = getByText('Add Todo') as HTMLButtonElement;
    input.value = 'mark new todo as completed';
    fireEvent.click(button);
    const completed = (await findByRole('checkbox')) as HTMLInputElement;
    expect(completed?.checked).toBe(false);
    fireEvent.click(completed);
    expect(completed?.checked).toBe(true);
    const text = getByText('mark new todo as completed') as HTMLSpanElement;
    expect(text).toHaveStyle({ 'text-decoration': 'line-through' });
  });
});
```

## ðŸ“„ src/components/MultiplayerApp.tsx
```tsx
// src/components/MultiplayerApp.tsx - Interface multiplayer avec gRPC
import { Component, createSignal, createEffect, onMount, Show, For, onCleanup } from 'solid-js';
import { gameClient } from '../services/GameClient';

// Import des types gÃ©nÃ©rÃ©s depuis vos fichiers
import { SessionState } from '../generated/common';
import type { Player as ProtoPlayer, GameState as ProtoGameState } from '../generated/common';

// Types pour l'Ã©tat local (adaptÃ©s de vos protos)
interface Player {
    id: string;
    name: string;
    score: number;
    isReady: boolean;
    isConnected: boolean;
    joinedAt: string;
}

interface GameState {
    sessionCode: string;
    state: SessionState;
    players: Player[];
    boardState: string;
    currentTurn?: string;
}

interface Session {
    playerId: string;
    sessionCode: string;
    sessionId: string; // Ajout du sessionId pour les appels gRPC
}

const MultiplayerApp: Component = () => {
    // Signaux SolidJS
    const [playerName, setPlayerName] = createSignal('');
    const [sessionCode, setSessionCode] = createSignal('');
    const [gameState, setGameState] = createSignal<GameState | null>(null);
    const [session, setSession] = createSignal<Session | null>(null);
    const [loading, setLoading] = createSignal(false);
    const [error, setError] = createSignal('');
    const [statusMessage, setStatusMessage] = createSignal('');

    // Polling pour l'Ã©tat du jeu
    let pollInterval: number | undefined;

    // DÃ©marrer le polling quand on rejoint une session
    createEffect(() => {
        const currentSession = session();
        if (currentSession) {
            // RÃ©activer le polling pour synchroniser les joueurs
            startPolling(currentSession.sessionId);
            console.log('Polling activÃ© pour session:', currentSession.sessionCode, 'ID:', currentSession.sessionId);
        } else {
            stopPolling();
        }
    });

    // Nettoyage au dÃ©montage
    onCleanup(() => {
        stopPolling();
        gameClient.dispose();
    });

    // Fonctions utilitaires
    const isPlayerReady = () => {
        const state = gameState();
        const currentSession = session();
        if (!state || !currentSession) return false;

        const player = state.players.find(p => p.id === currentSession.playerId);
        return player?.isReady || false;
    };

    const isCurrentPlayer = (playerId: string) => {
        const currentSession = session();
        return currentSession?.playerId === playerId;
    };

    const getPlayerStatus = (player: Player) => {
        if (player.isReady) {
            return "âœ… PrÃªt";
        }
        return "â³ En attente";
    };

    const getSessionStateLabel = (state: SessionState) => {
        switch (state) {
            case SessionState.WAITING: return "En attente";
            case SessionState.IN_PROGRESS: return "En cours";
            case SessionState.FINISHED: return "TerminÃ©e";
            case SessionState.CANCELLED: return "AnnulÃ©e";
            default: return "Inconnue";
        }
    };

    // Actions gRPC
    const createSession = async () => {
        if (!playerName().trim()) {
            setError('Veuillez entrer votre nom');
            return;
        }

        setLoading(true);
        setError('');

        const result = await gameClient.createSession(playerName());

        if (result.success) {
            setSession({
                playerId: result.playerId!,
                sessionCode: result.sessionCode!,
                sessionId: result.sessionId! // Stocker le sessionId aussi
            });

            // Convertir la rÃ©ponse gRPC en Ã©tat local
            if (result.sessionState) {
                setGameState(convertSessionState(result.sessionState));
            } else {
                // CrÃ©er un Ã©tat initial si pas de sessionState
                setGameState({
                    sessionCode: result.sessionCode!,
                    state: SessionState.WAITING,
                    players: [{
                        id: result.playerId!,
                        name: playerName(),
                        score: 0,
                        isReady: true, // Le crÃ©ateur est automatiquement prÃªt
                        isConnected: true,
                        joinedAt: Date.now().toString()
                    }],
                    boardState: "{}"
                });
            }

            setStatusMessage(`Session crÃ©Ã©e ! Code: ${result.sessionCode}`);
        } else {
            setError(result.error || 'Erreur lors de la crÃ©ation');
        }

        setLoading(false);
    };

    const joinSession = async () => {
        if (!playerName().trim() || !sessionCode().trim()) {
            setError('Veuillez entrer votre nom et le code de session');
            return;
        }

        setLoading(true);
        setError('');

        const result = await gameClient.joinSession(sessionCode(), playerName());

        if (result.success) {
            setSession({
                playerId: result.playerId!,
                sessionCode: result.sessionCode!,
                sessionId: result.sessionId! // Stocker le sessionId aussi
            });

            if (result.sessionState) {
                setGameState(convertSessionState(result.sessionState));
            } else {
                // CrÃ©er un Ã©tat initial si pas de sessionState
                setGameState({
                    sessionCode: result.sessionCode!,
                    state: SessionState.WAITING,
                    players: [{
                        id: result.playerId!,
                        name: playerName(),
                        score: 0,
                        isReady: false, // Le nouveau joueur n'est pas encore prÃªt
                        isConnected: true,
                        joinedAt: Date.now().toString()
                    }],
                    boardState: "{}"
                });
            }

            setStatusMessage(`Rejoint la session ${result.sessionCode}`);
        } else {
            setError(result.error || 'Erreur lors du join');
        }

        setLoading(false);
    };

    const setReady = async () => {
        const currentSession = session();
        if (!currentSession) return;

        setLoading(true);

        // Note: Utiliser sessionId pour les appels gRPC
        const result = await gameClient.setPlayerReady(
            currentSession.sessionId, // Utiliser sessionId maintenant
            currentSession.playerId
        );

        if (result.success) {
            // Mettre Ã  jour l'Ã©tat local directement
            setGameState(prev => {
                if (!prev) return null;
                return {
                    ...prev,
                    players: prev.players.map(p =>
                        p.id === currentSession.playerId
                            ? { ...p, isReady: true }
                            : p
                    )
                };
            });

            setStatusMessage('Vous Ãªtes maintenant prÃªt !');

            // VÃ©rifier si la partie a commencÃ©
            if (result.gameStarted) {
                setGameState(prev => prev ? { ...prev, state: SessionState.IN_PROGRESS } : null);
                setStatusMessage('La partie commence !');
            }
        } else {
            setError(result.error || 'Erreur');
        }

        setLoading(false);
    };

    const leaveSession = async () => {
        const currentSession = session();
        if (currentSession) {
            await gameClient.leaveSession(currentSession.sessionId, currentSession.playerId); // Utiliser sessionId
        }

        setSession(null);
        setGameState(null);
        setError('');
        setStatusMessage('');
        setSessionCode('');
    };

    // Polling de l'Ã©tat du jeu
    const startPolling = (sessionId: string) => {
        stopPolling();

        const poll = async () => {
            try {
                const result = await gameClient.getSessionState(sessionId);
                if (result.success && result.sessionState) {
                    setGameState(convertSessionState(result.sessionState));
                } else if (result.error) {
                    console.warn('Erreur polling:', result.error);
                    // Ne pas afficher l'erreur Ã  l'utilisateur pour Ã©viter le spam
                }
            } catch (error) {
                console.warn('Erreur polling:', error);
                // En cas d'erreur rÃ©pÃ©tÃ©e, on peut arrÃªter le polling
            }
        };

        // Poll immÃ©diat puis toutes les 2 secondes
        poll();
        pollInterval = window.setInterval(poll, 2000);
    };

    const stopPolling = () => {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = undefined;
        }
    };

    // Convertir SessionState gRPC vers Ã©tat local
    const convertSessionState = (sessionState: ProtoGameState): GameState => {
        return {
            sessionCode: sessionState.sessionId || '', // Note: sessionId dans le proto
            state: sessionState.state,
            players: sessionState.players.map((p: ProtoPlayer) => ({
                id: p.id,
                name: p.name,
                score: p.score,
                isReady: p.isReady,
                isConnected: p.isConnected,
                joinedAt: p.joinedAt.toString() // bigint vers string
            })),
            boardState: sessionState.boardState || '{}',
            currentTurn: sessionState.currentPlayerId
        };
    };

    // Rendu des joueurs
    const renderPlayers = () => {
        const state = gameState();
        if (!state) return null;

        return (
            <div class="players-section">
                <h3>Joueurs ({state.players.length})</h3>
                <div class="players-list">
                    <For each={state.players}>
                        {(player) => (
                            <div
                                class={`player-card ${isCurrentPlayer(player.id) ? 'current-player' : ''}`}
                            >
                                <div class="player-info">
                  <span class="player-name">
                    {player.name}
                      {isCurrentPlayer(player.id) && <span class="you-indicator"> (Vous)</span>}
                  </span>
                                    <span class="player-score">Score: {player.score}</span>
                                </div>
                                <div class="player-status">
                                    {getPlayerStatus(player)}
                                </div>
                            </div>
                        )}
                    </For>
                </div>

                {/* Section bouton "Je suis prÃªt" */}
                <Show when={gameState()?.state === SessionState.WAITING}>
                    <div class="ready-section">
                        <Show when={!isPlayerReady()}>
                            <button
                                onClick={setReady}
                                disabled={loading()}
                                class="ready-button"
                            >
                                Je suis prÃªt !
                            </button>
                        </Show>
                        <Show when={isPlayerReady()}>
                            <div class="ready-status">
                                âœ… Vous Ãªtes prÃªt ! En attente des autres joueurs...
                            </div>
                        </Show>
                    </div>
                </Show>
            </div>
        );
    };

    // Rendu du plateau de jeu
    const renderGameBoard = () => {
        const state = gameState();
        if (!state) return null;

        return (
            <div class="game-board-section">
                <h3>ðŸŽ® Plateau de Jeu</h3>

                <div class="game-status">
                    <strong>Ã‰tat: {getSessionStateLabel(state.state)}</strong>
                    <Show when={state.currentTurn}>
                        <span class="current-turn">Tour de: <strong>{state.currentTurn}</strong></span>
                    </Show>
                </div>

                <Show when={state.state === SessionState.WAITING}>
                    <div class="waiting-message">
                        <p>â³ En attente que tous les joueurs soient prÃªts...</p>
                        <p>DÃ¨s que tous les joueurs seront prÃªts, le plateau hexagonal apparaÃ®tra !</p>
                    </div>
                </Show>

                <Show when={state.state === SessionState.IN_PROGRESS}>
                    <div class="active-game">
                        <GameBoard gameState={state} />
                    </div>
                </Show>

                <Show when={state.boardState && state.boardState !== "{}"}>
                    <div class="board-preview">
                        <h4>Ã‰tat du plateau (debug) :</h4>
                        <pre class="board-data">
              {JSON.stringify(JSON.parse(state.boardState), null, 2)}
            </pre>
                    </div>
                </Show>
            </div>
        );
    };

    // Composant plateau de jeu hexagonal
    const GameBoard = (props: { gameState: GameState }) => {
        let canvasRef: HTMLCanvasElement;
        let nextTileCanvasRef: HTMLCanvasElement;

        const [nextTile, setNextTile] = createSignal<string | null>(null);
        const [plateauTiles, setPlateauTiles] = createSignal<string[]>(new Array(19).fill(''));

        // Positions hexagonales (identiques Ã  votre App.tsx)
        const hexPositions = [
            [-2, 2], [-2.3, 4], [-2.65, 6], [-1, 1], [-1.3, 3], [-1.6, 5], [-1.95, 7],
            [0, 0],
            [-0.3, 2], [-0.6, 4], [-0.9, 6], [-1.25, 8],
            [0.7, 1], [0.4, 3], [0.1, 5], [-0.2, 7],
            [1.4, 2], [1.1, 4], [0.8, 6],
        ];

        const hexRadius = 35; // Plus petit pour le multiplayer
        const hexWidth = Math.sqrt(3) * hexRadius;
        const hexHeight = 2 * hexRadius;
        const offsetY = 0.45 * hexHeight;

        const drawHexagon = (ctx: CanvasRenderingContext2D, x: number, y: number, radius: number) => {
            const angleStep = Math.PI / 3;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = angleStep * i;
                const xOffset = x + radius * Math.cos(angle);
                const yOffset = y + radius * Math.sin(angle);
                if (i === 0) ctx.moveTo(xOffset, yOffset);
                else ctx.lineTo(xOffset, yOffset);
            }
            ctx.closePath();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        };

        const drawHexagonalGrid = (ctx: CanvasRenderingContext2D, images: string[], canvas: HTMLCanvasElement, onClick?: (index: number) => void) => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#1e1e1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const gridOriginX = canvas.width / 2 - hexWidth;
            const gridOriginY = canvas.height / 2 - 2 * offsetY;

            const clickableAreas: { x: number; y: number; index: number }[] = [];

            hexPositions.forEach(([q, r], index) => {
                const x = gridOriginX + q * hexWidth + r * (hexWidth / 6) + 50;
                const y = gridOriginY + r * offsetY - 50;

                // Dessiner l'hexagone
                drawHexagon(ctx, x, y, hexRadius);

                // Dessiner l'image si elle existe
                if (images[index]) {
                    const img = new Image();
                    img.src = images[index];
                    img.onload = () => {
                        const scaledWidth = img.width / 3;
                        const scaledHeight = img.height / 3;
                        ctx.drawImage(img, x - scaledWidth / 2, y - scaledHeight / 2, scaledWidth, scaledHeight);
                        drawHexagon(ctx, x, y, hexRadius);
                    };
                }

                if (onClick) {
                    clickableAreas.push({ x, y, index });
                }
            });

            if (onClick) {
                canvas.onclick = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickY = e.clientY - rect.top;

                    for (const area of clickableAreas) {
                        const dx = clickX - area.x;
                        const dy = clickY - area.y;
                        if (Math.sqrt(dx * dx + dy * dy) < hexRadius) {
                            onClick(area.index);
                            break;
                        }
                    }
                };
            }
        };

        const handleTileClick = (index: number) => {
            const currentSession = session();
            if (!currentSession) return;

            // VÃ©rifier si c'est le tour du joueur
            if (props.gameState.currentTurn !== currentSession.playerId) {
                setStatusMessage("Ce n'est pas votre tour !");
                return;
            }

            // TODO: ImplÃ©menter le mouvement via gRPC
            console.log(`Clic sur la position ${index}`);
            setStatusMessage(`Mouvement sur la position ${index}`);
        };

        createEffect(() => {
            if (canvasRef) {
                const ctx = canvasRef.getContext('2d');
                if (ctx) {
                    const currentSession = session();
                    const canClick = currentSession && props.gameState.currentTurn === currentSession.playerId;
                    drawHexagonalGrid(ctx, plateauTiles(), canvasRef, canClick ? handleTileClick : undefined);
                }
            }
        });

        createEffect(() => {
            if (nextTileCanvasRef && nextTile()) {
                const ctx = nextTileCanvasRef.getContext('2d');
                if (ctx) {
                    ctx.clearRect(0, 0, nextTileCanvasRef.width, nextTileCanvasRef.height);
                    const img = new Image();
                    img.src = nextTile()!;
                    img.onload = () => {
                        const scale = 0.4;
                        const w = img.width * scale;
                        const h = img.height * scale;
                        ctx.drawImage(img, (120 - w) / 2, (120 - h) / 2, w, h);
                    };
                }
            }
        });

        return (
            <div class="game-board-container">
                <div class="game-controls">
                    <div class="next-tile-section">
                        <h4>Prochaine tuile</h4>
                        <canvas
                            ref={nextTileCanvasRef!}
                            width="120"
                            height="120"
                            class="next-tile-canvas"
                        />
                        <button
                            onClick={() => setNextTile(`/api/tiles/random-${Math.floor(Math.random() * 10)}.png`)}
                            class="generate-tile-button"
                        >
                            ðŸŽ² GÃ©nÃ©rer tuile
                        </button>
                    </div>

                    <div class="turn-info">
                        <Show when={props.gameState.currentTurn}>
                            <div class="current-turn-display">
                                <h4>Tour actuel</h4>
                                <p class="turn-player">
                                    {props.gameState.players.find(p => p.id === props.gameState.currentTurn)?.name || 'Inconnu'}
                                </p>
                                <Show when={session()?.playerId === props.gameState.currentTurn}>
                                    <div class="your-turn">ðŸŽ¯ Ã€ votre tour !</div>
                                </Show>
                            </div>
                        </Show>
                    </div>
                </div>

                <div class="board-canvas-container">
                    <canvas
                        ref={canvasRef!}
                        width="500"
                        height="500"
                        class="game-canvas"
                    />
                    <div class="canvas-instructions">
                        <Show when={session()?.playerId === props.gameState.currentTurn}>
                            <p>âœ¨ Cliquez sur un hexagone pour placer votre tuile</p>
                        </Show>
                        <Show when={session()?.playerId !== props.gameState.currentTurn}>
                            <p>â³ En attente du tour de l'autre joueur...</p>
                        </Show>
                    </div>
                </div>
            </div>
        );
    };

    return (
        <div class="multiplayer-app">
            <h1>ðŸŽ® Take It Easy - Multiplayer</h1>

            {/* Messages d'erreur et de statut */}
            <Show when={error()}>
                <div class="error-message">{error()}</div>
            </Show>

            <Show when={statusMessage()}>
                <div class="status-message">{statusMessage()}</div>
            </Show>

            {/* Interface de connexion */}
            <Show when={!session()}>
                <div class="connection-section">
                    <div class="input-group">
                        <label for="player-name">Nom du joueur :</label>
                        <input
                            id="player-name"
                            type="text"
                            class="player-name-input"
                            value={playerName()}
                            onInput={(e) => setPlayerName(e.target.value)}
                            placeholder="Entrez votre nom"
                            maxLength={20}
                        />
                    </div>

                    <div class="actions">
                        <button
                            onClick={createSession}
                            disabled={loading()}
                            class="create-button"
                        >
                            {loading() ? 'CrÃ©ation...' : 'CrÃ©er une nouvelle session'}
                        </button>

                        <div class="join-section">
                            <input
                                type="text"
                                class="session-code-input"
                                value={sessionCode()}
                                onInput={(e) => setSessionCode(e.target.value.toUpperCase())}
                                placeholder="CODE"
                                maxLength={6}
                            />
                            <button
                                onClick={joinSession}
                                disabled={loading()}
                                class="join-button"
                            >
                                {loading() ? 'Connexion...' : 'Rejoindre'}
                            </button>
                        </div>
                    </div>
                </div>
            </Show>

            {/* Interface de jeu */}
            <Show when={session()}>
                <div class="session-info">
                    <div class="session-details">
                        <h2>ðŸŽ® Session: {session()?.sessionCode}</h2>
                        <p>Joueur: <strong>{playerName()}</strong></p>
                        <p class="player-id">ID: {session()?.playerId}</p>
                    </div>
                    <button onClick={leaveSession} class="leave-button">
                        Quitter la session
                    </button>
                </div>

                {renderPlayers()}
                {renderGameBoard()}
            </Show>

            {/* Styles CSS intÃ©grÃ©s */}
            <style jsx>{`
                .multiplayer-app {
                    max-width: 900px;
                    margin: 0 auto;
                    padding: 20px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    min-height: 100vh;
                    color: white;
                }

                h1 {
                    text-align: center;
                    margin-bottom: 30px;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                }

                .connection-section {
                    background: rgba(255,255,255,0.95);
                    color: #333;
                    padding: 30px;
                    border-radius: 16px;
                    margin-bottom: 20px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.1);
                }

                .input-group {
                    margin-bottom: 20px;
                }

                .input-group label {
                    display: block;
                    margin-bottom: 8px;
                    font-weight: 600;
                    color: #555;
                }

                .player-name-input, .session-code-input {
                    width: 100%;
                    padding: 14px;
                    border: 2px solid #e0e6ed;
                    border-radius: 10px;
                    font-size: 16px;
                    transition: all 0.3s ease;
                }

                .player-name-input:focus, .session-code-input:focus {
                    outline: none;
                    border-color: #667eea;
                    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
                }

                .session-code-input {
                    text-transform: uppercase;
                    letter-spacing: 3px;
                    text-align: center;
                    font-weight: bold;
                    font-size: 18px;
                }

                .actions {
                    display: flex;
                    flex-direction: column;
                    gap: 15px;
                }

                .join-section {
                    display: flex;
                    gap: 12px;
                }

                .join-section input {
                    flex: 1;
                }

                button {
                    padding: 14px 28px;
                    border: none;
                    border-radius: 10px;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }

                .create-button {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                }

                .join-button {
                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                    color: white;
                }

                .leave-button {
                    background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                    color: #333;
                }

                .ready-button {
                    background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
                    color: #333;
                    font-size: 18px;
                    padding: 16px 32px;
                }

                button:hover:not(:disabled) {
                    transform: translateY(-2px);
                    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
                }

                button:disabled {
                    opacity: 0.6;
                    cursor: not-allowed;
                    transform: none;
                }

                .session-info {
                    background: rgba(255,255,255,0.1);
                    backdrop-filter: blur(10px);
                    padding: 24px;
                    border-radius: 16px;
                    margin-bottom: 24px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border: 1px solid rgba(255,255,255,0.2);
                }

                .session-details h2 {
                    margin: 0 0 8px 0;
                    font-size: 24px;
                }

                .session-details p {
                    margin: 4px 0;
                    opacity: 0.9;
                }

                .player-id {
                    font-size: 12px;
                    font-family: monospace;
                    opacity: 0.7;
                }

                .status-message {
                    background: rgba(16, 185, 129, 0.2);
                    color: #10b981;
                    padding: 12px;
                    border-radius: 8px;
                    margin: 10px 0;
                    border: 1px solid rgba(16, 185, 129, 0.3);
                    backdrop-filter: blur(10px);
                }

                .error-message {
                    background: rgba(239, 68, 68, 0.2);
                    color: #ef4444;
                    padding: 12px;
                    border-radius: 8px;
                    margin: 10px 0;
                    border: 1px solid rgba(239, 68, 68, 0.3);
                    backdrop-filter: blur(10px);
                }

                /* Styles pour les joueurs */
                .players-section {
                    background: rgba(255,255,255,0.1);
                    backdrop-filter: blur(10px);
                    padding: 24px;
                    border-radius: 16px;
                    margin: 24px 0;
                    border: 1px solid rgba(255,255,255,0.2);
                }

                .players-section h3 {
                    margin: 0 0 20px 0;
                    font-size: 20px;
                }

                .players-list {
                    display: flex;
                    flex-direction: column;
                    gap: 12px;
                    margin: 20px 0;
                }

                .player-card {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 16px;
                    background: rgba(255,255,255,0.1);
                    border-radius: 12px;
                    border: 1px solid rgba(255,255,255,0.2);
                    backdrop-filter: blur(5px);
                }

                .player-card.current-player {
                    border: 2px solid #a8edea;
                    background: rgba(168, 237, 234, 0.2);
                }

                .player-info {
                    display: flex;
                    flex-direction: column;
                    gap: 4px;
                }

                .player-name {
                    font-weight: bold;
                    font-size: 16px;
                }

                .you-indicator {
                    color: #a8edea;
                    font-size: 12px;
                }

                .player-score {
                    font-size: 14px;
                    opacity: 0.8;
                }

                .player-status {
                    font-size: 14px;
                    font-weight: bold;
                }

                .ready-section {
                    text-align: center;
                    margin: 24px 0;
                    padding: 20px;
                    border-radius: 12px;
                    background: rgba(255,255,255,0.05);
                }

                .ready-status {
                    background: rgba(16, 185, 129, 0.2);
                    color: #10b981;
                    padding: 16px;
                    border-radius: 8px;
                    font-weight: bold;
                    border: 1px solid rgba(16, 185, 129, 0.3);
                }

                /* Styles pour le plateau de jeu */
                .game-board-section {
                    background: rgba(255,255,255,0.1);
                    backdrop-filter: blur(10px);
                    padding: 24px;
                    border-radius: 16px;
                    margin: 24px 0;
                    border: 1px solid rgba(255,255,255,0.2);
                }

                .game-board-section h3 {
                    margin: 0 0 16px 0;
                    font-size: 20px;
                }

                .game-status {
                    background: rgba(255,255,255,0.1);
                    padding: 12px;
                    border-radius: 8px;
                    margin-bottom: 16px;
                    text-align: center;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }

                .current-turn {
                    color: #a8edea;
                    font-weight: bold;
                }

                .waiting-message {
                    text-align: center;
                    font-style: italic;
                    opacity: 0.8;
                    margin: 20px 0;
                }

                .active-game {
                    margin: 20px 0;
                }

                .game-board-container {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 20px;
                    margin: 20px 0;
                }

                .game-controls {
                    display: flex;
                    gap: 30px;
                    align-items: flex-start;
                    background: rgba(255,255,255,0.05);
                    padding: 20px;
                    border-radius: 12px;
                }

                .next-tile-section {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 10px;
                }

                .next-tile-section h4 {
                    margin: 0;
                    color: #a8edea;
                }

                .next-tile-canvas {
                    border: 2px solid rgba(255,255,255,0.2);
                    border-radius: 8px;
                    background: #1e1e1e;
                }

                .generate-tile-button {
                    background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    font-size: 14px;
                    cursor: pointer;
                    transition: all 0.2s;
                }

                .generate-tile-button:hover {
                    transform: translateY(-1px);
                    box-shadow: 0 4px 12px rgba(255, 216, 155, 0.3);
                }

                .turn-info {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    min-width: 150px;
                }

                .current-turn-display h4 {
                    margin: 0 0 8px 0;
                    color: #a8edea;
                }

                .turn-player {
                    font-size: 18px;
                    font-weight: bold;
                    color: white;
                    margin: 0;
                    text-align: center;
                }

                .your-turn {
                    background: rgba(168, 237, 234, 0.2);
                    color: #a8edea;
                    padding: 8px 12px;
                    border-radius: 6px;
                    font-weight: bold;
                    margin-top: 8px;
                    text-align: center;
                    border: 1px solid #a8edea;
                    animation: pulse 2s infinite;
                }

                @keyframes pulse {
                    0% { opacity: 1; }
                    50% { opacity: 0.7; }
                    100% { opacity: 1; }
                }

                .board-canvas-container {
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 15px;
                }

                .game-canvas {
                    border: 3px solid rgba(255,255,255,0.2);
                    border-radius: 12px;
                    background: #1e1e1e;
                    cursor: pointer;
                    transition: all 0.3s ease;
                }

                .game-canvas:hover {
                    border-color: #a8edea;
                    box-shadow: 0 0 20px rgba(168, 237, 234, 0.3);
                }

                .canvas-instructions {
                    text-align: center;
                    font-style: italic;
                    color: rgba(255,255,255,0.8);
                }

                .canvas-instructions p {
                    margin: 0;
                    padding: 8px 16px;
                    background: rgba(255,255,255,0.05);
                    border-radius: 6px;
                    border: 1px solid rgba(255,255,255,0.1);
                }

                .board-preview {
                    margin-top: 20px;
                }

                .board-preview h4 {
                    margin: 0 0 12px 0;
                    font-size: 16px;
                }

                .board-data {
                    background: rgba(0,0,0,0.3);
                    color: #e2e8f0;
                    padding: 16px;
                    border-radius: 8px;
                    font-size: 12px;
                    max-height: 200px;
                    overflow-y: auto;
                    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                    border: 1px solid rgba(255,255,255,0.1);
                }

                /* Responsive */
                @media (max-width: 600px) {
                    .multiplayer-app {
                        padding: 12px;
                    }

                    .join-section {
                        flex-direction: column;
                    }

                    .session-info {
                        flex-direction: column;
                        gap: 16px;
                        text-align: center;
                    }

                    button {
                        padding: 12px 20px;
                        font-size: 14px;
                    }
                }
            `}</style>
        </div>
    );
};

export default MultiplayerApp;```

## ðŸ“„ src/services/GameClient.ts
```ts
// src/services/GameClient.ts - Client gRPC-Web unifiÃ© pour Take It Easy
import { GrpcWebFetchTransport } from '@protobuf-ts/grpcweb-transport';
import { SessionServiceClient } from '../generated/session_service.client';
import { GameServiceClient } from '../generated/game_service.client';
import {
    CreateSessionRequest,
    JoinSessionRequest,
    SetReadyRequest,
    GetSessionStateRequest
} from '../generated/session_service';
import type { GameState } from '../generated/common';

export class GameClient {
    private sessionClient: SessionServiceClient;
    private gameClient: GameServiceClient;
    private transport: GrpcWebFetchTransport;

    constructor() {
        // Test direct au serveur Rust pour Ã©viter les problÃ¨mes de proxy
        this.transport = new GrpcWebFetchTransport({
            baseUrl: 'http://localhost:50051', // Direct vers le serveur Rust
            fetchInit: {
                mode: 'cors', // Activer CORS
                credentials: 'omit' // Pas de credentials pour Ã©viter les conflits
            },
            // Configuration gRPC-Web spÃ©cifique
            format: "binary",
            compress: false,
            timeout: 10000, // 10 secondes de timeout
            // Headers explicites
            meta: {
                'content-type': 'application/grpc-web+proto',
                'accept': 'application/grpc-web+proto'
            }
        });

        this.sessionClient = new SessionServiceClient(this.transport);
        this.gameClient = new GameServiceClient(this.transport);
    }

    // CrÃ©er une nouvelle session
    async createSession(playerName: string) {
        try {
            const request: CreateSessionRequest = {
                playerName: playerName,
                maxPlayers: 4, // Valeur par dÃ©faut
                gameMode: "multiplayer"
            };

            const { response } = await this.sessionClient.createSession(request);

            if (response.result.oneofKind === "success") {
                const success = response.result.success;
                return {
                    success: true,
                    sessionCode: success.sessionCode,
                    sessionId: success.sessionId, // Ajouter sessionId
                    playerId: success.playerId,
                    sessionState: success.player ? {
                        sessionId: success.sessionId,
                        players: [success.player],
                        currentPlayerId: success.playerId,
                        state: 0, // WAITING
                        boardState: "{}",
                        turnNumber: 0
                    } as GameState : undefined
                };
            } else if (response.result.oneofKind === "error") {
                return {
                    success: false,
                    error: response.result.error.message
                };
            }

            return {
                success: false,
                error: "RÃ©ponse invalide du serveur"
            };
        } catch (error) {
            console.error('Erreur crÃ©ation session:', error);
            return {
                success: false,
                error: this.extractErrorMessage(error)
            };
        }
    }

    // Rejoindre une session existante
    async joinSession(sessionCode: string, playerName: string) {
        try {
            const request: JoinSessionRequest = {
                sessionCode: sessionCode.toUpperCase(),
                playerName: playerName
            };

            const { response } = await this.sessionClient.joinSession(request);

            if (response.result.oneofKind === "success") {
                const success = response.result.success;
                return {
                    success: true,
                    sessionCode: sessionCode,
                    sessionId: success.sessionId, // Ajouter sessionId
                    playerId: success.playerId,
                    sessionState: success.gameState
                };
            } else if (response.result.oneofKind === "error") {
                return {
                    success: false,
                    error: response.result.error.message
                };
            }

            return {
                success: false,
                error: "RÃ©ponse invalide du serveur"
            };
        } catch (error) {
            console.error('Erreur join session:', error);
            return {
                success: false,
                error: this.extractErrorMessage(error)
            };
        }
    }

    // Marquer un joueur comme prÃªt
    async setPlayerReady(sessionId: string, playerId: string) {
        try {
            const request: SetReadyRequest = {
                sessionId: sessionId,
                playerId: playerId,
                ready: true
            };

            const { response } = await this.sessionClient.setReady(request);

            if (response.success) {
                return {
                    success: true,
                    gameStarted: response.gameStarted
                };
            } else if (response.error) {
                return {
                    success: false,
                    error: response.error.message
                };
            }

            return {
                success: false,
                error: "Ã‰chec de la requÃªte"
            };
        } catch (error) {
            console.error('Erreur set ready:', error);
            return {
                success: false,
                error: this.extractErrorMessage(error)
            };
        }
    }

    // Obtenir l'Ã©tat d'une session
    async getSessionState(sessionId: string) {
        try {
            const request: GetSessionStateRequest = {
                sessionId: sessionId
            };

            const { response } = await this.sessionClient.getSessionState(request);

            if (response.gameState) {
                return {
                    success: true,
                    sessionState: response.gameState
                };
            } else if (response.error) {
                return {
                    success: false,
                    error: response.error.message
                };
            }

            return {
                success: false,
                error: "Aucun Ã©tat de session retournÃ©"
            };
        } catch (error) {
            console.error('Erreur get session state:', error);
            return {
                success: false,
                error: this.extractErrorMessage(error)
            };
        }
    }

    // Quitter une session
    async leaveSession(sessionId: string, playerId: string) {
        try {
            // Note: Vous devez implÃ©menter une mÃ©thode LeaveSession dans votre .proto
            // Pour l'instant, on retourne simplement success
            return { success: true };
        } catch (error) {
            console.error('Erreur leave session:', error);
            return {
                success: false,
                error: this.extractErrorMessage(error)
            };
        }
    }

    // Extraire le message d'erreur
    private extractErrorMessage(error: any): string {
        if (error?.message) {
            return error.message;
        }
        if (typeof error === 'string') {
            return error;
        }
        return 'Erreur de connexion au serveur';
    }

    // Fermer les connexions
    dispose() {
        // Nettoyage si nÃ©cessaire
    }
}

// Instance singleton
export const gameClient = new GameClient();```

## ðŸ“¡ Frontend Generated: src/generated/session_service.client.ts (extrait)
```typescript
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { SessionService } from "./session_service";
import type { GetSessionStateResponse } from "./session_service";
import type { GetSessionStateRequest } from "./session_service";
import type { SetReadyResponse } from "./session_service";
import type { SetReadyRequest } from "./session_service";
import type { JoinSessionResponse } from "./session_service";
import type { JoinSessionRequest } from "./session_service";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { CreateSessionResponse } from "./session_service";
import type { CreateSessionRequest } from "./session_service";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service takeiteasygame.v1.SessionService
 */
export interface ISessionServiceClient {
    /**
     * @generated from protobuf rpc: CreateSession
     */
    createSession(input: CreateSessionRequest, options?: RpcOptions): UnaryCall<CreateSessionRequest, CreateSessionResponse>;
    /**
     * @generated from protobuf rpc: JoinSession
     */
    joinSession(input: JoinSessionRequest, options?: RpcOptions): UnaryCall<JoinSessionRequest, JoinSessionResponse>;
    /**
// ... (fichier tronquÃ©)
```

## ðŸ“¡ Frontend Generated: src/generated/game_service.ts (extrait)
```typescript
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GameState } from "./common";
import { Error } from "./common";
/**
 * @generated from protobuf message takeiteasygame.v1.MakeMoveRequest
 */
export interface MakeMoveRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
    /**
     * @generated from protobuf field: string move_data = 3
     */
// ... (fichier tronquÃ©)
```

## ðŸ“¡ Frontend Generated: src/generated/session_service.ts (extrait)
```typescript
// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GameState } from "./common";
import { Error } from "./common";
import { Player } from "./common";
// ============================================================================
// MESSAGES SESSION SERVICE
// ============================================================================

/**
 * @generated from protobuf message takeiteasygame.v1.CreateSessionRequest
 */
export interface CreateSessionRequest {
    /**
     * @generated from protobuf field: string player_name = 1
     */
    playerName: string;
    /**
     * @generated from protobuf field: int32 max_players = 2
// ... (fichier tronquÃ©)
```

