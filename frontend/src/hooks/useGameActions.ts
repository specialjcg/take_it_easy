// hooks/useGameActions.ts - Actions gameplay isol√©es
import { gameClient } from '../services/GameClient';
import type { GameState, Session } from './useGameState';
import {batch} from "solid-js";

/**
 * Hook pour les actions de gameplay (gRPC calls)
 * Isole toute la logique m√©tier du composant principal
 */
export const useGameActions = (
    session: () => Session | null,
    setLoading: (loading: boolean) => void,
    setError: (error: string) => void,
    setStatusMessage: (message: string) => void,
    setCurrentTile: (tile: string | null) => void,
    setCurrentTileImage: (image: string | null) => void,
    setCurrentTurnNumber: (turn: number) => void,
    setIsGameStarted: (started: boolean) => void,
    setMyTurn: (turn: boolean) => void,
    setMctsLastMove: (move: string) => void,
    updatePlateauTiles: (gameState: any) => void,
    addDebugLog: (message: string) => void,
) => {

    /**
     * D√©marrer un nouveau tour (tire une tuile al√©atoire)
     */
        // ‚úÖ SOLUTION 2: startGameTurn optimis√©
    const startGameTurn = async () => {
            const currentSession = session();
            if (!currentSession) return;

            // ‚úÖ BATCH: √âtat de chargement
            batch(() => {
                setLoading(true);
                setError('');
            });

            try {
                const result = await gameClient.startNewTurn(currentSession.sessionId);

                if (result.success) {
                    // ‚úÖ BATCH: Mise √† jour compl√®te du tour
                    batch(() => {
                        setCurrentTile(result.announcedTile || null);
                        setCurrentTileImage(result.tileImage || null);
                        setCurrentTurnNumber(result.turnNumber || 0);
                        setStatusMessage(`üé≤ Tour ${result.turnNumber}: ${result.announcedTile}`);
                        setIsGameStarted(true);
                        setMyTurn(result.waitingForPlayers?.includes(currentSession.playerId) || false);
                        setLoading(false);
                    });

                    // ‚úÖ PLATEAU EN DIFF√âR√â (non-bloquant)
                    if (result.gameState) {
                        queueMicrotask(() => {
                            const parsedState = JSON.parse(result.gameState);
                            updatePlateauTiles(parsedState);
                        });
                    }
                } else {
                    batch(() => {
                        setError(result.error || 'Erreur tour');
                        setLoading(false);
                    });
                }
            } catch (error) {
                batch(() => {
                    setError('Erreur connexion');
                    setLoading(false);
                });
            }
        };

    /**
     * Jouer un mouvement (position sur le plateau) - VERSION OPTIMISTE
     */
    const playMove = async (position: number, myTurn: () => boolean, markActionPerformed?: () => void) => {
        const currentSession = session();
        if (!currentSession || !myTurn()) {
            setStatusMessage("Ce n'est pas votre tour !");
            return;
        }
        batch(() => {
            setStatusMessage(`üéØ Position ${position}...`);
            setMyTurn(false); // Bloquer imm√©diatement les clics
            setLoading(true);
            setError('');
        });
        // Marquer pour √©viter les conflits polling
        markActionPerformed?.();

        // ‚úÖ LOGIQUE ASYNC NON-BLOQUANTE
        try {
            const result = await gameClient.makeMove(
                currentSession.sessionId,
                currentSession.playerId,
                position
            );

            // ‚úÖ BATCH 2: Mise √† jour r√©sultat (1 seul re-render)
            batch(() => {
                if (result.success) {
                    setStatusMessage(`‚úÖ Position ${position}! +${result.pointsEarned} pts`);
                    setLoading(false);

                    // √âtat plateau mis √† jour en arri√®re-plan (pas de re-render imm√©diat)
                    if (result.newGameState) {
                        queueMicrotask(() => {
                            const parsedState = JSON.parse(result.newGameState);
                            updatePlateauTiles(parsedState);
                        });
                    }

                    // MCTS en diff√©r√© pour ne pas bloquer l'UI
                    if (result.mctsResponse && result.mctsResponse !== "{}") {
                        setTimeout(() => {
                            try {
                                const mctsData = JSON.parse(result.mctsResponse);
                                const mctsMessage = `ü§ñ MCTS: position ${mctsData.position}`;
                                batch(() => {
                                    setMctsLastMove(mctsMessage);
                                    setStatusMessage(mctsMessage);
                                });
                            } catch (e) {
                                setMctsLastMove('ü§ñ MCTS a jou√©');
                            }
                        }, 500); // D√©lai pour voir la confirmation du joueur
                    }

                    // Tour suivant en diff√©r√©
                    if (!result.isGameOver) {
                        setTimeout(() => {
                            startGameTurn();
                        }, 2000);
                    }
                } else {
                    // ROLLBACK en cas d'√©chec
                    setMyTurn(true);
                    setLoading(false);
                    setError(result.error || 'Mouvement refus√©');
                    setStatusMessage(`‚ùå ${result.error}`);
                }
            });

        } catch (error) {
            // ‚úÖ BATCH 3: Gestion d'erreur (1 seul re-render)
            batch(() => {
                setMyTurn(true);
                setLoading(false);
                setError('Erreur r√©seau');
                setStatusMessage('üí• R√©essayez');
            });
        }
    };

    /**
     * Cr√©er une nouvelle session
     */
    const createSession = async (
        playerName: () => string,
        setSession: (session: Session) => void,
        setGameState: (state: GameState) => void,
        convertSessionState: (sessionState: any) => GameState
    ) => {
        if (!playerName().trim()) {
            setError('Veuillez entrer votre nom');
            return;
        }

        setLoading(true);
        setError('');
        addDebugLog(`üéØ Cr√©ation session pour ${playerName()}`);

        const result = await gameClient.createSession(playerName());

        if (result.success) {
            // Validation des donn√©es de session
            if (!result.sessionId || !result.playerId || !result.sessionCode) {
                const error = `Donn√©es de session manquantes: sessionId=${result.sessionId}, playerId=${result.playerId}, sessionCode=${result.sessionCode}`;
                setError(error);
                addDebugLog(`‚ùå ${error}`);
                setLoading(false);
                return;
            }

            addDebugLog(`‚úÖ Session cr√©√©e avec succ√®s: sessionId=${result.sessionId}, playerId=${result.playerId}`);

            setSession({
                playerId: result.playerId,
                sessionCode: result.sessionCode,
                sessionId: result.sessionId
            });

            if (result.sessionState) {
                setGameState(convertSessionState(result.sessionState));
            } else {
                setGameState({
                    sessionCode: result.sessionCode,
                    state: 0, // SessionState.WAITING
                    players: [{
                        id: result.playerId,
                        name: playerName(),
                        score: 0,
                        isReady: true,
                        isConnected: true,
                        joinedAt: Date.now().toString()
                    }],
                    boardState: "{}"
                });
            }

            setStatusMessage(`Session cr√©√©e ! Code: ${result.sessionCode}`);
            addDebugLog(`‚úÖ Session cr√©√©e: ${result.sessionCode}`);
        } else {
            setError(result.error || 'Erreur lors de la cr√©ation');
            addDebugLog(`‚ùå √âchec cr√©ation: ${result.error}`);
        }

        setLoading(false);
    };

    /**
     * Rejoindre une session existante
     */
    const joinSession = async (
        playerName: () => string,
        sessionCode: () => string,
        setSession: (session: Session) => void,
        setGameState: (state: GameState) => void,
        convertSessionState: (sessionState: any) => GameState
    ) => {
        if (!playerName().trim() || !sessionCode().trim()) {
            setError('Veuillez entrer votre nom et le code de session');
            return;
        }

        setLoading(true);
        setError('');
        addDebugLog(`üö™ Join session: ${sessionCode()} par ${playerName()}`);

        const result = await gameClient.joinSession(sessionCode(), playerName());

        if (result.success) {
            // Validation des donn√©es de session
            if (!result.sessionId || !result.playerId || !result.sessionCode) {
                const error = `Donn√©es de session manquantes: sessionId=${result.sessionId}, playerId=${result.playerId}, sessionCode=${result.sessionCode}`;
                setError(error);
                addDebugLog(`‚ùå ${error}`);
                setLoading(false);
                return;
            }

            addDebugLog(`‚úÖ Session jointe avec succ√®s: sessionId=${result.sessionId}, playerId=${result.playerId}`);

            setSession({
                playerId: result.playerId,
                sessionCode: result.sessionCode,
                sessionId: result.sessionId
            });

            if (result.sessionState) {
                setGameState(convertSessionState(result.sessionState));
            } else {
                setGameState({
                    sessionCode: result.sessionCode,
                    state: 0, // SessionState.WAITING
                    players: [{
                        id: result.playerId,
                        name: playerName(),
                        score: 0,
                        isReady: false,
                        isConnected: true,
                        joinedAt: Date.now().toString()
                    }],
                    boardState: "{}"
                });
            }

            setStatusMessage(`Rejoint la session ${result.sessionCode}`);
            addDebugLog(`‚úÖ Session jointe: ${result.sessionCode}`);
        } else {
            setError(result.error || 'Erreur lors du join');
            addDebugLog(`‚ùå √âchec join: ${result.error}`);
        }

        setLoading(false);
    };

    /**
     * D√©finir le joueur comme pr√™t
     */
    const setReady = async (
        setGameState: (state: GameState | ((prev: GameState | null) => GameState | null)) => void
    ) => {
        const currentSession = session();
        if (!currentSession) {
            addDebugLog('‚ùå Pas de session active');
            return;
        }

        // Validation renforc√©e
        const sessionId = currentSession.sessionId;
        const playerId = currentSession.playerId;

        addDebugLog(`‚ö° SET_READY: sessionId="${sessionId}", playerId="${playerId}"`);

        if (!sessionId || !playerId) {
            const error = `Donn√©es manquantes: sessionId=${sessionId}, playerId=${playerId}`;
            setError(error);
            addDebugLog(`‚ùå ${error}`);
            return;
        }

        setLoading(true);

        const result = await gameClient.setPlayerReady(sessionId, playerId);

        if (result.success) {
            setGameState(prev => {
                if (!prev) return null;
                return {
                    ...prev,
                    players: prev.players.map(p =>
                        p.id === currentSession.playerId
                            ? { ...p, isReady: true }
                            : p
                    )
                };
            });

            setStatusMessage('Vous √™tes maintenant pr√™t !');
            addDebugLog(`‚úÖ Ready d√©fini - Game Started: ${result.gameStarted}`);

            if (result.gameStarted) {
                setGameState(prev => prev ? { ...prev, state: 1 } : null); // SessionState.IN_PROGRESS
                setStatusMessage('La partie commence !');
                addDebugLog('üéÆ Jeu d√©marr√©');
            }
        } else {
            setError(result.error || 'Erreur');
            addDebugLog(`‚ùå √âchec setReady: ${result.error}`);
        }

        setLoading(false);
    };

    /**
     * Quitter la session
     */
    const leaveSession = async (resetSession: () => void) => {
        const currentSession = session();
        if (currentSession) {
            await gameClient.leaveSession(currentSession.sessionId, currentSession.playerId);
            addDebugLog(`üö™ Session quitt√©e: ${currentSession.sessionCode}`);
        }

        resetSession();
    };

    return {
        startGameTurn,
        playMove,
        createSession,
        joinSession,
        setReady,
        leaveSession
    };
};