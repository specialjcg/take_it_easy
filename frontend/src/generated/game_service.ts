// @generated by protobuf-ts 2.11.0
// @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GameState } from "./common";
import { Error } from "./common";
/**
 * @generated from protobuf message takeiteasygame.v1.MakeMoveRequest
 */
export interface MakeMoveRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
    /**
     * @generated from protobuf field: string move_data = 3
     */
    moveData: string; // JSON du mouvement
    /**
     * @generated from protobuf field: int64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message takeiteasygame.v1.MakeMoveResponse
 */
export interface MakeMoveResponse {
    /**
     * @generated from protobuf oneof: result
     */
    result: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: takeiteasygame.v1.MakeMoveSuccess success = 1
         */
        success: MakeMoveSuccess;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: takeiteasygame.v1.Error error = 2
         */
        error: Error;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message takeiteasygame.v1.MakeMoveSuccess
 */
export interface MakeMoveSuccess {
    /**
     * @generated from protobuf field: takeiteasygame.v1.GameState new_game_state = 1
     */
    newGameState?: GameState;
    /**
     * @generated from protobuf field: string mcts_response = 2
     */
    mctsResponse: string; // Réponse de l'IA si applicable
    /**
     * @generated from protobuf field: int32 points_earned = 3
     */
    pointsEarned: number;
    /**
     * @generated from protobuf field: bool is_game_over = 4
     */
    isGameOver: boolean;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GetAvailableMovesRequest
 */
export interface GetAvailableMovesRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
    /**
     * @generated from protobuf field: string player_id = 2
     */
    playerId: string;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GetAvailableMovesResponse
 */
export interface GetAvailableMovesResponse {
    /**
     * @generated from protobuf field: repeated string available_moves = 1
     */
    availableMoves: string[]; // JSON des mouvements possibles
    /**
     * @generated from protobuf field: takeiteasygame.v1.Error error = 2
     */
    error?: Error;
}
/**
 * Démarrer un nouveau tour
 *
 * @generated from protobuf message takeiteasygame.v1.StartTurnRequest
 */
export interface StartTurnRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
}
/**
 * @generated from protobuf message takeiteasygame.v1.StartTurnResponse
 */
export interface StartTurnResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string announced_tile = 2
     */
    announcedTile: string; // "5-3-7"
    /**
     * @generated from protobuf field: string tile_image = 3
     */
    tileImage: string; // "537.png"
    /**
     * @generated from protobuf field: int32 turn_number = 4
     */
    turnNumber: number;
    /**
     * @generated from protobuf field: repeated string waiting_for_players = 5
     */
    waitingForPlayers: string[];
    /**
     * @generated from protobuf field: string game_state = 6
     */
    gameState: string; // JSON complet de l'état
    /**
     * @generated from protobuf field: takeiteasygame.v1.Error error = 7
     */
    error?: Error;
}
/**
 * Obtenir l'état complet du jeu
 *
 * @generated from protobuf message takeiteasygame.v1.GetGameStateRequest
 */
export interface GetGameStateRequest {
    /**
     * @generated from protobuf field: string session_id = 1
     */
    sessionId: string;
}
/**
 * @generated from protobuf message takeiteasygame.v1.GetGameStateResponse
 */
export interface GetGameStateResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string game_state = 2
     */
    gameState: string; // JSON complet de l'état
    /**
     * @generated from protobuf field: string current_tile = 3
     */
    currentTile: string; // "5-3-7" ou vide
    /**
     * @generated from protobuf field: string current_tile_image = 4
     */
    currentTileImage: string; // ✅ NOUVEAU: "../image/537.png"
    /**
     * @generated from protobuf field: int32 current_turn = 5
     */
    currentTurn: number; // Numéro du tour (0-18) - RENUMÉROTÉ
    /**
     * @generated from protobuf field: repeated string waiting_for_players = 6
     */
    waitingForPlayers: string[]; // RENUMÉROTÉ
    /**
     * @generated from protobuf field: bool is_game_finished = 7
     */
    isGameFinished: boolean; // RENUMÉROTÉ
    /**
     * @generated from protobuf field: string final_scores = 8
     */
    finalScores: string; // JSON des scores finaux - RENUMÉROTÉ
    /**
     * @generated from protobuf field: takeiteasygame.v1.Error error = 9
     */
    error?: Error; // RENUMÉROTÉ
}
// @generated message type with reflection information, may provide speed optimized methods
class MakeMoveRequest$Type extends MessageType<MakeMoveRequest> {
    constructor() {
        super("takeiteasygame.v1.MakeMoveRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "move_data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MakeMoveRequest>): MakeMoveRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.playerId = "";
        message.moveData = "";
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<MakeMoveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveRequest): MakeMoveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 2:
                    message.playerId = reader.string();
                    break;
                case /* string move_data */ 3:
                    message.moveData = reader.string();
                    break;
                case /* int64 timestamp */ 4:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MakeMoveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 2; */
        if (message.playerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
        /* string move_data = 3; */
        if (message.moveData !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.moveData);
        /* int64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveRequest
 */
export const MakeMoveRequest = new MakeMoveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MakeMoveResponse$Type extends MessageType<MakeMoveResponse> {
    constructor() {
        super("takeiteasygame.v1.MakeMoveResponse", [
            { no: 1, name: "success", kind: "message", oneof: "result", T: () => MakeMoveSuccess },
            { no: 2, name: "error", kind: "message", oneof: "result", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<MakeMoveResponse>): MakeMoveResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MakeMoveResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveResponse): MakeMoveResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.MakeMoveSuccess success */ 1:
                    message.result = {
                        oneofKind: "success",
                        success: MakeMoveSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
                    };
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.result = {
                        oneofKind: "error",
                        error: Error.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MakeMoveResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.MakeMoveSuccess success = 1; */
        if (message.result.oneofKind === "success")
            MakeMoveSuccess.internalBinaryWrite(message.result.success, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* takeiteasygame.v1.Error error = 2; */
        if (message.result.oneofKind === "error")
            Error.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveResponse
 */
export const MakeMoveResponse = new MakeMoveResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MakeMoveSuccess$Type extends MessageType<MakeMoveSuccess> {
    constructor() {
        super("takeiteasygame.v1.MakeMoveSuccess", [
            { no: 1, name: "new_game_state", kind: "message", T: () => GameState },
            { no: 2, name: "mcts_response", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "points_earned", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "is_game_over", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MakeMoveSuccess>): MakeMoveSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mctsResponse = "";
        message.pointsEarned = 0;
        message.isGameOver = false;
        if (value !== undefined)
            reflectionMergePartial<MakeMoveSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveSuccess): MakeMoveSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* takeiteasygame.v1.GameState new_game_state */ 1:
                    message.newGameState = GameState.internalBinaryRead(reader, reader.uint32(), options, message.newGameState);
                    break;
                case /* string mcts_response */ 2:
                    message.mctsResponse = reader.string();
                    break;
                case /* int32 points_earned */ 3:
                    message.pointsEarned = reader.int32();
                    break;
                case /* bool is_game_over */ 4:
                    message.isGameOver = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MakeMoveSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* takeiteasygame.v1.GameState new_game_state = 1; */
        if (message.newGameState)
            GameState.internalBinaryWrite(message.newGameState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string mcts_response = 2; */
        if (message.mctsResponse !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mctsResponse);
        /* int32 points_earned = 3; */
        if (message.pointsEarned !== 0)
            writer.tag(3, WireType.Varint).int32(message.pointsEarned);
        /* bool is_game_over = 4; */
        if (message.isGameOver !== false)
            writer.tag(4, WireType.Varint).bool(message.isGameOver);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveSuccess
 */
export const MakeMoveSuccess = new MakeMoveSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAvailableMovesRequest$Type extends MessageType<GetAvailableMovesRequest> {
    constructor() {
        super("takeiteasygame.v1.GetAvailableMovesRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAvailableMovesRequest>): GetAvailableMovesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<GetAvailableMovesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAvailableMovesRequest): GetAvailableMovesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                case /* string player_id */ 2:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAvailableMovesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        /* string player_id = 2; */
        if (message.playerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetAvailableMovesRequest
 */
export const GetAvailableMovesRequest = new GetAvailableMovesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAvailableMovesResponse$Type extends MessageType<GetAvailableMovesResponse> {
    constructor() {
        super("takeiteasygame.v1.GetAvailableMovesResponse", [
            { no: 1, name: "available_moves", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<GetAvailableMovesResponse>): GetAvailableMovesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.availableMoves = [];
        if (value !== undefined)
            reflectionMergePartial<GetAvailableMovesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAvailableMovesResponse): GetAvailableMovesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string available_moves */ 1:
                    message.availableMoves.push(reader.string());
                    break;
                case /* takeiteasygame.v1.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAvailableMovesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string available_moves = 1; */
        for (let i = 0; i < message.availableMoves.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.availableMoves[i]);
        /* takeiteasygame.v1.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetAvailableMovesResponse
 */
export const GetAvailableMovesResponse = new GetAvailableMovesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartTurnRequest$Type extends MessageType<StartTurnRequest> {
    constructor() {
        super("takeiteasygame.v1.StartTurnRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StartTurnRequest>): StartTurnRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        if (value !== undefined)
            reflectionMergePartial<StartTurnRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartTurnRequest): StartTurnRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartTurnRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.StartTurnRequest
 */
export const StartTurnRequest = new StartTurnRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartTurnResponse$Type extends MessageType<StartTurnResponse> {
    constructor() {
        super("takeiteasygame.v1.StartTurnResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "announced_tile", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tile_image", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "turn_number", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "waiting_for_players", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "game_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<StartTurnResponse>): StartTurnResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.announcedTile = "";
        message.tileImage = "";
        message.turnNumber = 0;
        message.waitingForPlayers = [];
        message.gameState = "";
        if (value !== undefined)
            reflectionMergePartial<StartTurnResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartTurnResponse): StartTurnResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string announced_tile */ 2:
                    message.announcedTile = reader.string();
                    break;
                case /* string tile_image */ 3:
                    message.tileImage = reader.string();
                    break;
                case /* int32 turn_number */ 4:
                    message.turnNumber = reader.int32();
                    break;
                case /* repeated string waiting_for_players */ 5:
                    message.waitingForPlayers.push(reader.string());
                    break;
                case /* string game_state */ 6:
                    message.gameState = reader.string();
                    break;
                case /* takeiteasygame.v1.Error error */ 7:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartTurnResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string announced_tile = 2; */
        if (message.announcedTile !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.announcedTile);
        /* string tile_image = 3; */
        if (message.tileImage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tileImage);
        /* int32 turn_number = 4; */
        if (message.turnNumber !== 0)
            writer.tag(4, WireType.Varint).int32(message.turnNumber);
        /* repeated string waiting_for_players = 5; */
        for (let i = 0; i < message.waitingForPlayers.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.waitingForPlayers[i]);
        /* string game_state = 6; */
        if (message.gameState !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.gameState);
        /* takeiteasygame.v1.Error error = 7; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.StartTurnResponse
 */
export const StartTurnResponse = new StartTurnResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetGameStateRequest$Type extends MessageType<GetGameStateRequest> {
    constructor() {
        super("takeiteasygame.v1.GetGameStateRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetGameStateRequest>): GetGameStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        if (value !== undefined)
            reflectionMergePartial<GetGameStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetGameStateRequest): GetGameStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetGameStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetGameStateRequest
 */
export const GetGameStateRequest = new GetGameStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetGameStateResponse$Type extends MessageType<GetGameStateResponse> {
    constructor() {
        super("takeiteasygame.v1.GetGameStateResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "game_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "current_tile", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "current_tile_image", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "current_turn", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "waiting_for_players", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "is_game_finished", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "final_scores", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<GetGameStateResponse>): GetGameStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.gameState = "";
        message.currentTile = "";
        message.currentTileImage = "";
        message.currentTurn = 0;
        message.waitingForPlayers = [];
        message.isGameFinished = false;
        message.finalScores = "";
        if (value !== undefined)
            reflectionMergePartial<GetGameStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetGameStateResponse): GetGameStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string game_state */ 2:
                    message.gameState = reader.string();
                    break;
                case /* string current_tile */ 3:
                    message.currentTile = reader.string();
                    break;
                case /* string current_tile_image */ 4:
                    message.currentTileImage = reader.string();
                    break;
                case /* int32 current_turn */ 5:
                    message.currentTurn = reader.int32();
                    break;
                case /* repeated string waiting_for_players */ 6:
                    message.waitingForPlayers.push(reader.string());
                    break;
                case /* bool is_game_finished */ 7:
                    message.isGameFinished = reader.bool();
                    break;
                case /* string final_scores */ 8:
                    message.finalScores = reader.string();
                    break;
                case /* takeiteasygame.v1.Error error */ 9:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetGameStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string game_state = 2; */
        if (message.gameState !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.gameState);
        /* string current_tile = 3; */
        if (message.currentTile !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.currentTile);
        /* string current_tile_image = 4; */
        if (message.currentTileImage !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.currentTileImage);
        /* int32 current_turn = 5; */
        if (message.currentTurn !== 0)
            writer.tag(5, WireType.Varint).int32(message.currentTurn);
        /* repeated string waiting_for_players = 6; */
        for (let i = 0; i < message.waitingForPlayers.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.waitingForPlayers[i]);
        /* bool is_game_finished = 7; */
        if (message.isGameFinished !== false)
            writer.tag(7, WireType.Varint).bool(message.isGameFinished);
        /* string final_scores = 8; */
        if (message.finalScores !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.finalScores);
        /* takeiteasygame.v1.Error error = 9; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message takeiteasygame.v1.GetGameStateResponse
 */
export const GetGameStateResponse = new GetGameStateResponse$Type();
/**
 * @generated ServiceType for protobuf service takeiteasygame.v1.GameService
 */
export const GameService = new ServiceType("takeiteasygame.v1.GameService", [
    { name: "MakeMove", options: {}, I: MakeMoveRequest, O: MakeMoveResponse },
    { name: "GetAvailableMoves", options: {}, I: GetAvailableMovesRequest, O: GetAvailableMovesResponse },
    { name: "StartTurn", options: {}, I: StartTurnRequest, O: StartTurnResponse },
    { name: "GetGameState", options: {}, I: GetGameStateRequest, O: GetGameStateResponse }
]);
