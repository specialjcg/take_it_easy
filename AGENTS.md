# Repository Guidelines

## Project Structure & Module Organization
The Rust backend lives in `src/`, with domain modules like `game/`, `mcts/`, `neural/`, and `servers/` separated for gameplay, search, model inference, and service interfaces. gRPC bindings generated by `build.rs` land in `src/generated/`; avoid editing them directly and update `.proto` files in `protos/` instead. End-to-end and regression tests sit under `tests/`, while reusable automation lives in `scripts/`. The SolidJS client, assets, and Vite config reside in `frontend/`, and large model artifacts are tracked in `transformer_weights/` and `game_data_*` files.

## Build, Test, and Development Commands
- `make dev` (or `npm run dev`): launches backend plus SolidJS frontend using `dev_start.sh`.
- `cargo run -- --mode multiplayer`: runs the backend service only; swap the flag for other launch modes defined in `src/main.rs`.
- `make build`: performs a release build and triggers the frontend production bundle.
- `run_all_tests.sh`: executes the Rust unit, integration, and transformer evaluations sequentially; inspect `lib_tests.log` and `integration_tests.log` if failures occur.

## Coding Style & Naming Conventions
Format Rust code with `cargo fmt` before committing; follow Rust 2021 defaults (4-space indentation, module-level `snake_case`). Prefer `PascalCase` for types and components, `camelCase` for local variables, and `SCREAMING_SNAKE_CASE` for constants. Keep module boundaries aligned with domain folders (e.g., AI helpers stay under `neural/`) and document non-obvious behaviour with concise inline comments. Frontend components should use PascalCase filenames inside `frontend/src`.

## Testing Guidelines
Use `cargo test` locally for fast iterations; target specific scenarios with `cargo test --test transformer_evaluation_tests`. Integration suites rely on the pretrained weights shipped in `transformer_weights/`, so avoid mutating those files in-place‚Äîstage replacements under the same names. Record new regression cases by mirroring the naming pattern in `tests/ui_reactivity_regression_test.rs`. Capture coverage reports by running `run_all_tests.sh` and reviewing artifacts under `coverage/`.

## Commit & Pull Request Guidelines
Match the Conventional Commit style visible in history (`feat(scope): message`, `chore: ...`). Keep commit bodies focused on motivation and include follow-up instructions when manual steps are required. PRs should summarize backend and frontend impacts separately, link to any tracking issues, and attach screenshots or terminal logs when the UI or CLI output changes. Mention data or model updates explicitly so reviewers can verify large artifacts.

## Model & Generated Assets
Regenerate protobuf stubs with `cargo build` after editing files in `protos/`; clean old artifacts via `cargo clean` if you encounter stale compile errors. For AI experiments, prefer adding notebooks or scripts under `docs/` or `scripts/` instead of committing raw experimentation outputs to keep the repo lean. Respect the `.gitignore` rules added for game data and log files, and store new sizeable assets in the existing `transformer_weights/` hierarchy.
# ===============================================================
# ü¶Ä OPENAI CODEX PROMPTS ‚Äî RUST EXPERT SUITE
# ===============================================================
# Place this file at the root of your Rust project or in ~/.config/openai/
# Use with:
#   openai api completions.create -m code-davinci-002 -p "$(grep -A1000 '### [PROMPT NAME]' codex_rust_prompts.txt)"
# Or simply copy the prompt section you want and append your code.
# ===============================================================


### RUST-AUDIT
You are a senior Rust expert specialized in performance, safety, and software architecture.
Task: Audit this Rust project.
Evaluate:
1. Code hygiene (dead code, warnings, unsafe, error handling)
2. Performance (profiling, algorithmic efficiency, memory usage)
3. Maintainability (refactoring, documentation, testing)
4. Production readiness (logging, monitoring, containerization)
   Output:
- Executive summary (‚â§5 lines)
- Action plan with phases: Critical / Performance / Quality / Production
- Concrete tasks, estimated time, expected impact
- Recommended cargo commands (cargo clippy, cargo bench, cargo test, etc.)


### RUST-ARCHITECTURE
You are a Rust software architect.
Task: Describe the overall architecture of this project.
Explain:
- Application type (CLI, Web API, Library, etc.)
- Structure of src/ (main.rs, lib.rs, modules)
- Data flow between layers
- Key dependencies and business domain
  Output:
- Architecture overview
- File tree structure
- Data flow diagram (text)
- Components and their responsibilities


### RUST-CONTEXT
You are a Rust technical and business analyst.
Task: Explain the project‚Äôs business and technical context.
Include:
- Problem being solved
- Target users
- Main use cases
- Technical constraints
- Integrations (DBs, APIs, services)
- Deployment
  Output:
- üéØ Business Context
- ‚öôÔ∏è Technical Context
- üîó Integrations
- üöÄ Deployment


### RUST-QUALITY
You are a Rust quality engineer.
Task: Evaluate the quality of this Rust project based on 2025 standards.
Criteria:
- Extensibility, maintainability, readability, testability
- Complexity, unsafe usage, clone overhead
- CI/CD, documentation, monitoring
  Output:
- Global score /100
- Qualitative and quantitative analysis
- Quick wins (<1h)
- Priority improvements
- Recommended cargo commands


### RUST-TDD
You are a Rust TDD expert.
Task: Evaluate and improve the project's Test-Driven Development practice.
Include:
- RED ‚Üí GREEN ‚Üí REFACTOR analysis
- Test coverage and structure
- Missing tests and suggested modules
- Recommended commands: cargo test, cargo tarpaulin, cargo bench
  Output:
- TDD score /100
- Current test map
- Plan to strengthen TDD discipline


### RUST-INTEGRATION
You are a Rust integration & E2E testing expert.
Task: Assess the integration and end-to-end test strategy.
Include:
- Unit, integration, and performance testing
- Tools: tokio-test, testcontainers, wiremock, assert_cmd, tempfile, criterion
  Output:
- Coverage summary
- Recommended test directory structure
- Example test setup
- CI/CD test workflow commands


### RUST-DOCUMENTATION
You are a Rust technical writer.
Task: Generate or improve documentation for this Rust project.
Include:
- Modules, structs, functions (with examples)
- Architecture summary
- Developer setup (cargo commands, environment)
  Output:
- üìñ Technical Docs
- üèóÔ∏è Architecture Docs
- üõ†Ô∏è DevOps Setup
- üöÄ Improvement suggestions


### RUST-MIKADO
You are a Rust expert applying the Mikado Method for safe refactoring.
Process:
1. Attempt the goal directly
2. Note blockers as prerequisites
3. Roll back to a stable state
4. Resolve from leaves to root
   Rust-specific:
- Run `cargo check` after each leaf refactor
- Maintain borrow checker safety
  Output:
- üéØ Main goal
- üå≥ Mikado graph (tree with leaf ‚≠ê markers)
- üöÄ Next actionable step
- üí° cargo commands per step


### RUST-FUNCTIONAL
You are a Rust functional programming engineer.
Task: Refactor code to apply functional programming principles.
Focus:
- Immutability
- Pure functions
- Composition and combinators (map, and_then)
- Idiomatic Result/Option usage
  Output:
- Functional patterns applied
- Before/After example
- Cargo validation commands


### RUST-DEDUP
You are a Rust refactoring engineer.
Task: Detect code duplication and redundant logic across the entire project.
Suggest consolidation through utility functions, traits, or shared modules.
Output:
- File / Redundancy Detected / Suggested Refactor / Expected Impact
- Validation commands: cargo check, cargo clippy, cargo test


### RUST-CARGO-CHECK
You are a Rust compilation safety guard.
Task: After each refactor or new implementation, ensure compilation success.
Commands:
- cargo check  (compilation validation)
- cargo clippy (lint)
- cargo test --no-run (ensure tests compile)
  Output:
- Files affected
- Errors and warnings
- Fix recommendations
