diff --git a/Cargo.lock b/Cargo.lock
index feeded5..1ee3eec 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -107,6 +107,12 @@ version = "1.0.95"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "34ac096ce696dc2fcabef30516bb13c0a68a11d30131d3df6f04711467681b04"
 
+[[package]]
+name = "assert_matches"
+version = "1.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9b34d609dfbaf33d6889b2b7106d3ca345eacad44200913df5ba02bfd31d2ba9"
+
 [[package]]
 name = "async-stream"
 version = "0.3.6"
@@ -153,25 +159,59 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3b829e4e32b91e643de6eafe82b1d90675f5874230191a4ffbc1b336dec4d6bf"
 dependencies = [
  "async-trait",
- "axum-core",
+ "axum-core 0.3.4",
  "bitflags 1.3.2",
  "bytes",
  "futures-util",
  "http 0.2.12",
- "http-body",
- "hyper",
+ "http-body 0.4.6",
+ "hyper 0.14.32",
+ "itoa",
+ "matchit 0.7.3",
+ "memchr",
+ "mime",
+ "percent-encoding",
+ "pin-project-lite",
+ "rustversion",
+ "serde",
+ "sync_wrapper 0.1.2",
+ "tower 0.4.13",
+ "tower-layer",
+ "tower-service",
+]
+
+[[package]]
+name = "axum"
+version = "0.8.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "021e862c184ae977658b36c4500f7feac3221ca5da43e3f25bd04ab6c79a29b5"
+dependencies = [
+ "axum-core 0.5.2",
+ "bytes",
+ "form_urlencoded",
+ "futures-util",
+ "http 1.2.0",
+ "http-body 1.0.1",
+ "http-body-util",
+ "hyper 1.6.0",
+ "hyper-util",
  "itoa",
- "matchit",
+ "matchit 0.8.4",
  "memchr",
  "mime",
  "percent-encoding",
  "pin-project-lite",
  "rustversion",
  "serde",
- "sync_wrapper",
- "tower",
+ "serde_json",
+ "serde_path_to_error",
+ "serde_urlencoded",
+ "sync_wrapper 1.0.2",
+ "tokio",
+ "tower 0.5.2",
  "tower-layer",
  "tower-service",
+ "tracing",
 ]
 
 [[package]]
@@ -184,11 +224,31 @@ dependencies = [
  "bytes",
  "futures-util",
  "http 0.2.12",
- "http-body",
+ "http-body 0.4.6",
+ "mime",
+ "rustversion",
+ "tower-layer",
+ "tower-service",
+]
+
+[[package]]
+name = "axum-core"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "68464cd0412f486726fb3373129ef5d2993f90c34bc2bc1c1e9943b2f4fc7ca6"
+dependencies = [
+ "bytes",
+ "futures-core",
+ "http 1.2.0",
+ "http-body 1.0.1",
+ "http-body-util",
  "mime",
+ "pin-project-lite",
  "rustversion",
+ "sync_wrapper 1.0.2",
  "tower-layer",
  "tower-service",
+ "tracing",
 ]
 
 [[package]]
@@ -436,19 +496,6 @@ dependencies = [
  "typenum",
 ]
 
-[[package]]
-name = "dashmap"
-version = "5.5.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "978747c1d849a7d2ee5e8adc0159961c48fb7e5db2f06af6723b80123bb53856"
-dependencies = [
- "cfg-if",
- "hashbrown 0.14.5",
- "lock_api",
- "once_cell",
- "parking_lot_core",
-]
-
 [[package]]
 name = "data-encoding"
 version = "2.6.0"
@@ -487,6 +534,28 @@ version = "1.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"
 
+[[package]]
+name = "errno"
+version = "0.3.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cea14ef9355e3beab063703aa9dab15afd25f0667c341310c1e5274bb1d0da18"
+dependencies = [
+ "libc",
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "fastrand"
+version = "2.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"
+
+[[package]]
+name = "fixedbitset"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0ce7134b9999ecaf8bcd65542e436736ef32ddca1b3e06094cb6ec5755203b80"
+
 [[package]]
 name = "flate2"
 version = "1.0.35"
@@ -516,6 +585,15 @@ version = "1.0.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
 
+[[package]]
+name = "form_urlencoded"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
+dependencies = [
+ "percent-encoding",
+]
+
 [[package]]
 name = "futures"
 version = "0.3.31"
@@ -679,12 +757,6 @@ version = "0.12.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
 
-[[package]]
-name = "hashbrown"
-version = "0.14.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
-
 [[package]]
 name = "hashbrown"
 version = "0.15.3"
@@ -739,6 +811,41 @@ dependencies = [
  "pin-project-lite",
 ]
 
+[[package]]
+name = "http-body"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
+dependencies = [
+ "bytes",
+ "http 1.2.0",
+]
+
+[[package]]
+name = "http-body-util"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b021d93e26becf5dc7e1b75b1bed1fd93124b374ceb73f43d4d4eafec896a64a"
+dependencies = [
+ "bytes",
+ "futures-core",
+ "http 1.2.0",
+ "http-body 1.0.1",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "http-range-header"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "add0ab9360ddbd88cfeb3bd9574a1d85cfdfa14db10b3e21d3700dbc4328758f"
+
+[[package]]
+name = "http-range-header"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9171a2ea8a68358193d15dd5d70c1c10a2afc3e7e4c5bc92bc9f025cebd7359c"
+
 [[package]]
 name = "httparse"
 version = "1.9.5"
@@ -763,7 +870,7 @@ dependencies = [
  "futures-util",
  "h2",
  "http 0.2.12",
- "http-body",
+ "http-body 0.4.6",
  "httparse",
  "httpdate",
  "itoa",
@@ -775,18 +882,53 @@ dependencies = [
  "want",
 ]
 
+[[package]]
+name = "hyper"
+version = "1.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cc2b571658e38e0c01b1fdca3bbbe93c00d3d71693ff2770043f8c29bc7d6f80"
+dependencies = [
+ "bytes",
+ "futures-channel",
+ "futures-util",
+ "http 1.2.0",
+ "http-body 1.0.1",
+ "httparse",
+ "httpdate",
+ "itoa",
+ "pin-project-lite",
+ "smallvec",
+ "tokio",
+]
+
 [[package]]
 name = "hyper-timeout"
 version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bbb958482e8c7be4bc3cf272a766a2b0bf1a6755e7a6ae777f017a31d11b13b1"
 dependencies = [
- "hyper",
+ "hyper 0.14.32",
  "pin-project-lite",
  "tokio",
  "tokio-io-timeout",
 ]
 
+[[package]]
+name = "hyper-util"
+version = "0.1.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b1c293b6b3d21eca78250dc7dbebd6b9210ec5530e038cbfe0661b5c47ab06e8"
+dependencies = [
+ "bytes",
+ "futures-core",
+ "http 1.2.0",
+ "http-body 1.0.1",
+ "hyper 1.6.0",
+ "pin-project-lite",
+ "tokio",
+ "tower-service",
+]
+
 [[package]]
 name = "iana-time-zone"
 version = "0.1.61"
@@ -892,14 +1034,10 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d750af042f7ef4f724306de029d18836c26c1765a54a6a3f094cbd23a7267ffa"
 
 [[package]]
-name = "lock_api"
-version = "0.4.12"
+name = "linux-raw-sys"
+version = "0.9.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
-dependencies = [
- "autocfg",
- "scopeguard",
-]
+checksum = "cd945864f07fe9f5371a27ad7b52a172b4b499999f1d97574c9fa68373937e12"
 
 [[package]]
 name = "log"
@@ -913,6 +1051,12 @@ version = "0.7.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0e7465ac9959cc2b1404e8e2367b43684a6d13790fe23056cc8c6c5a6b7bcb94"
 
+[[package]]
+name = "matchit"
+version = "0.8.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "47e1ffaa40ddd1f3ed91f717a33c8c0ee23fff369e3aa8772b9605cc1d22f4c3"
+
 [[package]]
 name = "matrixmultiply"
 version = "0.3.9"
@@ -935,6 +1079,16 @@ version = "0.3.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
 
+[[package]]
+name = "mime_guess"
+version = "2.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f7c44f8e672c00fe5308fa235f821cb4198414e1c77935c1ab6948d3fd78550e"
+dependencies = [
+ "mime",
+ "unicase",
+]
+
 [[package]]
 name = "miniz_oxide"
 version = "0.8.0"
@@ -955,6 +1109,12 @@ dependencies = [
  "windows-sys 0.52.0",
 ]
 
+[[package]]
+name = "multimap"
+version = "0.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1d87ecb2933e8aeadb3e3a02b828fed80a7528047e68b4f424523a0981a3a084"
+
 [[package]]
 name = "ndarray"
 version = "0.16.1"
@@ -1027,19 +1187,6 @@ version = "1.20.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1261fe7e33c73b354eab43b1273a57c8f967d0391e80353e51f764ac02cf6775"
 
-[[package]]
-name = "parking_lot_core"
-version = "0.9.10"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
-dependencies = [
- "cfg-if",
- "libc",
- "redox_syscall",
- "smallvec",
- "windows-targets",
-]
-
 [[package]]
 name = "password-hash"
 version = "0.4.2"
@@ -1069,6 +1216,16 @@ version = "2.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"
 
+[[package]]
+name = "petgraph"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b4c5cc86750666a3ed20bdaf5ca2a0344f9c67674cae0515bec2da16fbaa47db"
+dependencies = [
+ "fixedbitset",
+ "indexmap 2.9.0",
+]
+
 [[package]]
 name = "pin-project"
 version = "1.1.10"
@@ -1137,6 +1294,16 @@ dependencies = [
  "zerocopy 0.7.35",
 ]
 
+[[package]]
+name = "prettyplease"
+version = "0.2.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "664ec5419c51e34154eec046ebcba56312d5a2fc3b09a06da188e1ad21afadf6"
+dependencies = [
+ "proc-macro2",
+ "syn",
+]
+
 [[package]]
 name = "proc-macro2"
 version = "1.0.95"
@@ -1156,6 +1323,27 @@ dependencies = [
  "prost-derive",
 ]
 
+[[package]]
+name = "prost-build"
+version = "0.12.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "22505a5c94da8e3b7c2996394d1c933236c4d743e81a410bcca4e6989fc066a4"
+dependencies = [
+ "bytes",
+ "heck",
+ "itertools",
+ "log",
+ "multimap",
+ "once_cell",
+ "petgraph",
+ "prettyplease",
+ "prost",
+ "prost-types",
+ "regex",
+ "syn",
+ "tempfile",
+]
+
 [[package]]
 name = "prost-derive"
 version = "0.12.6"
@@ -1169,6 +1357,15 @@ dependencies = [
  "syn",
 ]
 
+[[package]]
+name = "prost-types"
+version = "0.12.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9091c90b0a32608e984ff2fa4091273cbdd755d54935c51d520887f4a1dbd5b0"
+dependencies = [
+ "prost",
+]
+
 [[package]]
 name = "quote"
 version = "1.0.40"
@@ -1265,15 +1462,6 @@ dependencies = [
  "crossbeam-utils",
 ]
 
-[[package]]
-name = "redox_syscall"
-version = "0.5.12"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "928fca9cf2aa042393a8325b9ead81d2f0df4cb12e1e24cef072922ccd99c5af"
-dependencies = [
- "bitflags 2.6.0",
-]
-
 [[package]]
 name = "regex"
 version = "1.11.1"
@@ -1309,6 +1497,19 @@ version = "0.1.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"
 
+[[package]]
+name = "rustix"
+version = "1.0.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c71e83d6afe7ff64890ec6b71d6a69bb8a610ab78ce364b3352876bb4c801266"
+dependencies = [
+ "bitflags 2.6.0",
+ "errno",
+ "libc",
+ "linux-raw-sys",
+ "windows-sys 0.59.0",
+]
+
 [[package]]
 name = "rustversion"
 version = "1.0.21"
@@ -1331,12 +1532,6 @@ dependencies = [
  "serde_json",
 ]
 
-[[package]]
-name = "scopeguard"
-version = "1.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
-
 [[package]]
 name = "serde"
 version = "1.0.215"
@@ -1369,6 +1564,28 @@ dependencies = [
  "serde",
 ]
 
+[[package]]
+name = "serde_path_to_error"
+version = "0.1.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "59fab13f937fa393d08645bf3a84bdfe86e296747b506ada67bb15f10f218b2a"
+dependencies = [
+ "itoa",
+ "serde",
+]
+
+[[package]]
+name = "serde_urlencoded"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
+dependencies = [
+ "form_urlencoded",
+ "itoa",
+ "ryu",
+ "serde",
+]
+
 [[package]]
 name = "sha1"
 version = "0.10.6"
@@ -1451,16 +1668,24 @@ version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2047c6ded9c721764247e62cd3b03c09ffc529b2ba5b10ec482ae507a4a70160"
 
+[[package]]
+name = "sync_wrapper"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bf256ce5efdfa370213c1dabab5935a12e49f2c58d15e9eac2870d3b4f27263"
+
 [[package]]
 name = "take_it_easy"
 version = "0.1.0"
 dependencies = [
+ "assert_matches",
+ "axum 0.8.4",
  "chrono",
  "clap",
- "dashmap",
  "flexi_logger",
  "futures",
  "futures-util",
+ "http 0.2.12",
  "log",
  "prost",
  "rand 0.9.0",
@@ -1470,8 +1695,13 @@ dependencies = [
  "tch",
  "tokio",
  "tokio-stream",
+ "tokio-test",
  "tokio-tungstenite",
  "tonic",
+ "tonic-build",
+ "tonic-web",
+ "tower 0.4.13",
+ "tower-http 0.6.4",
  "uuid",
 ]
 
@@ -1492,6 +1722,19 @@ dependencies = [
  "zip",
 ]
 
+[[package]]
+name = "tempfile"
+version = "3.20.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e8a64e3985349f2441a1a9ef0b853f869006c3855f2cda6862a94d26ebb9d6a1"
+dependencies = [
+ "fastrand",
+ "getrandom 0.3.1",
+ "once_cell",
+ "rustix",
+ "windows-sys 0.59.0",
+]
+
 [[package]]
 name = "thiserror"
 version = "1.0.69"
@@ -1553,9 +1796,9 @@ checksum = "ef927ca75afb808a4d64dd374f00a2adf8d0fcff8e7b184af886c3c87ec4a3f3"
 
 [[package]]
 name = "tokio"
-version = "1.42.0"
+version = "1.45.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5cec9b21b0450273377fc97bd4c33a8acffc8c996c987a7c5b319a0083707551"
+checksum = "75ef51a33ef1da925cea3e4eb122833cb377c61439ca401b770f54902b806779"
 dependencies = [
  "backtrace",
  "bytes",
@@ -1579,9 +1822,9 @@ dependencies = [
 
 [[package]]
 name = "tokio-macros"
-version = "2.4.0"
+version = "2.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752"
+checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -1599,6 +1842,19 @@ dependencies = [
  "tokio",
 ]
 
+[[package]]
+name = "tokio-test"
+version = "0.4.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2468baabc3311435b55dd935f702f42cd1b8abb7e754fb7dfb16bd36aa88f9f7"
+dependencies = [
+ "async-stream",
+ "bytes",
+ "futures-core",
+ "tokio",
+ "tokio-stream",
+]
+
 [[package]]
 name = "tokio-tungstenite"
 version = "0.24.0"
@@ -1632,20 +1888,53 @@ checksum = "d560933a0de61cf715926b9cac824d4c883c2c43142f787595e48280c40a1d0e"
 dependencies = [
  "async-stream",
  "async-trait",
- "axum",
+ "axum 0.6.20",
  "base64",
  "bytes",
  "h2",
  "http 0.2.12",
- "http-body",
- "hyper",
+ "http-body 0.4.6",
+ "hyper 0.14.32",
  "hyper-timeout",
  "percent-encoding",
  "pin-project",
  "prost",
  "tokio",
  "tokio-stream",
- "tower",
+ "tower 0.4.13",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+]
+
+[[package]]
+name = "tonic-build"
+version = "0.10.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9d021fc044c18582b9a2408cd0dd05b1596e3ecdb5c4df822bb0183545683889"
+dependencies = [
+ "prettyplease",
+ "proc-macro2",
+ "prost-build",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "tonic-web"
+version = "0.10.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0fddb2a37b247e6adcb9f239f4e5cefdcc5ed526141a416b943929f13aea2cce"
+dependencies = [
+ "base64",
+ "bytes",
+ "http 0.2.12",
+ "http-body 0.4.6",
+ "hyper 0.14.32",
+ "pin-project",
+ "tokio-stream",
+ "tonic",
+ "tower-http 0.4.4",
  "tower-layer",
  "tower-service",
  "tracing",
@@ -1683,6 +1972,65 @@ dependencies = [
  "tracing",
 ]
 
+[[package]]
+name = "tower"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d039ad9159c98b70ecfd540b2573b97f7f52c3e8d9f8ad57a24b916a536975f9"
+dependencies = [
+ "futures-core",
+ "futures-util",
+ "pin-project-lite",
+ "sync_wrapper 1.0.2",
+ "tokio",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+]
+
+[[package]]
+name = "tower-http"
+version = "0.4.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "61c5bb1d698276a2443e5ecfabc1008bf15a36c12e6a7176e7bf089ea9131140"
+dependencies = [
+ "bitflags 2.6.0",
+ "bytes",
+ "futures-core",
+ "futures-util",
+ "http 0.2.12",
+ "http-body 0.4.6",
+ "http-range-header 0.3.1",
+ "pin-project-lite",
+ "tower-layer",
+ "tower-service",
+]
+
+[[package]]
+name = "tower-http"
+version = "0.6.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0fdb0c213ca27a9f57ab69ddb290fd80d970922355b83ae380b395d3986b8a2e"
+dependencies = [
+ "bitflags 2.6.0",
+ "bytes",
+ "futures-util",
+ "http 1.2.0",
+ "http-body 1.0.1",
+ "http-body-util",
+ "http-range-header 0.4.2",
+ "httpdate",
+ "mime",
+ "mime_guess",
+ "percent-encoding",
+ "pin-project-lite",
+ "tokio",
+ "tokio-util",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+]
+
 [[package]]
 name = "tower-layer"
 version = "0.3.3"
@@ -1701,6 +2049,7 @@ version = "0.1.41"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
 dependencies = [
+ "log",
  "pin-project-lite",
  "tracing-attributes",
  "tracing-core",
@@ -1756,6 +2105,12 @@ version = "1.17.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"
 
+[[package]]
+name = "unicase"
+version = "2.8.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "75b844d17643ee918803943289730bec8aac480150456169e647ed0b576ba539"
+
 [[package]]
 name = "unicode-ident"
 version = "1.0.14"
diff --git a/Cargo.toml b/Cargo.toml
index 0e0373a..c39a70f 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -5,7 +5,7 @@ edition = "2021"
 
 [dependencies]
 rand = "0.9.0-beta.1"
-tokio = { version = "1.42.0", features = ["rt", "rt-multi-thread", "macros", "time"] }
+tokio = { version = "1.42.0", features = ["rt", "rt-multi-thread", "macros", "time", "fs"] }
 serde_json = "1.0.133"
 serde = { version = "1.0.188", features = ["derive"] }
 tokio-tungstenite = "0.24.0"
@@ -16,9 +16,28 @@ log = "0.4.22"
 rayon = "1.10.0"
 chrono = "0.4"
 flexi_logger = "0.29.0"
- tonic = "0.10"
- prost = "0.12"
- uuid = { version = "1.0", features = ["v4"] }
- dashmap = "5.5"
- tokio-stream = "0.1"
- futures = "0.3"
+tonic = "0.10"
+prost = "0.12"
+tokio-stream = "0.1"
+uuid = { version = "1.0", features = ["v4"] }
+tonic-web = "0.10"
+axum = "0.8.4"
+tower-http = { version = "0.6.4", features = ["fs", "cors"] }
+http = "0.2.12"
+tower = "0.4.13"
+futures = "0.3.31"
+[build-dependencies]
+tonic-build = "0.10"
+
+[dev-dependencies]
+tokio-test = "0.4"
+assert_matches = "1.5"
+
+# Profils optimisés
+[profile.release]
+lto = true
+codegen-units = 1
+
+[profile.dev]
+debug = true
+opt-level = 0
\ No newline at end of file
diff --git a/build.rs b/build.rs
index e69de29..a6725ee 100644
--- a/build.rs
+++ b/build.rs
@@ -0,0 +1,15 @@
+fn main() -> Result<(), Box<dyn std::error::Error>> {
+    tonic_build::configure()
+        .build_server(true)
+        .build_client(true)
+        .out_dir("src/generated")
+        .compile(
+            &[
+                "protos/common.proto",
+                "protos/session_service.proto",
+                "protos/game_service.proto",
+            ],
+            &["protos"],
+        )?;
+    Ok(())
+}
\ No newline at end of file
diff --git a/diff_output b/diff_output
index 6fd7cd5..5679aa9 100644
--- a/diff_output
+++ b/diff_output
@@ -1,5371 +0,0 @@
-diff --git a/Cargo.lock b/Cargo.lock
-index adc29ae..feeded5 100644
---- a/Cargo.lock
-+++ b/Cargo.lock
-@@ -107,12 +107,90 @@ version = "1.0.95"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "34ac096ce696dc2fcabef30516bb13c0a68a11d30131d3df6f04711467681b04"
- 
-+[[package]]
-+name = "async-stream"
-+version = "0.3.6"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "0b5a71a6f37880a80d1d7f19efd781e4b5de42c88f0722cc13bcb6cc2cfe8476"
-+dependencies = [
-+ "async-stream-impl",
-+ "futures-core",
-+ "pin-project-lite",
-+]
-+
-+[[package]]
-+name = "async-stream-impl"
-+version = "0.3.6"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "c7c24de15d275a1ecfd47a380fb4d5ec9bfe0933f309ed5e705b775596a3574d"
-+dependencies = [
-+ "proc-macro2",
-+ "quote",
-+ "syn",
-+]
-+
-+[[package]]
-+name = "async-trait"
-+version = "0.1.88"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "e539d3fca749fcee5236ab05e93a52867dd549cc157c8cb7f99595f3cedffdb5"
-+dependencies = [
-+ "proc-macro2",
-+ "quote",
-+ "syn",
-+]
-+
- [[package]]
- name = "autocfg"
- version = "1.4.0"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"
- 
-+[[package]]
-+name = "axum"
-+version = "0.6.20"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "3b829e4e32b91e643de6eafe82b1d90675f5874230191a4ffbc1b336dec4d6bf"
-+dependencies = [
-+ "async-trait",
-+ "axum-core",
-+ "bitflags 1.3.2",
-+ "bytes",
-+ "futures-util",
-+ "http 0.2.12",
-+ "http-body",
-+ "hyper",
-+ "itoa",
-+ "matchit",
-+ "memchr",
-+ "mime",
-+ "percent-encoding",
-+ "pin-project-lite",
-+ "rustversion",
-+ "serde",
-+ "sync_wrapper",
-+ "tower",
-+ "tower-layer",
-+ "tower-service",
-+]
-+
-+[[package]]
-+name = "axum-core"
-+version = "0.3.4"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "759fa577a247914fd3f7f76d62972792636412fbfd634cd452f6a385a74d2d2c"
-+dependencies = [
-+ "async-trait",
-+ "bytes",
-+ "futures-util",
-+ "http 0.2.12",
-+ "http-body",
-+ "mime",
-+ "rustversion",
-+ "tower-layer",
-+ "tower-service",
-+]
-+
- [[package]]
- name = "backtrace"
- version = "0.3.74"
-@@ -128,12 +206,24 @@ dependencies = [
-  "windows-targets",
- ]
- 
-+[[package]]
-+name = "base64"
-+version = "0.21.7"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"
-+
- [[package]]
- name = "base64ct"
- version = "1.6.0"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "8c3c1a368f70d6cf7302d78f8f7093da241fb8e8807c05cc9e51a125895a6d5b"
- 
-+[[package]]
-+name = "bitflags"
-+version = "1.3.2"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
-+
- [[package]]
- name = "bitflags"
- version = "2.6.0"
-@@ -346,6 +436,19 @@ dependencies = [
-  "typenum",
- ]
- 
-+[[package]]
-+name = "dashmap"
-+version = "5.5.3"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "978747c1d849a7d2ee5e8adc0159961c48fb7e5db2f06af6723b80123bb53856"
-+dependencies = [
-+ "cfg-if",
-+ "hashbrown 0.14.5",
-+ "lock_api",
-+ "once_cell",
-+ "parking_lot_core",
-+]
-+
- [[package]]
- name = "data-encoding"
- version = "2.6.0"
-@@ -378,6 +481,12 @@ version = "1.13.0"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"
- 
-+[[package]]
-+name = "equivalent"
-+version = "1.0.2"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"
-+
- [[package]]
- name = "flate2"
- version = "1.0.35"
-@@ -407,12 +516,54 @@ version = "1.0.7"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
- 
-+[[package]]
-+name = "futures"
-+version = "0.3.31"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
-+dependencies = [
-+ "futures-channel",
-+ "futures-core",
-+ "futures-executor",
-+ "futures-io",
-+ "futures-sink",
-+ "futures-task",
-+ "futures-util",
-+]
-+
-+[[package]]
-+name = "futures-channel"
-+version = "0.3.31"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
-+dependencies = [
-+ "futures-core",
-+ "futures-sink",
-+]
-+
- [[package]]
- name = "futures-core"
- version = "0.3.31"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"
- 
-+[[package]]
-+name = "futures-executor"
-+version = "0.3.31"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
-+dependencies = [
-+ "futures-core",
-+ "futures-task",
-+ "futures-util",
-+]
-+
-+[[package]]
-+name = "futures-io"
-+version = "0.3.31"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"
-+
- [[package]]
- name = "futures-macro"
- version = "0.3.31"
-@@ -442,10 +593,13 @@ version = "0.3.31"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
- dependencies = [
-+ "futures-channel",
-  "futures-core",
-+ "futures-io",
-  "futures-macro",
-  "futures-sink",
-  "futures-task",
-+ "memchr",
-  "pin-project-lite",
-  "pin-utils",
-  "slab",
-@@ -490,6 +644,25 @@ version = "0.31.1"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"
- 
-+[[package]]
-+name = "h2"
-+version = "0.3.26"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "81fe527a889e1532da5c525686d96d4c2e74cdd345badf8dfef9f6b39dd5f5e8"
-+dependencies = [
-+ "bytes",
-+ "fnv",
-+ "futures-core",
-+ "futures-sink",
-+ "futures-util",
-+ "http 0.2.12",
-+ "indexmap 2.9.0",
-+ "slab",
-+ "tokio",
-+ "tokio-util",
-+ "tracing",
-+]
-+
- [[package]]
- name = "half"
- version = "2.6.0"
-@@ -500,6 +673,24 @@ dependencies = [
-  "crunchy",
- ]
- 
-+[[package]]
-+name = "hashbrown"
-+version = "0.12.3"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
-+
-+[[package]]
-+name = "hashbrown"
-+version = "0.14.5"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
-+
-+[[package]]
-+name = "hashbrown"
-+version = "0.15.3"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "84b26c544d002229e640969970a2e74021aadf6e2f96372b9c58eff97de08eb3"
-+
- [[package]]
- name = "heck"
- version = "0.5.0"
-@@ -515,6 +706,17 @@ dependencies = [
-  "digest",
- ]
- 
-+[[package]]
-+name = "http"
-+version = "0.2.12"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "601cbb57e577e2f5ef5be8e7b83f0f63994f25aa94d673e54a92d5c516d101f1"
-+dependencies = [
-+ "bytes",
-+ "fnv",
-+ "itoa",
-+]
-+
- [[package]]
- name = "http"
- version = "1.2.0"
-@@ -526,12 +728,65 @@ dependencies = [
-  "itoa",
- ]
- 
-+[[package]]
-+name = "http-body"
-+version = "0.4.6"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "7ceab25649e9960c0311ea418d17bee82c0dcec1bd053b5f9a66e265a693bed2"
-+dependencies = [
-+ "bytes",
-+ "http 0.2.12",
-+ "pin-project-lite",
-+]
-+
- [[package]]
- name = "httparse"
- version = "1.9.5"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "7d71d3574edd2771538b901e6549113b4006ece66150fb69c0fb6d9a2adae946"
- 
-+[[package]]
-+name = "httpdate"
-+version = "1.0.3"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"
-+
-+[[package]]
-+name = "hyper"
-+version = "0.14.32"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "41dfc780fdec9373c01bae43289ea34c972e40ee3c9f6b3c8801a35f35586ce7"
-+dependencies = [
-+ "bytes",
-+ "futures-channel",
-+ "futures-core",
-+ "futures-util",
-+ "h2",
-+ "http 0.2.12",
-+ "http-body",
-+ "httparse",
-+ "httpdate",
-+ "itoa",
-+ "pin-project-lite",
-+ "socket2",
-+ "tokio",
-+ "tower-service",
-+ "tracing",
-+ "want",
-+]
-+
-+[[package]]
-+name = "hyper-timeout"
-+version = "0.4.1"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "bbb958482e8c7be4bc3cf272a766a2b0bf1a6755e7a6ae777f017a31d11b13b1"
-+dependencies = [
-+ "hyper",
-+ "pin-project-lite",
-+ "tokio",
-+ "tokio-io-timeout",
-+]
-+
- [[package]]
- name = "iana-time-zone"
- version = "0.1.61"
-@@ -555,6 +810,26 @@ dependencies = [
-  "cc",
- ]
- 
-+[[package]]
-+name = "indexmap"
-+version = "1.9.3"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
-+dependencies = [
-+ "autocfg",
-+ "hashbrown 0.12.3",
-+]
-+
-+[[package]]
-+name = "indexmap"
-+version = "2.9.0"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "cea70ddb795996207ad57735b50c5982d8844f38ba9ee5f1aedcfb708a2aa11e"
-+dependencies = [
-+ "equivalent",
-+ "hashbrown 0.15.3",
-+]
-+
- [[package]]
- name = "inout"
- version = "0.1.3"
-@@ -570,6 +845,15 @@ version = "1.70.1"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"
- 
-+[[package]]
-+name = "itertools"
-+version = "0.12.1"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569"
-+dependencies = [
-+ "either",
-+]
-+
- [[package]]
- name = "itoa"
- version = "1.0.14"
-@@ -587,9 +871,9 @@ dependencies = [
- 
- [[package]]
- name = "js-sys"
--version = "0.3.74"
-+version = "0.3.77"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "a865e038f7f6ed956f788f0d7d60c541fff74c7bd74272c5d4cf15c63743e705"
-+checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
- dependencies = [
-  "once_cell",
-  "wasm-bindgen",
-@@ -603,9 +887,19 @@ checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
- 
- [[package]]
- name = "libc"
--version = "0.2.167"
-+version = "0.2.172"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "09d6582e104315a817dff97f75133544b2e094ee22447d2acf4a74e189ba06fc"
-+checksum = "d750af042f7ef4f724306de029d18836c26c1765a54a6a3f094cbd23a7267ffa"
-+
-+[[package]]
-+name = "lock_api"
-+version = "0.4.12"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
-+dependencies = [
-+ "autocfg",
-+ "scopeguard",
-+]
- 
- [[package]]
- name = "log"
-@@ -613,6 +907,12 @@ version = "0.4.22"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"
- 
-+[[package]]
-+name = "matchit"
-+version = "0.7.3"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "0e7465ac9959cc2b1404e8e2367b43684a6d13790fe23056cc8c6c5a6b7bcb94"
-+
- [[package]]
- name = "matrixmultiply"
- version = "0.3.9"
-@@ -629,6 +929,12 @@ version = "2.7.4"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"
- 
-+[[package]]
-+name = "mime"
-+version = "0.3.17"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
-+
- [[package]]
- name = "miniz_oxide"
- version = "0.8.0"
-@@ -721,6 +1027,19 @@ version = "1.20.2"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "1261fe7e33c73b354eab43b1273a57c8f967d0391e80353e51f764ac02cf6775"
- 
-+[[package]]
-+name = "parking_lot_core"
-+version = "0.9.10"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
-+dependencies = [
-+ "cfg-if",
-+ "libc",
-+ "redox_syscall",
-+ "smallvec",
-+ "windows-targets",
-+]
-+
- [[package]]
- name = "password-hash"
- version = "0.4.2"
-@@ -744,6 +1063,32 @@ dependencies = [
-  "sha2",
- ]
- 
-+[[package]]
-+name = "percent-encoding"
-+version = "2.3.1"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"
-+
-+[[package]]
-+name = "pin-project"
-+version = "1.1.10"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "677f1add503faace112b9f1373e43e9e054bfdd22ff1a63c1bc485eaec6a6a8a"
-+dependencies = [
-+ "pin-project-internal",
-+]
-+
-+[[package]]
-+name = "pin-project-internal"
-+version = "1.1.10"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "6e918e4ff8c4549eb882f14b3a4bc8c8bc93de829416eacf579f1207a8fbf861"
-+dependencies = [
-+ "proc-macro2",
-+ "quote",
-+ "syn",
-+]
-+
- [[package]]
- name = "pin-project-lite"
- version = "0.2.15"
-@@ -794,18 +1139,41 @@ dependencies = [
- 
- [[package]]
- name = "proc-macro2"
--version = "1.0.92"
-+version = "1.0.95"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "37d3544b3f2748c54e147655edb5025752e2303145b5aefb3c3ea2c78b973bb0"
-+checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
- dependencies = [
-  "unicode-ident",
- ]
- 
-+[[package]]
-+name = "prost"
-+version = "0.12.6"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "deb1435c188b76130da55f17a466d252ff7b1418b2ad3e037d127b94e3411f29"
-+dependencies = [
-+ "bytes",
-+ "prost-derive",
-+]
-+
-+[[package]]
-+name = "prost-derive"
-+version = "0.12.6"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "81bddcdb20abf9501610992b6759a4c888aef7d1a7247ef75e2404275ac24af1"
-+dependencies = [
-+ "anyhow",
-+ "itertools",
-+ "proc-macro2",
-+ "quote",
-+ "syn",
-+]
-+
- [[package]]
- name = "quote"
--version = "1.0.37"
-+version = "1.0.40"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
-+checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
- dependencies = [
-  "proc-macro2",
- ]
-@@ -897,6 +1265,15 @@ dependencies = [
-  "crossbeam-utils",
- ]
- 
-+[[package]]
-+name = "redox_syscall"
-+version = "0.5.12"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "928fca9cf2aa042393a8325b9ead81d2f0df4cb12e1e24cef072922ccd99c5af"
-+dependencies = [
-+ "bitflags 2.6.0",
-+]
-+
- [[package]]
- name = "regex"
- version = "1.11.1"
-@@ -932,6 +1309,12 @@ version = "0.1.24"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"
- 
-+[[package]]
-+name = "rustversion"
-+version = "1.0.21"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"
-+
- [[package]]
- name = "ryu"
- version = "1.0.18"
-@@ -948,6 +1331,12 @@ dependencies = [
-  "serde_json",
- ]
- 
-+[[package]]
-+name = "scopeguard"
-+version = "1.2.0"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
-+
- [[package]]
- name = "serde"
- version = "1.0.215"
-@@ -1017,11 +1406,17 @@ dependencies = [
-  "autocfg",
- ]
- 
-+[[package]]
-+name = "smallvec"
-+version = "1.15.0"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "8917285742e9f3e1683f0a9c4e6b57960b7314d0b08d30d1ecd426713ee2eee9"
-+
- [[package]]
- name = "socket2"
--version = "0.5.8"
-+version = "0.5.10"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "c970269d99b64e60ec3bd6ad27270092a5394c4e309314b18ae3fe575695fbe8"
-+checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
- dependencies = [
-  "libc",
-  "windows-sys 0.52.0",
-@@ -1041,31 +1436,43 @@ checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"
- 
- [[package]]
- name = "syn"
--version = "2.0.90"
-+version = "2.0.101"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "919d3b74a5dd0ccd15aeb8f93e7006bd9e14c295087c9896a110f490752bcf31"
-+checksum = "8ce2b7fc941b3a24138a0a7cf8e858bfc6a992e7978a068a5c760deb0ed43caf"
- dependencies = [
-  "proc-macro2",
-  "quote",
-  "unicode-ident",
- ]
- 
-+[[package]]
-+name = "sync_wrapper"
-+version = "0.1.2"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "2047c6ded9c721764247e62cd3b03c09ffc529b2ba5b10ec482ae507a4a70160"
-+
- [[package]]
- name = "take_it_easy"
- version = "0.1.0"
- dependencies = [
-  "chrono",
-  "clap",
-+ "dashmap",
-  "flexi_logger",
-+ "futures",
-  "futures-util",
-  "log",
-+ "prost",
-  "rand 0.9.0",
-  "rayon",
-  "serde",
-  "serde_json",
-  "tch",
-  "tokio",
-+ "tokio-stream",
-  "tokio-tungstenite",
-+ "tonic",
-+ "uuid",
- ]
- 
- [[package]]
-@@ -1160,6 +1567,16 @@ dependencies = [
-  "windows-sys 0.52.0",
- ]
- 
-+[[package]]
-+name = "tokio-io-timeout"
-+version = "1.2.0"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "30b74022ada614a1b4834de765f9bb43877f910cc8ce4be40e89042c9223a8bf"
-+dependencies = [
-+ "pin-project-lite",
-+ "tokio",
-+]
-+
- [[package]]
- name = "tokio-macros"
- version = "2.4.0"
-@@ -1171,6 +1588,17 @@ dependencies = [
-  "syn",
- ]
- 
-+[[package]]
-+name = "tokio-stream"
-+version = "0.1.17"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "eca58d7bba4a75707817a2c44174253f9236b2d5fbd055602e9d5c07c139a047"
-+dependencies = [
-+ "futures-core",
-+ "pin-project-lite",
-+ "tokio",
-+]
-+
- [[package]]
- name = "tokio-tungstenite"
- version = "0.24.0"
-@@ -1183,6 +1611,46 @@ dependencies = [
-  "tungstenite",
- ]
- 
-+[[package]]
-+name = "tokio-util"
-+version = "0.7.15"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "66a539a9ad6d5d281510d5bd368c973d636c02dbf8a67300bfb6b950696ad7df"
-+dependencies = [
-+ "bytes",
-+ "futures-core",
-+ "futures-sink",
-+ "pin-project-lite",
-+ "tokio",
-+]
-+
-+[[package]]
-+name = "tonic"
-+version = "0.10.2"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "d560933a0de61cf715926b9cac824d4c883c2c43142f787595e48280c40a1d0e"
-+dependencies = [
-+ "async-stream",
-+ "async-trait",
-+ "axum",
-+ "base64",
-+ "bytes",
-+ "h2",
-+ "http 0.2.12",
-+ "http-body",
-+ "hyper",
-+ "hyper-timeout",
-+ "percent-encoding",
-+ "pin-project",
-+ "prost",
-+ "tokio",
-+ "tokio-stream",
-+ "tower",
-+ "tower-layer",
-+ "tower-service",
-+ "tracing",
-+]
-+
- [[package]]
- name = "torch-sys"
- version = "0.19.0"
-@@ -1195,6 +1663,75 @@ dependencies = [
-  "zip",
- ]
- 
-+[[package]]
-+name = "tower"
-+version = "0.4.13"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "b8fa9be0de6cf49e536ce1851f987bd21a43b771b09473c3549a6c853db37c1c"
-+dependencies = [
-+ "futures-core",
-+ "futures-util",
-+ "indexmap 1.9.3",
-+ "pin-project",
-+ "pin-project-lite",
-+ "rand 0.8.5",
-+ "slab",
-+ "tokio",
-+ "tokio-util",
-+ "tower-layer",
-+ "tower-service",
-+ "tracing",
-+]
-+
-+[[package]]
-+name = "tower-layer"
-+version = "0.3.3"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"
-+
-+[[package]]
-+name = "tower-service"
-+version = "0.3.3"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"
-+
-+[[package]]
-+name = "tracing"
-+version = "0.1.41"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
-+dependencies = [
-+ "pin-project-lite",
-+ "tracing-attributes",
-+ "tracing-core",
-+]
-+
-+[[package]]
-+name = "tracing-attributes"
-+version = "0.1.28"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "395ae124c09f9e6918a2310af6038fba074bcf474ac352496d5910dd59a2226d"
-+dependencies = [
-+ "proc-macro2",
-+ "quote",
-+ "syn",
-+]
-+
-+[[package]]
-+name = "tracing-core"
-+version = "0.1.33"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "e672c95779cf947c5311f83787af4fa8fffd12fb27e4993211a84bdfd9610f9c"
-+dependencies = [
-+ "once_cell",
-+]
-+
-+[[package]]
-+name = "try-lock"
-+version = "0.2.5"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"
-+
- [[package]]
- name = "tungstenite"
- version = "0.24.0"
-@@ -1204,7 +1741,7 @@ dependencies = [
-  "byteorder",
-  "bytes",
-  "data-encoding",
-- "http",
-+ "http 1.2.0",
-  "httparse",
-  "log",
-  "rand 0.8.5",
-@@ -1237,12 +1774,32 @@ version = "0.2.2"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"
- 
-+[[package]]
-+name = "uuid"
-+version = "1.17.0"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "3cf4199d1e5d15ddd86a694e4d0dffa9c323ce759fea589f00fef9d81cc1931d"
-+dependencies = [
-+ "getrandom 0.3.1",
-+ "js-sys",
-+ "wasm-bindgen",
-+]
-+
- [[package]]
- name = "version_check"
- version = "0.9.5"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"
- 
-+[[package]]
-+name = "want"
-+version = "0.3.1"
-+source = "registry+https://github.com/rust-lang/crates.io-index"
-+checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
-+dependencies = [
-+ "try-lock",
-+]
-+
- [[package]]
- name = "wasi"
- version = "0.11.0+wasi-snapshot-preview1"
-@@ -1260,24 +1817,24 @@ dependencies = [
- 
- [[package]]
- name = "wasm-bindgen"
--version = "0.2.97"
-+version = "0.2.100"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "d15e63b4482863c109d70a7b8706c1e364eb6ea449b201a76c5b89cedcec2d5c"
-+checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
- dependencies = [
-  "cfg-if",
-  "once_cell",
-+ "rustversion",
-  "wasm-bindgen-macro",
- ]
- 
- [[package]]
- name = "wasm-bindgen-backend"
--version = "0.2.97"
-+version = "0.2.100"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "8d36ef12e3aaca16ddd3f67922bc63e48e953f126de60bd33ccc0101ef9998cd"
-+checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
- dependencies = [
-  "bumpalo",
-  "log",
-- "once_cell",
-  "proc-macro2",
-  "quote",
-  "syn",
-@@ -1286,9 +1843,9 @@ dependencies = [
- 
- [[package]]
- name = "wasm-bindgen-macro"
--version = "0.2.97"
-+version = "0.2.100"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "705440e08b42d3e4b36de7d66c944be628d579796b8090bfa3471478a2260051"
-+checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
- dependencies = [
-  "quote",
-  "wasm-bindgen-macro-support",
-@@ -1296,9 +1853,9 @@ dependencies = [
- 
- [[package]]
- name = "wasm-bindgen-macro-support"
--version = "0.2.97"
-+version = "0.2.100"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "98c9ae5a76e46f4deecd0f0255cc223cfa18dc9b261213b8aa0c7b36f61b3f1d"
-+checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
- dependencies = [
-  "proc-macro2",
-  "quote",
-@@ -1309,9 +1866,12 @@ dependencies = [
- 
- [[package]]
- name = "wasm-bindgen-shared"
--version = "0.2.97"
-+version = "0.2.100"
- source = "registry+https://github.com/rust-lang/crates.io-index"
--checksum = "6ee99da9c5ba11bd675621338ef6fa52296b76b83305e9b6e5c77d4c286d6d49"
-+checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
-+dependencies = [
-+ "unicode-ident",
-+]
- 
- [[package]]
- name = "windows-core"
-@@ -1410,7 +1970,7 @@ version = "0.33.0"
- source = "registry+https://github.com/rust-lang/crates.io-index"
- checksum = "3268f3d866458b787f390cf61f4bbb563b922d091359f9608842999eaee3943c"
- dependencies = [
-- "bitflags",
-+ "bitflags 2.6.0",
- ]
- 
- [[package]]
-diff --git a/Cargo.toml b/Cargo.toml
-index 5170311..0e0373a 100644
---- a/Cargo.toml
-+++ b/Cargo.toml
-@@ -16,3 +16,9 @@ log = "0.4.22"
- rayon = "1.10.0"
- chrono = "0.4"
- flexi_logger = "0.29.0"
-+ tonic = "0.10"
-+ prost = "0.12"
-+ uuid = { version = "1.0", features = ["v4"] }
-+ dashmap = "5.5"
-+ tokio-stream = "0.1"
-+ futures = "0.3"
-diff --git a/diff_output b/diff_output
-index ac885b3..7adf05e 100644
---- a/diff_output
-+++ b/diff_output
-@@ -1,3315 +0,0 @@
--diff --git a/src/data/append_result.rs b/src/data/append_result.rs
--index e69de29..5e0a05b 100644
----- a/src/data/append_result.rs
--+++ b/src/data/append_result.rs
--@@ -0,0 +1,23 @@
--+use std::fs::OpenOptions;
--+use std::io::{BufWriter, Write};
--+use chrono::Utc;
--+use futures_util::stream::SplitSink;
--+use futures_util::StreamExt;
--+use tokio::net::TcpListener;
--+use tokio_tungstenite::tungstenite::Message;
--+use tokio_tungstenite::{accept_async, WebSocketStream};
--+
--+pub fn append_to_results_file(file_path: &str, avg_score: f64) {
--+    let timestamp = Utc::now().to_rfc3339();
--+    let result_line = format!("{},{:.2}\n", timestamp, avg_score);
--+
--+    let file = OpenOptions::new()
--+        .create(true)
--+        .append(true)
--+        .open(file_path)
--+        .expect("Unable to open results file");
--+    let mut writer = BufWriter::new(file);
--+    writer
--+        .write_all(result_line.as_bytes())
--+        .expect("Unable to write to results file");
--+}
--diff --git a/src/data/load_data.rs b/src/data/load_data.rs
--index e69de29..b9b6cc9 100644
----- a/src/data/load_data.rs
--+++ b/src/data/load_data.rs
--@@ -0,0 +1,52 @@
--+use std::path::Path;
--+use tch::Tensor;
--+use crate::mcts::mcts_result::MCTSResult;
--+
--+pub fn load_game_data(file_path: &str) -> Vec<MCTSResult> {
--+    // Paths for the .pt files
--+    let states_path = format!("{}_states.pt", file_path);
--+    let positions_path = format!("{}_positions.pt", file_path);
--+    let subscores_path = format!("{}_subscores.pt", file_path);
--+
--+    // Check if all files exist
--+    if !Path::new(&states_path).exists() {
--+        println!(
--+            "⚠️  Warning: '{}' not found. Returning empty dataset.",
--+            states_path
--+        );
--+        return Vec::new();
--+    }
--+    if !Path::new(&positions_path).exists() {
--+        println!(
--+            "⚠️  Warning: '{}' not found. Returning empty dataset.",
--+            positions_path
--+        );
--+        return Vec::new();
--+    }
--+    if !Path::new(&subscores_path).exists() {
--+        println!(
--+            "⚠️  Warning: '{}' not found. Returning empty dataset.",
--+            subscores_path
--+        );
--+        return Vec::new();
--+    }
--+
--+    println!("🚀 Loading game data from .pt files...");
--+
--+    // Load the saved tensors
--+    let state_tensor = Tensor::load(states_path).expect("Failed to load states");
--+    let position_tensor = Tensor::load(positions_path).expect("Failed to load positions");
--+    let subscore_tensor = Tensor::load(subscores_path).expect("Failed to load subscores");
--+
--+    // Convert them back into MCTSResult objects
--+    let mut data = Vec::new();
--+    for i in 0..state_tensor.size()[0] {
--+        data.push(MCTSResult {
--+            board_tensor: state_tensor.get(i),
--+            best_position: position_tensor.get(i).int64_value(&[]) as usize,
--+            subscore: subscore_tensor.get(i).double_value(&[]),
--+        });
--+    }
--+    println!("✅ Loaded {} game records.", data.len());
--+    data
--+}
--\ No newline at end of file
--diff --git a/src/data/mod.rs b/src/data/mod.rs
--index e69de29..85c648b 100644
----- a/src/data/mod.rs
--+++ b/src/data/mod.rs
--@@ -0,0 +1,3 @@
--+pub mod load_data;
--+pub mod save_data;
--+pub mod append_result;
--\ No newline at end of file
--diff --git a/src/data/save_data.rs b/src/data/save_data.rs
--index e69de29..7b2b24f 100644
----- a/src/data/save_data.rs
--+++ b/src/data/save_data.rs
--@@ -0,0 +1,53 @@
--+use tch::Tensor;
--+use crate::mcts::mcts_result::MCTSResult;
--+
--+pub fn save_game_data(file_path: &str, game_data: Vec<MCTSResult>) {
--+    println!("🚀 Saving game data to .pt files...");
--+
--+    let mut tensors = vec![];
--+    let mut positions = vec![];
--+    let mut subscores = vec![];
--+
--+    for result in game_data {
--+        tensors.push(result.board_tensor.shallow_clone());
--+        positions.push(result.best_position as i64);
--+        subscores.push(result.subscore as f32);
--+    }
--+
--+    // Création des nouveaux tensors
--+    let state_tensor = Tensor::stack(&tensors, 0);
--+    let position_tensor = Tensor::from_slice(&positions).view([-1, 1]);
--+    let subscore_tensor = Tensor::from_slice(&subscores).view([-1, 1]);
--+
--+    // 🔄 Append logic: charger les anciens tensors s'ils existent
--+    let combined_states = if let Ok(prev) = Tensor::load(format!("{}_states.pt", file_path)) {
--+        Tensor::cat(&[prev, state_tensor], 0)
--+    } else {
--+        state_tensor
--+    };
--+
--+    let combined_positions = if let Ok(prev) = Tensor::load(format!("{}_positions.pt", file_path)) {
--+        Tensor::cat(&[prev, position_tensor], 0)
--+    } else {
--+        position_tensor
--+    };
--+
--+    let combined_subscores = if let Ok(prev) = Tensor::load(format!("{}_subscores.pt", file_path)) {
--+        Tensor::cat(&[prev, subscore_tensor], 0)
--+    } else {
--+        subscore_tensor
--+    };
--+
--+    // 🔄 Sauvegarde des tensors concaténés
--+    if let Err(e) = combined_states.save(format!("{}_states.pt", file_path)) {
--+        log::info!("❌ Error saving states: {:?}", e);
--+    }
--+    if let Err(e) = combined_positions.save(format!("{}_positions.pt", file_path)) {
--+        log::info!("❌ Error saving positions: {:?}", e);
--+    }
--+    if let Err(e) = combined_subscores.save(format!("{}_subscores.pt", file_path)) {
--+        log::info!("❌ Error saving subscores: {:?}", e);
--+    }
--+
--+    log::info!("✅ Save complete!");
--+}
--diff --git a/src/game/create_deck.rs b/src/game/create_deck.rs
--index 5ea7b53..3a7c7f7 100644
----- a/src/game/create_deck.rs
--+++ b/src/game/create_deck.rs
--@@ -1,7 +1,7 @@
-- use crate::game::deck::Deck;
-- use crate::game::tile::Tile;
-- 
---pub fn create_shuffle_deck() -> Deck {
--+pub fn create_deck() -> Deck {
--     let tiles = vec![
--         new_tiles(1, 2, 3),
--         new_tiles(1, 6, 8),
--@@ -40,13 +40,14 @@ pub(crate) fn new_tiles(x: i32, y: i32, z: i32) -> Tile {
-- }
-- #[cfg(test)]
-- mod tests {
---    use crate::create_deck;
--+    use crate::game::create_deck;
--+    use crate::game::create_deck::create_deck;
--     use crate::game::tile::Tile;
-- 
--     #[test]
--     fn test_create_shuffle_deck() {
--         // Create the shuffle deck
---        let deck = create_shuffle_deck();
--+        let deck = create_deck();
-- 
--         // Check that the deck has exactly 27 tiles
--         assert_eq!(
--diff --git a/src/game/deck.rs b/src/game/deck.rs
--index e69de29..2709b0d 100644
----- a/src/game/deck.rs
--+++ b/src/game/deck.rs
--@@ -0,0 +1,6 @@
--+use crate::game::tile::Tile;
--+
--+#[derive(Debug, Clone, PartialEq)]
--+pub struct Deck{
--+    pub(crate) tiles: Vec<Tile>,
--+}
--\ No newline at end of file
--diff --git a/src/game/get_legal_moves.rs b/src/game/get_legal_moves.rs
--index e69de29..b8c40e3 100644
----- a/src/game/get_legal_moves.rs
--+++ b/src/game/get_legal_moves.rs
--@@ -0,0 +1,17 @@
--+use crate::game::plateau::Plateau;
--+use crate::game::tile::Tile;
--+
--+pub fn get_legal_moves(plateau: Plateau) -> Vec<usize> {
--+    plateau
--+        .tiles
--+        .iter()
--+        .enumerate()
--+        .filter_map(|(i, tile)| {
--+            if *tile == Tile(0, 0, 0) {
--+                Some(i)
--+            } else {
--+                None
--+            }
--+        })
--+        .collect()
--+}
--\ No newline at end of file
--diff --git a/src/game/mod.rs b/src/game/mod.rs
--index e69de29..97a038c 100644
----- a/src/game/mod.rs
--+++ b/src/game/mod.rs
--@@ -0,0 +1,9 @@
--+pub mod deck;
--+pub mod plateau;
--+pub mod game_state;
--+pub mod tile;
--+pub mod create_deck;
--+pub mod remove_tile_from_deck;
--+pub mod plateau_is_full;
--+pub mod get_legal_moves;
--+pub mod simulate_game;
--diff --git a/src/game/plateau.rs b/src/game/plateau.rs
--index f6c4e1c..0502b7a 100644
----- a/src/game/plateau.rs
--+++ b/src/game/plateau.rs
--@@ -1,6 +1,13 @@
---use crate::tile::Tile;
--+use crate::game::tile::Tile;
-- 
-- #[derive(Debug, Clone, PartialEq)]
-- pub(crate) struct Plateau{
--     pub(crate) tiles: Vec<Tile>,
---}
--\ No newline at end of file
--+}
--+
--+
--+pub(crate) fn create_plateau_empty() -> Plateau {
--+    Plateau {
--+        tiles: vec![Tile(0, 0, 0); 19],
--+    }
--+}
--diff --git a/src/game/plateau_is_full.rs b/src/game/plateau_is_full.rs
--index e69de29..050e566 100644
----- a/src/game/plateau_is_full.rs
--+++ b/src/game/plateau_is_full.rs
--@@ -0,0 +1,6 @@
--+use crate::game::plateau::Plateau;
--+use crate::game::tile::Tile;
--+
--+pub fn is_plateau_full(plateau: &Plateau) -> bool {
--+    plateau.tiles.iter().all(|tile| *tile != Tile(0, 0, 0))
--+}
--\ No newline at end of file
--diff --git a/src/game/simulate_game.rs b/src/game/simulate_game.rs
--index e69de29..d370bf1 100644
----- a/src/game/simulate_game.rs
--+++ b/src/game/simulate_game.rs
--@@ -0,0 +1,41 @@
--+use rand::Rng;
--+use crate::game::deck::Deck;
--+use crate::game::get_legal_moves::get_legal_moves;
--+use crate::game::plateau::Plateau;
--+use crate::game::plateau_is_full::is_plateau_full;
--+use crate::game::tile::Tile;
--+use crate::scoring::scoring::result;
--+
--+pub fn simulate_games(plateau: Plateau, deck: Deck) -> i32 {
--+    let mut simulated_plateau = plateau.clone();
--+    let simulated_deck = deck.clone();
--+    let mut legal_moves = get_legal_moves(simulated_plateau.clone());
--+
--+    // Filter out invalid tiles (0, 0, 0)
--+    let mut valid_tiles: Vec<Tile> = simulated_deck
--+        .tiles
--+        .iter()
--+        .cloned()
--+        .filter(|tile| *tile != Tile(0, 0, 0))
--+        .collect();
--+
--+    let mut rng = rand::rng(); // Fixed: Use new API
--+
--+    while !is_plateau_full(&simulated_plateau) {
--+        if legal_moves.is_empty() || valid_tiles.is_empty() {
--+            break;
--+        }
--+
--+        // Fixed: Use new rand API
--+        let position_index = rng.random_range(0..legal_moves.len());
--+        let position = legal_moves.swap_remove(position_index); // Swap-remove for O(1) removal
--+
--+        let tile_index = rng.random_range(0..valid_tiles.len());
--+        let chosen_tile = valid_tiles.swap_remove(tile_index); // Swap-remove for O(1) removal
--+
--+        // Place the chosen tile
--+        simulated_plateau.tiles[position] = chosen_tile;
--+    }
--+
--+    result(&simulated_plateau) // Compute and return the result
--+}
--\ No newline at end of file
--diff --git a/src/main.rs b/src/main.rs
--index 390fb85..90a57dc 100644
----- a/src/main.rs
--+++ b/src/main.rs
--@@ -1,44 +1,61 @@
--+use chrono::Utc;
--+use clap::Parser;
--+use futures_util::stream::SplitSink;
--+use futures_util::{SinkExt, StreamExt};
--+use rand::{rng, Rng};
--+use serde_json;
-- use std::collections::HashMap;
-- use std::fs::OpenOptions;
-- use std::io::{BufWriter, Write};
-- use std::path::Path;
-- use std::sync::Arc;
---use chrono::Utc;
---use clap::Parser;
---use futures_util::{SinkExt, StreamExt};
---use futures_util::stream::SplitSink;
---use rand::{Rng, rng};
---use serde_json;
---use tch::{Device, IndexOp, nn, Tensor};
-- use tch::nn::{Optimizer, OptimizerConfig};
--+use tch::{nn, Device, IndexOp, Tensor};
-- use tokio::net::TcpListener;
---use tokio_tungstenite::{accept_async, WebSocketStream};
-- use tokio_tungstenite::tungstenite::protocol::Message;
--+use tokio_tungstenite::{accept_async, WebSocketStream};
-- 
---use create_plateau_empty::create_plateau_empty;
---use create_shuffle_deck::create_shuffle_deck;
---use result::result;
--+use crate::game::deck::Deck;
--+use crate::game::plateau::create_plateau_empty;
-- use crate::logging::setup_logging;
--+use crate::mcts::mcts_result::MCTSResult;
-- use crate::mcts_vs_human::play_mcts_vs_human;
---use crate::policy_value_net::{PolicyNet, ValueNet};
---use crate::remove_tile_from_deck::replace_tile_in_deck;
---use crate::test::{Deck, Plateau, Tile};
--+use game::create_deck::create_deck;
--+use game::plateau::Plateau;
--+use game::remove_tile_from_deck::replace_tile_in_deck;
--+use game::tile::Tile;
--+use neural::policy_value_net::{PolicyNet, ValueNet};
--+use crate::data::append_result::append_to_results_file;
--+use crate::data::load_data::load_game_data;
--+use crate::data::save_data::save_game_data;
--+use crate::game::get_legal_moves::get_legal_moves;
--+use crate::game::plateau_is_full::is_plateau_full;
--+use crate::game::simulate_game::simulate_games;
--+use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
--+use crate::neural::tensor_conversion::convert_plateau_to_tensor;
--+use crate::neural::training::gradient_clipping::enhanced_gradient_clipping;
--+use crate::neural::training::normalization::robust_state_normalization;
--+use crate::neural::training::trainer::train_network_with_game_data;
--+use crate::scoring::scoring::result;
--+use crate::strategy::position_evaluation::enhanced_position_evaluation;
--+use crate::training::evaluator::evaluate_model;
--+use crate::training::session::train_and_evaluate;
--+use crate::training::websocket::reconnect_websocket;
--+use crate::utils::image::generate_tile_image_names;
--+use crate::utils::random_index::random_index;
-- 
-- mod test;
---mod result;
---mod remove_tile_from_deck;
---mod create_plateau_empty;
---mod create_shuffle_deck;
-- 
---mod policy_value_net;
---mod mcts_vs_human;
--+mod game;
-- mod logging;
---
---fn generate_tile_image_names(tiles: &[Tile]) -> Vec<String> {
---    tiles.iter().map(|tile| {
---        format!("../image/{}{}{}.png", tile.0, tile.1, tile.2)
---    }).collect()
---}
--+mod mcts;
--+mod mcts_vs_human;
--+mod neural;
--+mod utils;
--+mod strategy;
--+mod scoring;
--+mod data;
--+mod training;
-- 
-- #[derive(Parser, Debug)]
-- #[command(name = "take_it_easy")]
--@@ -52,71 +69,10 @@ struct Config {
--     num_simulations: usize,
-- 
--     /// Run MCTS vs Human instead of training
---    #[arg(long)]
--+    #[arg(long, default_value_t = true)]
--     mcts_vs_human: bool,
-- }
---fn enhanced_gradient_clipping(vs_value: &nn::VarStore, vs_policy: &nn::VarStore) -> (f64, f64) {
---    let mut max_grad_value: f64 = 0.0;
---    let mut max_grad_policy: f64 = 0.0;
---
---    tch::no_grad(|| {
---        // Value network - clipping très agressif
---        for (_name, tensor) in vs_value.variables() {
---            if tensor.grad().defined() {
---                let grad_norm = tensor.grad().norm().double_value(&[]);
---                max_grad_value = max_grad_value.max(grad_norm);
-- 
---                // BEAUCOUP plus agressif que (-1.0, 1.0)
---                tensor.grad().clamp_(-0.5, 0.5);
---            }
---        }
---
---        // Policy network - clipping modéré
---        for (_name, tensor) in vs_policy.variables() {
---            if tensor.grad().defined() {
---                let grad_norm = tensor.grad().norm().double_value(&[]);
---                max_grad_policy = max_grad_policy.max(grad_norm);
---
---                tensor.grad().clamp_(-1.0, 1.0);
---            }
---        }
---
---        // Log seulement si vraiment élevé
---        if max_grad_value > 1.0 {
---            log::warn!("🔥 Value grad norm: {:.3}", max_grad_value);
---        }
---        if max_grad_policy > 2.0 {
---            log::warn!("🔥 Policy grad norm: {:.3}", max_grad_policy);
---        }
---    });
---
---    (max_grad_value, max_grad_policy)
---}
---fn robust_state_normalization(state: &Tensor) -> Tensor {
---    // 1. Clamp les valeurs extrêmes
---    let clamped = state.clamp(-10.0, 10.0);
---
---    // 2. Calcul de la médiane pour normalisation robuste
---    let flattened = clamped.view(-1);
---    let sorted = flattened.sort(0, false).0;
---    let median_idx = sorted.size()[0] / 2;
---    let median = sorted.i(median_idx).double_value(&[]);
---
---    // 3. MAD (Median Absolute Deviation) au lieu de std
---    let deviations = (flattened - median).abs();
---    let sorted_dev = deviations.sort(0, false).0;
---    let mad = sorted_dev.i(median_idx).double_value(&[]) * 1.4826;
---
---    // 4. Normalisation avec MAD
---    let normalized = if mad > 1e-6 {
---        (clamped - median) / mad.max(1e-6)
---    } else {
---        clamped - median
---    };
---
---    // 5. Clamp final pour éviter les valeurs extrêmes
---    normalized.clamp(-3.0, 3.0)
---}
-- #[tokio::main]
-- async fn main() {
--     let config = Config::parse();
--@@ -130,15 +86,12 @@ async fn main() {
--     let mut policy_net = PolicyNet::new(&vs_policy, input_dim);
--     let mut value_net = ValueNet::new(&mut vs_value, input_dim);
-- 
---
---
---
---
--     // Load weights if the model directory exists
--     if Path::new(model_path).exists() {
--         log::info!("🔄 Loading model weights from {}", model_path);
-- 
---        if let Err(e) = policy_net.load_model(&mut vs_policy, "model_weights/policy/policy.params") {
--+        if let Err(e) = policy_net.load_model(&mut vs_policy, "model_weights/policy/policy.params")
--+        {
--             log::error!("⚠️ Error loading PolicyNet: {:?}", e);
--             log::info!("➡️  Initializing PolicyNet with random weights.");
--         }
--@@ -150,15 +103,14 @@ async fn main() {
--     } else {
--         log::info!("📭 No pre-trained model found. Initializing new models.");
--     }
---    let mut optimizer_policy = nn::Adam ::default().build(&vs_policy, 1e-3).unwrap();
--+    let mut optimizer_policy = nn::Adam::default().build(&vs_policy, 1e-3).unwrap();
--     // Change your optimizer (around line 100):
--     let mut optimizer_value = nn::Adam {
---        wd: 1e-6,  // Was 1e-5
--+        wd: 1e-6, // Was 1e-5
--         ..Default::default()
---    }.build(&vs_value, 2e-4).unwrap(); // Was 1e-3
---
---
---
--+    }
--+    .build(&vs_value, 2e-4)
--+    .unwrap(); // Was 1e-3
-- 
--     // ➕ Duel Mode: MCTS vs Human
--     if config.mcts_vs_human {
--@@ -178,7 +130,7 @@ async fn main() {
--             &mut write,
--             &mut read,
--         )
---            .await;
--+        .await;
-- 
--         return; // Exit after duel game
--     }
--@@ -201,1210 +153,16 @@ async fn main() {
--         50, // Evaluate every 50 games
--         listener.into(),
--     )
---        .await;
---}
---fn random_index(max: usize) -> usize {
---    use rand::Rng;
---    let mut rng = rand::thread_rng();
---    rng.gen_range(0..max)
---}
---
---// Version simplifiée qui se concentre sur les positions stratégiques
---fn calculate_line_completion_bonus(plateau: &Plateau, position: usize, tile: &Tile) -> f64 {
---    let mut bonus = 0.0;
---
---    // Bonus basé sur les positions stratégiques identifiées dans tes données
---    bonus += match position {
---        8 => 5.0,   // Position 8: 150.6 moyenne - excellente
---        14 => 4.0,  // Position 14: 147.7 moyenne - très bonne
---        2 => 4.0,   // Position 2: 147.1 moyenne - très bonne
---        5 => 3.0,   // Position 5: 143.6 moyenne - bonne
---        11 => 3.0,  // Position 11: 142.9 moyenne - bonne
---        10 => 2.0,  // Position 10: 140.8 moyenne - correcte
---        13 => 2.0,  // Position 13: 140.2 moyenne - correcte
---        1 | 4 | 6 | 9 | 0 => 1.0,  // Positions moyennes
---        12 | 15 | 16 => 0.5,  // Positions plus faibles
---        7 | 17 => 0.0,  // Positions les plus faibles
---        _ => 0.0,
---    };
---
---    // Bonus pour les valeurs de tuiles élevées (plus de points potentiels)
---    let tile_value_bonus = ((tile.0 + tile.1) as f64) * 0.1;
---    bonus += tile_value_bonus;
---
---    // Bonus pour la cohérence des couleurs/formes
---    if tile.0 == tile.1 {
---        bonus += 1.0;  // Tuiles avec même couleur et forme
---    }
---
---    // Bonus central légèrement plus complexe
---    let row = position / 3;
---    let col = position % 3;
---    if row >= 1 && row <= 4 && col >= 1 && col <= 1 {
---        bonus += 2.0;  // Zone centrale du plateau
---    }
---
---    bonus
---}
---
---// ============================================================================
---// ALTERNATIVE PLUS SIMPLE (Si la version ci-dessus pose encore problème)
---// ============================================================================
---
---// Si vous préférez une version plus simple, utilisez celle-ci:
---
---fn enhanced_position_evaluation(plateau: &Plateau, position: usize, tile: &Tile, current_turn: usize) -> f64 {
---    // Score de base alignement (votre fonction existante)
---    let alignment_score = compute_alignment_score(plateau, position, tile);
---
---    // Bonus pour positions centrales stratégiques en début de partie
---    let position_bonus = if current_turn < 8 {
---        match position {
---            7 | 8 | 9 | 10 | 11 => 5.0,    // Ligne centrale - critique
---            4 | 5 | 6 | 12 | 13 | 14 | 15 => 3.0, // Positions stratégiques
---            _ => 0.0,
---        }
---    } else {
---        0.0 // En fin de partie, seul l'alignement compte
---    };
---
---    // Malus pour positions coins/bords si début de partie
---    let position_malus = if current_turn < 5 {
---        match position {
---            0 | 2 | 16 | 18 => -2.0,  // Coins - à éviter en début
---            1 | 17 => -1.0,           // Bords
---            _ => 0.0,
---        }
---    } else {
---        0.0
---    };
---
---    // Bonus pour complétion de lignes
---    let completion_bonus = calculate_line_completion_bonus(plateau, position, tile);
---
---    alignment_score + position_bonus + position_malus + completion_bonus
---}
---
---fn mcts_find_best_position_for_tile_with_nn(
---    plateau: &mut Plateau,
---    deck: &mut Deck,
---    chosen_tile: Tile,
---    policy_net: &PolicyNet,
---    value_net: &ValueNet,
---    num_simulations: usize,
---    current_turn:usize,
---    total_turns:usize,
---) -> MCTSResult {
---    let legal_moves = get_legal_moves(plateau.clone());
---    if legal_moves.is_empty() {
---        return MCTSResult {
---            best_position: 0,
---            board_tensor: convert_plateau_to_tensor(plateau, &chosen_tile, deck,current_turn, total_turns),
---            subscore: 0.0,
---        };
---    }
---
---    let board_tensor = convert_plateau_to_tensor(plateau, &chosen_tile, deck,current_turn, total_turns);
---    let policy_logits = policy_net.forward(&board_tensor, false);
---    let policy = policy_logits.log_softmax(-1, tch::Kind::Float).exp(); // Log-softmax improves numerical stability
---
---    let mut visit_counts: HashMap<usize, usize> = HashMap::new();
---    let mut total_scores: HashMap<usize, f64> = HashMap::new();
---    let mut ucb_scores: HashMap<usize, f64> = HashMap::new();
---    let mut total_visits: i32 = 0;
---
---
---    for &position in &legal_moves {
---        visit_counts.insert(position, 0);
---        total_scores.insert(position, 0.0);
---        ucb_scores.insert(position, f64::NEG_INFINITY);
---    }
---
---    let c_puct = if current_turn < 5 {
---        4.2  // Plus d'exploitation en début de partie (positions critiques)
---    } else if current_turn > 15 {
---        3.0  // Plus d'exploration en fin de partie (adaptation)
---    } else {
---        3.8  // Équilibre pour le milieu de partie
---    };
---
---    // **Compute ValueNet scores for all legal moves**
---    let mut value_estimates = HashMap::new();
---    let mut min_value = f64::INFINITY;
---    let mut max_value = f64::NEG_INFINITY;
---
---    for &position in &legal_moves {
---        let mut temp_plateau = plateau.clone();
---        let mut temp_deck = deck.clone();
---
---        temp_plateau.tiles[position] = chosen_tile;
---        temp_deck = replace_tile_in_deck(&temp_deck, &chosen_tile);
---        let board_tensor_temp = convert_plateau_to_tensor(&temp_plateau, &chosen_tile, &temp_deck,current_turn, total_turns);
---
---        let pred_value = value_net.forward(&board_tensor_temp, false).double_value(&[]);
---        let pred_value = pred_value.clamp(-1.0, 1.0);
---
---        // Track min and max for dynamic pruning
---        min_value = min_value.min(pred_value);
---        max_value = max_value.max(pred_value);
---
---        value_estimates.insert(position, pred_value);
---    }
---
---    // **Dynamic Pruning Strategy**
---    let value_threshold = if current_turn < 8 {
---        min_value + (max_value - min_value) * 0.1  // Garder plus de candidats en début
---    } else {
---        min_value + (max_value - min_value) * 0.15 // Pruning moins agressif
---    };
---
---    for _ in 0..num_simulations {
---        let mut moves_with_prior: Vec<_> = legal_moves
---            .iter()
---            .filter(|&&pos| value_estimates[&pos] >= value_threshold) // Prune weak moves
---            .map(|&pos| (pos, policy.i((0, pos as i64)).double_value(&[])))
---            .collect();
---
---        moves_with_prior.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
---
---        let top_k = usize::min(
---            moves_with_prior.len(),
---            ((total_visits as f64).sqrt() as usize).max(5),
---        );
---
---        let subset_moves: Vec<usize> = moves_with_prior.iter().take(top_k).map(|&(pos, _)| pos).collect();
---
---        for &position in &subset_moves {
---            let mut temp_plateau = plateau.clone();
---            let mut temp_deck = deck.clone();
---
---            temp_plateau.tiles[position] = chosen_tile;
---            temp_deck = replace_tile_in_deck(&temp_deck, &chosen_tile);
---
---            let value_estimate = *value_estimates.get(&position).unwrap_or(&0.0);
---
---            // **Improved Adaptive Rollout Strategy**
---            let rollout_count = match value_estimate {
---                x if x > 8.0 => 2, // Very strong move -> minimal rollouts
---                x if x > 6.0 => 4, // Strong move -> fewer rollouts
---                x if x > 4.0 => 6, // Decent move -> moderate rollouts
---                _ => 8,           // Uncertain move -> more rollouts
---            };
---
---            let mut total_simulated_score = 0.0;
---
---            for _ in 0..rollout_count {
---                let mut lookahead_plateau = temp_plateau.clone();
---                let mut lookahead_deck = temp_deck.clone();
---
---                // 🔮 Étape 1.1 — Tirer une tuile hypothétique (T2)
---                if lookahead_deck.tiles.is_empty() {
---                    continue;
---                }
---                let tile2_index = random_index(lookahead_deck.tiles.len());
---                let tile2 = lookahead_deck.tiles[tile2_index];
---
---                // 🔍 Étape 1.2 — Simuler tous les placements possibles de cette tuile
---                let second_moves = get_legal_moves(lookahead_plateau.clone());
---
---                let mut best_score_for_tile2: f64 = 0.0;
---
---                for &pos2 in &second_moves {
---                    let mut plateau2 = lookahead_plateau.clone();
---                    let mut deck2 = lookahead_deck.clone();
---
---                    plateau2.tiles[pos2] = tile2;
---                    deck2 = replace_tile_in_deck(&deck2, &tile2);
---
---                    let score = simulate_games(plateau2.clone(), deck2.clone()) as f64;
---                    best_score_for_tile2 = best_score_for_tile2.max(score);
---                }
---
---                total_simulated_score += best_score_for_tile2;
---            }
---
---            let simulated_score = total_simulated_score / rollout_count as f64;
---
---            let visits = visit_counts.entry(position).or_insert(0);
---            *visits += 1;
---            total_visits += 1;
---
---            let total_score = total_scores.entry(position).or_insert(0.0);
---            *total_score += simulated_score as f64;
---
---            let exploration_param = c_puct * (total_visits as f64).ln() / (1.0 + *visits as f64);
---            let prior_prob = policy.i((0, position as i64)).double_value(&[]);
---            let average_score = *total_score / (*visits as f64);
---            // 🧪 Reduce weight of rollout average
---            let enhanced_eval = enhanced_position_evaluation(&temp_plateau, position, &chosen_tile, current_turn);
---
---            // Intégrer dans le calcul UCB
---            let mut ucb_score = (average_score * 0.5)
---                + exploration_param * (prior_prob.sqrt())
---                + 0.25 * value_estimate.clamp(0.0, 2.0)
---                + 0.1 * enhanced_eval; // Nouveau facteur d'évaluation
---
---            // 🔥 Explicit Priority Logic HERE 🔥
---            // 1️⃣ Ajoute cette fonction en dehors de ta mcts_find_best_position_for_tile_with_nn
---
---
---            // 2️⃣ Intègre ceci dans ta boucle ucb_scores, juste après le boost fixe
---
---            if chosen_tile.0 == 9 && [7, 8, 9, 10, 11].contains(&position) {
---                ucb_score += 10000.0;  // double boost
---            } else if chosen_tile.0 == 5 && [3, 4, 5, 6, 12, 13, 14, 15].contains(&position) {
---                ucb_score += 8000.0;
---            } else if chosen_tile.0 == 1 && [0, 1, 2, 16, 17, 18].contains(&position) {
---                ucb_score += 6000.0;
---            }
---
---            // 🔥 Alignment Priority Logic 🔥
---
---
---
---
---
---            ucb_scores.insert(position, ucb_score);
---        }
---    }
---
---    // Select the move with the highest UCB score
---    let best_position = legal_moves.into_iter()
---        .max_by(|&a, &b| {
---            ucb_scores.get(&a).unwrap_or(&f64::NEG_INFINITY)
---                .partial_cmp(ucb_scores.get(&b).unwrap_or(&f64::NEG_INFINITY))
---                .unwrap_or(std::cmp::Ordering::Equal)
---        }).unwrap_or(0);
---
---
---    // **NEW: Simulate the Rest of the Game to Get Final Score**
---    let mut final_plateau = plateau.clone();
---    let mut final_deck = deck.clone();
---    final_plateau.tiles[best_position] = chosen_tile;
---    final_deck = replace_tile_in_deck(&final_deck, &chosen_tile);
---
---    while !is_plateau_full(&final_plateau) {
---        let tile_index = random_index(final_deck.tiles.len());
---        let random_tile = final_deck.tiles[tile_index];
---
---        let available_moves = get_legal_moves(final_plateau.clone());
---        if available_moves.is_empty() {
---            break;
---        }
---
---        let random_position = available_moves[random_index(available_moves.len())];
---        final_plateau.tiles[random_position] = random_tile;
---        final_deck = replace_tile_in_deck(&final_deck, &random_tile);
---    }
---
---    let final_score = result(&final_plateau); // Get actual game score
---
---    log::info!("🤖 Pos:{} Score:{}", best_position, final_score as i32);
---
---    MCTSResult {
---        best_position,
---        board_tensor,
---        subscore: final_score as f64, // Store real final score, not UCB score
---    }
---}
---fn local_lookahead(mut plateau: Plateau, mut deck: Deck, depth: usize) -> i32 {
---    for _ in 0..depth {
---        if is_plateau_full(&plateau) || deck.tiles.is_empty() {
---            break;
---        }
---
---        let tile_index = random_index(deck.tiles.len());
---        let chosen_tile = deck.tiles[tile_index];
---
---        let legal_moves = get_legal_moves(plateau.clone());
---        if legal_moves.is_empty() {
---            break;
---        }
---
---        let best_pos = legal_moves
---            .into_iter()
---            .max_by_key(|&pos| compute_alignment_score(&plateau, pos, &chosen_tile) as i32)
---            .unwrap();
---
---        plateau.tiles[best_pos] = chosen_tile;
---        deck = replace_tile_in_deck(&deck, &chosen_tile);
---    }
---
---    result(&plateau)
---}
---fn compute_global_stats(game_data: &[MCTSResult]) -> (Tensor, Tensor) {
---    let stacked = Tensor::cat(
---        &game_data.iter().map(|gd| gd.board_tensor.shallow_clone()).collect::<Vec<_>>(),
---        0
---    );
---
---    let mean = stacked.mean_dim(&[0i64, 2, 3][..], true, tch::Kind::Float);
---    let std = stacked.std_dim(&[0i64, 2, 3][..], true, true).clamp_min(1e-8);
---
---
---    (mean, std)
--+    .await;
-- }
-- 
-- 
-- 
-- 
---fn normalize_input(tensor: &Tensor, global_mean: &Tensor, global_std: &Tensor) -> Tensor {
---    (tensor - global_mean) / (global_std + 1e-8)
---}
---
---
---// Enhanced training function with better value network stabilization
---fn train_network_with_game_data(
---    vs_policy: &nn::VarStore,
---    vs_value: &nn::VarStore,
---    game_data: &[MCTSResult],
---    discount_factor: f64,
---    policy_net: &PolicyNet,
---    value_net: &ValueNet,
---    optimizer_policy: &mut Optimizer,
---    optimizer_value: &mut Optimizer,
---) {
---    // Hyperparameters
---    let entropy_weight = 0.05;
---    let gamma = 0.99;
---    let epsilon = 1e-8;
---
---    // Initialize accumulators
---    let mut predictions = Vec::new();
---    let mut targets = Vec::new();
---    let mut total_policy_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
---    let mut total_value_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
---    let mut total_entropy_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
---
---    // Initialize trajectory rewards and discounted sum
---    let mut trajectory_rewards = Vec::new();
---    let mut discounted_sum = Tensor::zeros(&[], (tch::Kind::Float, tch::Device::Cpu));
---
---    // === Training Loop ===
---    for (step, result) in game_data.iter().rev().enumerate() {
---        // 🛑 No Normalization: Use raw tensor
---        let state = result.board_tensor.shallow_clone();
---        let normalized_state = robust_state_normalization(&state);
---
---        // Forward pass through networks with normalized state
---        let pred_policy = policy_net.forward(&normalized_state, true).clamp_min(1e-7);
---        let pred_value = value_net.forward(&normalized_state, true);
---
---        // Forward pass through networks with normalized state
---        // Normalize reward: divide by a constant max value (e.g., 100)
---        let reward = Tensor::from(result.subscore).to_kind(tch::Kind::Float) / 100.0;
---        let gamma_tensor = Tensor::from_slice(&[gamma]).to_kind(tch::Kind::Float);
---
---        // ✅ NaN & Inf Check for reward
---        if reward.isnan().any().double_value(&[]) > 0.0 || reward.isinf().any().double_value(&[]) > 0.0 {
---            log::error!("⚠️ NaN or Inf detected in reward at step {}", step);
---            continue;
---        }
---
---        // Update discounted sum with normalized reward
---        discounted_sum = reward + gamma_tensor * discounted_sum;
---
---        // ✅ NaN & Inf Check for discounted sum
---        if discounted_sum.isnan().any().double_value(&[]) > 0.0 || discounted_sum.isinf().any().double_value(&[]) > 0.0 {
---            log::error!("⚠️ NaN or Inf detected in discounted sum at step {}", step);
---            continue;
---        }
---
---        // Store the value for analysis
---        trajectory_rewards.push(discounted_sum.double_value(&[]));
---
---        // Generate target tensor directly from discounted sum
---        let discounted_reward = discounted_sum.shallow_clone();
-- 
---        // Append for later analysis
---        predictions.push(pred_value.double_value(&[]));
---        targets.push(discounted_reward.double_value(&[]));
-- 
---        // === Compute Losses ===
---        // Policy loss
---        let best_position = result.best_position as i64;
---        let target_policy = Tensor::zeros(&[1, pred_policy.size()[1]], tch::kind::FLOAT_CPU);
---        target_policy.i((0, best_position)).fill_(1.0);
---        let log_policy = pred_policy.log();
---        let policy_loss = -(target_policy * log_policy.shallow_clone()).sum(tch::Kind::Float);
---        total_policy_loss += policy_loss;
-- 
---        // Entropy loss
---        let entropy_loss = -(pred_policy * (log_policy + epsilon)).sum(tch::Kind::Float);
---        total_entropy_loss += entropy_loss;
-- 
---        // Value loss (Huber loss for better stability)
---        let diff = discounted_reward.shallow_clone() - pred_value.shallow_clone();
---        let abs_diff = diff.abs();
---        let delta = 1.0;
---        let value_loss = abs_diff.le(delta).to_kind(tch::Kind::Float) * 0.5 * &diff * &diff
---            + abs_diff.gt(delta).to_kind(tch::Kind::Float) * (delta * (&abs_diff - 0.5 * delta));
---        total_value_loss += value_loss.mean(tch::Kind::Float);
---    }
---
---    // Fix: Add explicit type annotation for total_loss
---    let total_loss: Tensor = total_policy_loss.shallow_clone()
---        + total_value_loss.shallow_clone()
---        + (entropy_weight * total_entropy_loss.shallow_clone());
---
---    // Log the loss before backpropagation
---    log::info!("💡 Total Loss before backward: {:.4}", total_loss.double_value(&[]));
---
---    // ✅ Enhanced NaN and Inf check before backpropagation
---    if total_loss.isnan().any().double_value(&[]) > 0.0 {
---        log::error!("⚠️ NaN detected in total loss! Skipping backpropagation.");
---        return;
---    }
---    if total_loss.isinf().any().double_value(&[]) > 0.0 {
---        log::error!("⚠️ Inf detected in total loss! Skipping backpropagation.");
---        return;
---    }
---
---    // Check if total_loss requires gradients before calling backward
---    if !total_loss.requires_grad() {
---        log::error!("⚠️ Total loss does not require gradients! Skipping backpropagation.");
---        return;
---    }
---
---    total_loss.backward();
---
---    // Enhanced gradient clipping with fixed type annotation
---    let (_max_grad_value, _max_grad_policy) = enhanced_gradient_clipping(vs_value, vs_policy);
---
---
---    // === Optimizer Step ===
---    optimizer_policy.step();
---    optimizer_policy.zero_grad();
---    optimizer_value.step();
---    optimizer_value.zero_grad();
---
---    log::info!(
---        "🎯 Update Complete | Policy Loss: {:.4}, Value Loss: {:.4}, Entropy Loss: {:.4}",
---        total_policy_loss.double_value(&[]),
---        total_value_loss.double_value(&[]),
---        total_entropy_loss.double_value(&[])
---    );
---}
---
---// Fixed simulate_games function with updated rand API
---
---
---// N-step returns calculation for more stable targets
---fn calculate_n_step_returns(rewards: &[f32], gamma: f32, n: usize) -> Vec<f32> {
---    let mut returns = Vec::new();
---
---    for i in 0..rewards.len() {
---        let mut ret = 0.0;
---        let mut discount = 1.0;
---
---        // Calculate n-step return
---        for j in 0..n.min(rewards.len() - i) {
---            ret += discount * rewards[i + j];
---            discount *= gamma;
---        }
---
---        returns.push(ret / 100.0); // Normalize by dividing by max expected score
---    }
---
---    returns
---}
---
---// Huber loss for more stable value training
---fn huber_loss(predictions: &Tensor, targets: &Tensor, delta: f64) -> Tensor {
---    let diff = predictions - targets;
---    let abs_diff = diff.abs();
---    let quadratic = (abs_diff.le(delta)).to_kind(tch::Kind::Float) * 0.5 * &diff * &diff;
---    let linear = (abs_diff.gt(delta)).to_kind(tch::Kind::Float) *
---        (delta * (&abs_diff - 0.5 * delta));
---    (quadratic + linear).mean(tch::Kind::Float)
---}
---
---// Prediction accuracy calculation for monitoring
---fn calculate_prediction_accuracy(predictions: &[f64], targets: &[f64]) -> f64 {
---    if predictions.is_empty() || targets.is_empty() {
---        return 0.0;
---    }
---
---    let mse: f64 = predictions.iter()
---        .zip(targets.iter())
---        .map(|(p, t)| (p - t).powi(2))
---        .sum::<f64>() / predictions.len() as f64;
---
---    // Convert MSE to accuracy-like metric (higher is better)
---    1.0 / (1.0 + mse.sqrt())
---}
---
---
---
---
---
---
---
---fn convert_plateau_to_tensor(
---    plateau: &Plateau,
---    _tile: &Tile,        // Add underscore prefix
---    _deck: &Deck,        // Add underscore prefix
---    current_turn: usize,
---    total_turns: usize
---) -> Tensor {
---    let mut features = vec![0.0; 5 * 47]; // 5 channels
---
---    // Channel 1-3: Plateau (only use plateau data, not tile/deck)
---    for (i, t) in plateau.tiles.iter().enumerate() {
---        if i < 19 {
---            features[i] = (t.0 as f32 / 10.0).clamp(0.0, 1.0);
---            features[47 + i] = (t.1 as f32 / 10.0).clamp(0.0, 1.0);
---            features[2 * 47 + i] = (t.2 as f32 / 10.0).clamp(0.0, 1.0);
---        }
---    }
---
---    // Channel 4: Score Potential for each position
---    let potential_scores = compute_potential_scores(plateau);
---    for i in 0..19 {
---        features[3 * 47 + i] = potential_scores[i];
---    }
---
---    // Channel 5: Current Turn
---    let turn_normalized = current_turn as f32 / total_turns as f32;
---    for i in 0..19 {
---        features[4 * 47 + i] = turn_normalized;
---    }
---
---    Tensor::from_slice(&features).view([1, 5, 47, 1])
---}
---fn compute_potential_scores(plateau: &Plateau) -> Vec<f32> {
---    let mut scores = vec![0.0; 19]; // Potential score for each position
---
---    let patterns: Vec<(&[usize], i32, Box<dyn Fn(&Tile) -> i32>)> = vec![
---        (&[0, 1, 2], 3, Box::new(|tile: &Tile| tile.0)),
---        (&[3, 4, 5, 6], 4, Box::new(|tile: &Tile| tile.0)),
---        (&[7, 8, 9, 10, 11], 5, Box::new(|tile: &Tile| tile.0)),
---        (&[12, 13, 14, 15], 4, Box::new(|tile: &Tile| tile.0)),
---        (&[16, 17, 18], 3, Box::new(|tile: &Tile| tile.0)),
---        (&[0, 3, 7], 3, Box::new(|tile: &Tile| tile.1)),
---        (&[1, 4, 8, 12], 4, Box::new(|tile: &Tile| tile.1)),
---        (&[2, 5, 9, 13, 16], 5, Box::new(|tile: &Tile| tile.1)),
---        (&[6, 10, 14, 17], 4, Box::new(|tile: &Tile| tile.1)),
---        (&[11, 15, 18], 3, Box::new(|tile: &Tile| tile.1)),
---        (&[7, 12, 16], 3, Box::new(|tile: &Tile| tile.2)),
---        (&[3, 8, 13, 17], 4, Box::new(|tile: &Tile| tile.2)),
---        (&[0, 4, 9, 14, 18], 5, Box::new(|tile: &Tile| tile.2)),
---        (&[1, 5, 10, 15], 4, Box::new(|tile: &Tile| tile.2)),
---        (&[2, 6, 11], 3, Box::new(|tile: &Tile| tile.2)),
---    ];
---
---    for (indices, multiplier, selector) in &patterns {
---        let mut filled_values = Vec::new();
---        let mut empty_positions = Vec::new();
---
---        for &pos in *indices {
---            if plateau.tiles[pos] == Tile(0, 0, 0) {
---                empty_positions.push(pos);
---            } else {
---                filled_values.push(selector(&plateau.tiles[pos]) as f32);
---            }
---        }
---
---        // If at least one tile is placed in the pattern
---        if !filled_values.is_empty() {
---            let avg_filled_value = filled_values.iter().sum::<f32>() / filled_values.len() as f32;
---            let potential_score = avg_filled_value * (*multiplier as f32);
---
---            for &pos in empty_positions.iter() {
---                scores[pos] += potential_score / empty_positions.len() as f32; // Distribute potential score
---            }
---        }
---    }
---
---    scores
---}
---
---// Fix for alignment score function - add underscore prefix
---fn compute_alignment_score(plateau: &Plateau, position: usize, _tile: &Tile) -> f64 {
---    let patterns: Vec<(&[usize], Box<dyn Fn(&Tile) -> i32>)> = vec![
---        (&[0, 1, 2], Box::new(|t: &Tile| t.0)),
---        (&[3, 4, 5, 6], Box::new(|t: &Tile| t.0)),
---        (&[7, 8, 9, 10, 11], Box::new(|t: &Tile| t.0)),
---        (&[12, 13, 14, 15], Box::new(|t: &Tile| t.0)),
---        (&[16, 17, 18], Box::new(|t: &Tile| t.0)),
---        (&[0, 3, 7], Box::new(|t: &Tile| t.1)),
---        (&[1, 4, 8, 12], Box::new(|t: &Tile| t.1)),
---        (&[2, 5, 9, 13, 16], Box::new(|t: &Tile| t.1)),
---        (&[6, 10, 14, 17], Box::new(|t: &Tile| t.1)),
---        (&[11, 15, 18], Box::new(|t: &Tile| t.1)),
---        (&[7, 12, 16], Box::new(|t: &Tile| t.2)),
---        (&[3, 8, 13, 17], Box::new(|t: &Tile| t.2)),
---        (&[0, 4, 9, 14, 18], Box::new(|t: &Tile| t.2)),
---        (&[1, 5, 10, 15], Box::new(|t: &Tile| t.2)),
---        (&[2, 6, 11], Box::new(|t: &Tile| t.2)),
---    ];
---
---    let mut score = 0.0;
---
---    for (indices, selector) in patterns {
---        if indices.contains(&position) {
---            let values: Vec<i32> = indices
---                .iter()
---                .map(|&i| selector(&plateau.tiles[i]))
---                .filter(|&v| v != 0)
---                .collect();
---
---            if !values.is_empty() {
---                let sum = values.iter().sum::<i32>() as f64;
---                score += sum / values.len() as f64;
---            }
---        }
---    }
---
---    score
---}
---
---
---
---
---
---
---
---
---pub fn load_game_data(file_path: &str) -> Vec<MCTSResult> {
---    // Paths for the .pt files
---    let states_path = format!("{}_states.pt", file_path);
---    let positions_path = format!("{}_positions.pt", file_path);
---    let subscores_path = format!("{}_subscores.pt", file_path);
---
---    // Check if all files exist
---    if !Path::new(&states_path).exists() {
---        println!("⚠️  Warning: '{}' not found. Returning empty dataset.", states_path);
---        return Vec::new();
---    }
---    if !Path::new(&positions_path).exists() {
---        println!("⚠️  Warning: '{}' not found. Returning empty dataset.", positions_path);
---        return Vec::new();
---    }
---    if !Path::new(&subscores_path).exists() {
---        println!("⚠️  Warning: '{}' not found. Returning empty dataset.", subscores_path);
---        return Vec::new();
---    }
---
---    println!("🚀 Loading game data from .pt files...");
---
---    // Load the saved tensors
---    let state_tensor = Tensor::load(states_path).expect("Failed to load states");
---    let position_tensor = Tensor::load(positions_path).expect("Failed to load positions");
---    let subscore_tensor = Tensor::load(subscores_path).expect("Failed to load subscores");
---
---    // Convert them back into MCTSResult objects
---    let mut data = Vec::new();
---    for i in 0..state_tensor.size()[0] {
---        data.push(MCTSResult {
---            board_tensor: state_tensor.get(i),
---            best_position: position_tensor.get(i).int64_value(&[]) as usize,
---            subscore: subscore_tensor.get(i).double_value(&[]),
---        });
---    }
---    println!("✅ Loaded {} game records.", data.len());
---    data
---}
---
---
---
---
---fn deserialize_game_data(line: &str) -> Option<MCTSResult> {
---    let parts: Vec<&str> = line.split(',').collect();
---
---    if parts.len() != 3 {
---        log::error!("Invalid data format: '{}'", line);
---        return None;
---    }
---
---    // Parse tensor
---    let state_values: Vec<f32> = parts[0]
---        .split_whitespace()
---        .map(|v| v.parse::<f32>())
---        .collect::<Result<Vec<f32>, _>>()
---        .unwrap_or_else(|_| {
---            log::error!("Failed to parse state tensor in line '{}'", line);
---            vec![]
---        });
---
---    if state_values.len() != 5 * 47 {
---        log::error!("ERROR: Parsed tensor has incorrect size {} (expected 235). Data: '{}'", state_values.len(), parts[0]);
---        return None;
---    }
---
---    let state_tensor = Tensor::from_slice(&state_values).view([1, 5, 47, 1]);
---
---    // Parse subscore
---    let subscore = parts[1].parse::<f64>().unwrap_or_else(|_| {
---        log::error!("Failed to parse subscore in line '{}'", line);
---        0.0
---    });
---
---    // Parse best position
---    let best_position = parts[2].parse::<usize>().unwrap_or_else(|_| {
---        log::error!("Failed to parse best_position in line '{}'", line);
---        0
---    });
---
---    Some(MCTSResult {
---        board_tensor: state_tensor,
---        subscore,
---        best_position,
---    })
---}
---
---
---
---
---fn save_game_data(file_path: &str, game_data: Vec<MCTSResult>) {
---    println!("🚀 Saving game data to .pt files...");
---
---    let mut tensors = vec![];
---    let mut positions = vec![];
---    let mut subscores = vec![];
---
---    for result in game_data {
---        tensors.push(result.board_tensor.shallow_clone());
---        positions.push(result.best_position as i64);
---        subscores.push(result.subscore as f32);
---    }
---
---    // Création des nouveaux tensors
---    let state_tensor = Tensor::stack(&tensors, 0);
---    let position_tensor = Tensor::from_slice(&positions).view([-1, 1]);
---    let subscore_tensor = Tensor::from_slice(&subscores).view([-1, 1]);
---
---    // 🔄 Append logic: charger les anciens tensors s'ils existent
---    let combined_states = if let Ok(prev) = Tensor::load(format!("{}_states.pt", file_path)) {
---        Tensor::cat(&[prev, state_tensor], 0)
---    } else {
---        state_tensor
---    };
---
---    let combined_positions = if let Ok(prev) = Tensor::load(format!("{}_positions.pt", file_path)) {
---        Tensor::cat(&[prev, position_tensor], 0)
---    } else {
---        position_tensor
---    };
---
---    let combined_subscores = if let Ok(prev) = Tensor::load(format!("{}_subscores.pt", file_path)) {
---        Tensor::cat(&[prev, subscore_tensor], 0)
---    } else {
---        subscore_tensor
---    };
---
---    // 🔄 Sauvegarde des tensors concaténés
---    if let Err(e) = combined_states.save(format!("{}_states.pt", file_path)) {
---        log::info!("❌ Error saving states: {:?}", e);
---    }
---    if let Err(e) = combined_positions.save(format!("{}_positions.pt", file_path)) {
---        log::info!("❌ Error saving positions: {:?}", e);
---    }
---    if let Err(e) = combined_subscores.save(format!("{}_subscores.pt", file_path)) {
---        log::info!("❌ Error saving subscores: {:?}", e);
---    }
---
---    log::info!("✅ Save complete!");
---}
---
---
---fn tensor_to_vec(tensor: &Tensor) -> Vec<f32> {
---    // Flatten the tensor into a 1D array
---    let flattened = tensor.view(-1); // Reshape the tensor to a 1D view
---
---    // Convert each value in the flattened tensor to f32 and collect into a Vec
---    let mut vec = Vec::new();
---    for i in 0..flattened.size()[0] {
---        let value = flattened.i(i).double_value(&[]) as f32;
---        vec.push(value);
---    }
---
---    vec
---}
---
---
---fn serialize_tensor(tensor: Tensor) -> String {
---    let data: Vec<f32> = tensor_to_vec(&tensor); // Converts the slice to a Vec<f32>
---    data.iter()
---        .map(|v| v.to_string())
---        .collect::<Vec<_>>()
---        .join(" ")
---}
---#[derive(Debug)]
---pub struct MCTSResult {
---    pub board_tensor: Tensor,
---    pub best_position: usize,
---    pub subscore: f64,
---}
---
---impl Clone for MCTSResult {
---    fn clone(&self) -> Self {
---        MCTSResult {
---            board_tensor: self.board_tensor.shallow_clone(), // Manually clone the tensor
---            best_position: self.best_position,
---            subscore: self.subscore,
---        }
---    }
---}
---
---fn append_to_results_file(file_path: &str,  avg_score: f64) {
---    let timestamp = Utc::now().to_rfc3339();
---    let result_line = format!("{},{:.2}\n",timestamp,  avg_score );
---
---    let file = OpenOptions::new()
---        .create(true)
---        .append(true)
---        .open(file_path)
---        .expect("Unable to open results file");
---    let mut writer = BufWriter::new(file);
---    writer
---        .write_all(result_line.as_bytes())
---        .expect("Unable to write to results file");
---}
---async fn reconnect_websocket(
---    listener: &TcpListener,
---) -> Option<SplitSink<WebSocketStream<tokio::net::TcpStream>, Message>> {
---    match listener.accept().await {
---        Ok((stream, _)) => {
---            log::info!("Re-establishing WebSocket connection...");
---            let ws_stream = accept_async(stream).await.expect("Failed to accept WebSocket");
---            let (write, _) = ws_stream.split();
---            Some(write)
---        }
---        Err(e) => {
---            log::error!("Error while reconnecting WebSocket: {:?}", e);
---            None
---        }
---    }
---}
---async fn train_and_evaluate(
---    vs_policy: &nn::VarStore,
---    vs_value: &nn::VarStore,
---    policy_net: &mut PolicyNet,
---    value_net: &mut ValueNet,
---    optimizer_policy: &mut Optimizer,
---    optimizer_value: &mut Optimizer,
---    num_games: usize,
---    num_simulations: usize,
---    evaluation_interval: usize,
---    listener: Arc<TcpListener>,
---) {
---    let mut total_score = 0;
---    let mut games_played = 0;
---    let results_file = "results.csv";
---
---    while let Ok((stream, _)) = listener.accept().await {
---        let ws_stream = accept_async(stream).await.expect("Failed to accept WebSocket");
---        let (mut write, _) = ws_stream.split();
---        let mut scores_by_position: HashMap<usize, Vec<i32>> = HashMap::new();
---        let mut scores = Vec::new(); // Stocke les scores
---        let evaluation_interval_average = 10;
---
---        while games_played < num_games {
---
---            log::info!(
---                "Starting training iteration {}/{}...",
---                games_played + 1,
---                num_games
---            );
---            log::info!("\n🚀 Starting Batch {}", games_played / evaluation_interval + 1);
---
---            let mut batch_games_played = 0; // Tracks games processed in this evaluation interval
---
---            let max_memory_size = 1000; // Store last 500 games
---
---            for game in 0..evaluation_interval {
---                let mut deck = create_shuffle_deck();
---                let mut plateau = create_plateau_empty();
---                let mut game_data = Vec::new();
---                let mut first_move: Option<(usize, Tile)> = None;
---                let total_turns = 19; // The number of moves in the game
---                let mut current_turn = 0;
---                while !is_plateau_full(&plateau) {
---                    let tile_index = rng().random_range(0..deck.tiles.len());
---                    let chosen_tile = deck.tiles[tile_index];
---                    // ✅ **Send preview before placement**
---                    // ✅ **INSERT YOUR NEW CODE HERE**
---                    let chosen_tile_image = format!("../image/{}{}{}.png", chosen_tile.0, chosen_tile.1, chosen_tile.2);
---                    let payload = serde_json::json!({
---        "next_tile": chosen_tile_image,
---        "plateau_tiles": generate_tile_image_names(&plateau.tiles)
---    });
---                    let serialized = serde_json::to_string(&payload).unwrap();
---                    write.send(Message::Text(serialized)).await.unwrap();
---
---                    let game_result = mcts_find_best_position_for_tile_with_nn(
---                        &mut plateau,
---                        &mut deck,
---                        chosen_tile,
---                        policy_net,
---                        value_net,
---                        num_simulations,
---                        current_turn,
---                        total_turns,
---                    );
---
---                    let best_position = game_result.best_position;
---                    if first_move.is_none() {
---                        first_move = Some((best_position, chosen_tile));
---                    }
---                    plateau.tiles[best_position] = chosen_tile;
---                    deck = replace_tile_in_deck(&deck, &chosen_tile);
---                    // ✅ INSERT THIS TO SEND SCORE TO CLIENT
---                    let current_score = result(&plateau);
---                    let score_payload = serde_json::json!({
---    "type": "score_update",
---    "current_score": current_score,
---});
---                    let serialized_score = serde_json::to_string(&score_payload).unwrap();
---                    if let Err(e) = write.send(Message::Text(serialized_score)).await {
---                        log::error!("WebSocket error when sending score: {:?}", e);
---                        if let Some(new_write) = reconnect_websocket(&listener).await {
---                            write = new_write;
---                        } else {
---                            log::error!("Failed to reconnect WebSocket. Exiting...");
---                            break;
---                        }
---                    }
---
---                    game_data.push(game_result); // Store training data
---
---                    // ✅ **INSERT YOUR NEW CODE HERE**
---                    let payload_after_placement = serde_json::json!({
---        "next_tile": null, // Clear preview
---        "plateau_tiles": generate_tile_image_names(&plateau.tiles) // new updated state
---    });
---                    let serialized = serde_json::to_string(&payload_after_placement).unwrap();
---
---                    // ✅ Handle WebSocket disconnections
---                    if let Err(e) = write.send(Message::Text(serialized.clone())).await {
---                        log::error!("WebSocket error: {:?}. Attempting to reconnect...", e);
---
---                        // **Reconnect WebSocket**
---                        if let Some(new_write) = reconnect_websocket(&listener).await {
---                            write = new_write;
---                        } else {
---                            log::error!("Failed to reconnect WebSocket. Exiting...");
---                            break;
---                        }
---                    }
---                    current_turn += 1; // Increment turn counter each time a tile is placed
---
---                }
---
---                let final_score = result(&plateau);
---
---                if let Some((position, _)) = first_move {
---                    scores_by_position
---                        .entry(position)
---                        .or_insert_with(Vec::new)
---                        .push(final_score);
---                }
---
---                let mut batch_game_data = Vec::new();
---
---                // Prioritized historical data
---                let prioritized_data: Vec<MCTSResult> = load_game_data("game_data")
---                    .into_iter().filter(|r| r.subscore > 100.0) // Only select high-score games
---                    .take(50) // Limit to 50 samples to prevent overfitting
---                    .collect();
---
---                // Add historical data to batch
---                batch_game_data.extend(prioritized_data);
---
---                // Add current game's data to batch
---                batch_game_data.extend(game_data.iter().map(|result| MCTSResult {
---                    best_position: result.best_position,
---                    board_tensor: result.board_tensor.shallow_clone(),
---                    subscore: result.subscore,
---                }));
---
---                // Keep only last max_memory_size experiences
---                if batch_game_data.len() > max_memory_size {
---                    let to_remove = batch_game_data.len() - max_memory_size;
---                    batch_game_data.drain(0..to_remove); // Remove oldest data
---                }
---
---                // Train in batches
---                let batch_size = 10;
---                for batch in batch_game_data.chunks(batch_size) {
---                    train_network_with_game_data(
---                        &vs_policy,
---                        &vs_value,
---                        batch, // Use each batch directly
---                        final_score.into(),
---                        policy_net,
---                        value_net,
---                        optimizer_policy,
---                        optimizer_value,
---                    );
---                }
---
---                log::info!("Game {} finished with score: {}", game + 1, final_score);
---                scores.push(final_score);
---
---                // Update batch-specific counters
---                batch_games_played += 1;
---                total_score += final_score;
---
---                if game % evaluation_interval_average == 0 && game != 0 {
---                    let moyenne: f64 = scores.iter().sum::<i32>() as f64 / scores.len() as f64;
---                    log::info!("📊 [Batch {}] Avg Score: {:.2} | Games Played: {}", games_played / evaluation_interval, moyenne, games_played);
---                    log::info!("batch {} - Score moyen: {:.2}", game, moyenne);
---                    write.send(Message::Text(format!("GAME_RESULT:{}", moyenne))).await.unwrap();
---                }
---
---                // Save current game data for future training
---                save_game_data("game_data", game_data);
---            }
---
---
---            // Update main game counters
---            games_played += batch_games_played;
---
---            // Append results to the file
---            let avg_score = total_score as f64 / games_played as f64;
---            append_to_results_file(results_file,  avg_score);
---
---            // Calculate and display averages
---            let mut averages: Vec<(usize, f64)> = scores_by_position
---                .iter()
---                .map(|(position, scores)| {
---                    let average_score: f64 =
---                        scores.iter().sum::<i32>() as f64 / scores.len() as f64;
---                    (*position, average_score)
---                })
---                .collect();
---
---            averages.sort_by(|a, b| {
---                b.1.partial_cmp(&a.1)
---                    .unwrap_or(std::cmp::Ordering::Equal)
---            });
---
---            log::info!("\n--- Average Scores by First Position (Sorted) ---");
---            for (position, average_score) in averages {
---                log::info!("Position: {}, Average Score: {:.2}", position, average_score);
---            }
---
---            // Evaluate model after each interval
---            evaluate_model(policy_net, value_net,num_simulations).await;
---
---            log::info!(
---                "Games Played: {}, Total Score: {}, Avg Score: {:.2}",
---                games_played,
---                total_score,
---                total_score as f32 / games_played as f32
---            );
---            let model_path = "model_weights";
---            // Save model weights
---            log::info!("Saving models to {}", model_path);
---            log::info!("Saving model weights...");
---            if let Err(e) = policy_net.save_model(vs_policy,"model_weights/policy/policy.params") {
---                log::error!("Error saving PolicyNet weights: {:?}", e);
---            }
---            if let Err(e) = value_net.save_model(vs_value,"model_weights/value/value.params") {
---                log::error!("Error saving ValueNet weights: {:?}", e);
---            }
---        }
---        break; // Exit after handling one connection
---    }
---}
---
---async fn evaluate_model(
---    policy_net: &PolicyNet,
---    value_net: &ValueNet,
---    num_simulations: usize,
---) {
---    log::info!("Evaluating model...");
---    let mut scores = Vec::new();
---
---    for _ in 0..10 {
---        let mut deck = create_shuffle_deck();
---        let mut plateau = create_plateau_empty();
---        let total_turns = 19; // The number of moves in the game
---        let mut current_turn = 0;
---        while !is_plateau_full(&plateau) {
---            let tile_index = rng().random_range(0..deck.tiles.len());
---            let chosen_tile = deck.tiles[tile_index];
---            let game_result = mcts_find_best_position_for_tile_with_nn(
---                &mut plateau,
---                &mut deck,
---                chosen_tile,
---                policy_net,
---                value_net,
---                num_simulations,
---                current_turn,
---                total_turns,
---            );
---            let best_position = game_result.best_position;
---            plateau.tiles[best_position] = chosen_tile;
---            deck = replace_tile_in_deck(&deck, &chosen_tile);
---            current_turn += 1; // Increment turn counter each time a tile is placed
---
---        }
---
---        let game_score = result(&plateau);
---        scores.push(game_score);
---    }
---
---    let avg_score: f64 = scores.iter().copied().sum::<i32>() as f64 / scores.len() as f64;
---    log::info!("Model Evaluation Complete. Avg Score: {:.2}", avg_score);
---    // **Stop ping task**
---}
---
---
---/// Checks if the plateau is full
---fn is_plateau_full(plateau: &Plateau) -> bool {
---    plateau.tiles.iter().all(|tile| *tile != Tile(0, 0, 0))
---}
---
---/// Finds the best move using MCTS
---
---
---/// Simulates num_simulations games and returns the average score
---
---fn simulate_games(plateau: Plateau, deck: Deck) -> i32 {
---    let mut simulated_plateau = plateau.clone();
---    let simulated_deck = deck.clone();
---    let mut legal_moves = get_legal_moves(simulated_plateau.clone());
---
---    // Filter out invalid tiles (0, 0, 0)
---    let mut valid_tiles: Vec<Tile> = simulated_deck
---        .tiles
---        .iter()
---        .cloned()
---        .filter(|tile| *tile != Tile(0, 0, 0))
---        .collect();
---
---    let mut rng = rand::rng(); // Fixed: Use new API
---
---    while !is_plateau_full(&simulated_plateau) {
---        if legal_moves.is_empty() || valid_tiles.is_empty() {
---            break;
---        }
---
---        // Fixed: Use new rand API
---        let position_index = rng.random_range(0..legal_moves.len());
---        let position = legal_moves.swap_remove(position_index); // Swap-remove for O(1) removal
---
---        let tile_index = rng.random_range(0..valid_tiles.len());
---        let chosen_tile = valid_tiles.swap_remove(tile_index); // Swap-remove for O(1) removal
---
---        // Place the chosen tile
---        simulated_plateau.tiles[position] = chosen_tile;
---    }
---
---    result(&simulated_plateau) // Compute and return the result
---}
-- 
-- 
-- 
---/// Get all legal moves (empty positions) on the plateau
---fn get_legal_moves(plateau: Plateau) -> Vec<usize> {
---    plateau
---        .tiles
---        .iter()
---        .enumerate()
---        .filter_map(|(i, tile)| if *tile == Tile(0, 0, 0) { Some(i) } else { None })
---        .collect()
---}
--\ No newline at end of file
--diff --git a/src/mcts/algorithm.rs b/src/mcts/algorithm.rs
--index e69de29..88c272f 100644
----- a/src/mcts/algorithm.rs
--+++ b/src/mcts/algorithm.rs
--@@ -0,0 +1,255 @@
--+use std::collections::HashMap;
--+use tch::IndexOp;
--+use crate::game::deck::Deck;
--+use crate::game::get_legal_moves::get_legal_moves;
--+use crate::game::plateau::Plateau;
--+use crate::game::plateau_is_full::is_plateau_full;
--+use crate::game::remove_tile_from_deck::replace_tile_in_deck;
--+use crate::game::simulate_game::simulate_games;
--+use crate::game::tile::Tile;
--+use crate::mcts::mcts_result::MCTSResult;
--+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
--+use crate::neural::tensor_conversion::convert_plateau_to_tensor;
--+use crate::scoring::scoring::result;
--+use crate::strategy::position_evaluation::enhanced_position_evaluation;
--+use crate::utils::random_index::random_index;
--+
--+pub fn mcts_find_best_position_for_tile_with_nn(
--+    plateau: &mut Plateau,
--+    deck: &mut Deck,
--+    chosen_tile: Tile,
--+    policy_net: &PolicyNet,
--+    value_net: &ValueNet,
--+    num_simulations: usize,
--+    current_turn: usize,
--+    total_turns: usize,
--+) -> MCTSResult {
--+    let legal_moves = get_legal_moves(plateau.clone());
--+    if legal_moves.is_empty() {
--+        return MCTSResult {
--+            best_position: 0,
--+            board_tensor: convert_plateau_to_tensor(
--+                plateau,
--+                &chosen_tile,
--+                deck,
--+                current_turn,
--+                total_turns,
--+            ),
--+            subscore: 0.0,
--+        };
--+    }
--+
--+    let board_tensor =
--+        convert_plateau_to_tensor(plateau, &chosen_tile, deck, current_turn, total_turns);
--+    let policy_logits = policy_net.forward(&board_tensor, false);
--+    let policy = policy_logits.log_softmax(-1, tch::Kind::Float).exp(); // Log-softmax improves numerical stability
--+
--+    let mut visit_counts: HashMap<usize, usize> = HashMap::new();
--+    let mut total_scores: HashMap<usize, f64> = HashMap::new();
--+    let mut ucb_scores: HashMap<usize, f64> = HashMap::new();
--+    let mut total_visits: i32 = 0;
--+
--+    for &position in &legal_moves {
--+        visit_counts.insert(position, 0);
--+        total_scores.insert(position, 0.0);
--+        ucb_scores.insert(position, f64::NEG_INFINITY);
--+    }
--+
--+    let c_puct = if current_turn < 5 {
--+        4.2 // Plus d'exploitation en début de partie (positions critiques)
--+    } else if current_turn > 15 {
--+        3.0 // Plus d'exploration en fin de partie (adaptation)
--+    } else {
--+        3.8 // Équilibre pour le milieu de partie
--+    };
--+
--+    // **Compute ValueNet scores for all legal moves**
--+    let mut value_estimates = HashMap::new();
--+    let mut min_value = f64::INFINITY;
--+    let mut max_value = f64::NEG_INFINITY;
--+
--+    for &position in &legal_moves {
--+        let mut temp_plateau = plateau.clone();
--+        let mut temp_deck = deck.clone();
--+
--+        temp_plateau.tiles[position] = chosen_tile;
--+        temp_deck = replace_tile_in_deck(&temp_deck, &chosen_tile);
--+        let board_tensor_temp = convert_plateau_to_tensor(
--+            &temp_plateau,
--+            &chosen_tile,
--+            &temp_deck,
--+            current_turn,
--+            total_turns,
--+        );
--+
--+        let pred_value = value_net
--+            .forward(&board_tensor_temp, false)
--+            .double_value(&[]);
--+        let pred_value = pred_value.clamp(-1.0, 1.0);
--+
--+        // Track min and max for dynamic pruning
--+        min_value = min_value.min(pred_value);
--+        max_value = max_value.max(pred_value);
--+
--+        value_estimates.insert(position, pred_value);
--+    }
--+
--+    // **Dynamic Pruning Strategy**
--+    let value_threshold = if current_turn < 8 {
--+        min_value + (max_value - min_value) * 0.1 // Garder plus de candidats en début
--+    } else {
--+        min_value + (max_value - min_value) * 0.15 // Pruning moins agressif
--+    };
--+
--+    for _ in 0..num_simulations {
--+        let mut moves_with_prior: Vec<_> = legal_moves
--+            .iter()
--+            .filter(|&&pos| value_estimates[&pos] >= value_threshold) // Prune weak moves
--+            .map(|&pos| (pos, policy.i((0, pos as i64)).double_value(&[])))
--+            .collect();
--+
--+        moves_with_prior.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
--+
--+        let top_k = usize::min(
--+            moves_with_prior.len(),
--+            ((total_visits as f64).sqrt() as usize).max(5),
--+        );
--+
--+        let subset_moves: Vec<usize> = moves_with_prior
--+            .iter()
--+            .take(top_k)
--+            .map(|&(pos, _)| pos)
--+            .collect();
--+
--+        for &position in &subset_moves {
--+            let mut temp_plateau = plateau.clone();
--+            let mut temp_deck = deck.clone();
--+
--+            temp_plateau.tiles[position] = chosen_tile;
--+            temp_deck = replace_tile_in_deck(&temp_deck, &chosen_tile);
--+
--+            let value_estimate = *value_estimates.get(&position).unwrap_or(&0.0);
--+
--+            // **Improved Adaptive Rollout Strategy**
--+            let rollout_count = match value_estimate {
--+                x if x > 8.0 => 2, // Very strong move -> minimal rollouts
--+                x if x > 6.0 => 4, // Strong move -> fewer rollouts
--+                x if x > 4.0 => 6, // Decent move -> moderate rollouts
--+                _ => 8,            // Uncertain move -> more rollouts
--+            };
--+
--+            let mut total_simulated_score = 0.0;
--+
--+            for _ in 0..rollout_count {
--+                let mut lookahead_plateau = temp_plateau.clone();
--+                let mut lookahead_deck = temp_deck.clone();
--+
--+                // 🔮 Étape 1.1 — Tirer une tuile hypothétique (T2)
--+                if lookahead_deck.tiles.is_empty() {
--+                    continue;
--+                }
--+                let tile2_index = random_index(lookahead_deck.tiles.len());
--+                let tile2 = lookahead_deck.tiles[tile2_index];
--+
--+                // 🔍 Étape 1.2 — Simuler tous les placements possibles de cette tuile
--+                let second_moves = get_legal_moves(lookahead_plateau.clone());
--+
--+                let mut best_score_for_tile2: f64 = 0.0;
--+
--+                for &pos2 in &second_moves {
--+                    let mut plateau2 = lookahead_plateau.clone();
--+                    let mut deck2 = lookahead_deck.clone();
--+
--+                    plateau2.tiles[pos2] = tile2;
--+                    deck2 = replace_tile_in_deck(&deck2, &tile2);
--+
--+                    let score = simulate_games(plateau2.clone(), deck2.clone()) as f64;
--+                    best_score_for_tile2 = best_score_for_tile2.max(score);
--+                }
--+
--+                total_simulated_score += best_score_for_tile2;
--+            }
--+
--+            let simulated_score = total_simulated_score / rollout_count as f64;
--+
--+            let visits = visit_counts.entry(position).or_insert(0);
--+            *visits += 1;
--+            total_visits += 1;
--+
--+            let total_score = total_scores.entry(position).or_insert(0.0);
--+            *total_score += simulated_score as f64;
--+
--+            let exploration_param = c_puct * (total_visits as f64).ln() / (1.0 + *visits as f64);
--+            let prior_prob = policy.i((0, position as i64)).double_value(&[]);
--+            let average_score = *total_score / (*visits as f64);
--+            // 🧪 Reduce weight of rollout average
--+            let enhanced_eval =
--+                enhanced_position_evaluation(&temp_plateau, position, &chosen_tile, current_turn);
--+
--+            // Intégrer dans le calcul UCB
--+            let mut ucb_score = (average_score * 0.5)
--+                + exploration_param * (prior_prob.sqrt())
--+                + 0.25 * value_estimate.clamp(0.0, 2.0)
--+                + 0.1 * enhanced_eval; // Nouveau facteur d'évaluation
--+
--+            // 🔥 Explicit Priority Logic HERE 🔥
--+            // 1️⃣ Ajoute cette fonction en dehors de ta mcts_find_best_position_for_tile_with_nn
--+
--+            // 2️⃣ Intègre ceci dans ta boucle ucb_scores, juste après le boost fixe
--+
--+            if chosen_tile.0 == 9 && [7, 8, 9, 10, 11].contains(&position) {
--+                ucb_score += 10000.0; // double boost
--+            } else if chosen_tile.0 == 5 && [3, 4, 5, 6, 12, 13, 14, 15].contains(&position) {
--+                ucb_score += 8000.0;
--+            } else if chosen_tile.0 == 1 && [0, 1, 2, 16, 17, 18].contains(&position) {
--+                ucb_score += 6000.0;
--+            }
--+
--+            // 🔥 Alignment Priority Logic 🔥
--+
--+            ucb_scores.insert(position, ucb_score);
--+        }
--+    }
--+
--+    // Select the move with the highest UCB score
--+    let best_position = legal_moves
--+        .into_iter()
--+        .max_by(|&a, &b| {
--+            ucb_scores
--+                .get(&a)
--+                .unwrap_or(&f64::NEG_INFINITY)
--+                .partial_cmp(ucb_scores.get(&b).unwrap_or(&f64::NEG_INFINITY))
--+                .unwrap_or(std::cmp::Ordering::Equal)
--+        })
--+        .unwrap_or(0);
--+
--+    // **NEW: Simulate the Rest of the Game to Get Final Score**
--+    let mut final_plateau = plateau.clone();
--+    let mut final_deck = deck.clone();
--+    final_plateau.tiles[best_position] = chosen_tile;
--+    final_deck = replace_tile_in_deck(&final_deck, &chosen_tile);
--+
--+    while !is_plateau_full(&final_plateau) {
--+        let tile_index = random_index(final_deck.tiles.len());
--+        let random_tile = final_deck.tiles[tile_index];
--+
--+        let available_moves = get_legal_moves(final_plateau.clone());
--+        if available_moves.is_empty() {
--+            break;
--+        }
--+
--+        let random_position = available_moves[random_index(available_moves.len())];
--+        final_plateau.tiles[random_position] = random_tile;
--+        final_deck = replace_tile_in_deck(&final_deck, &random_tile);
--+    }
--+
--+    let final_score = result(&final_plateau); // Get actual game score
--+
--+    log::info!("🤖 Pos:{} Score:{}", best_position, final_score as i32);
--+
--+    MCTSResult {
--+        best_position,
--+        board_tensor,
--+        subscore: final_score as f64, // Store real final score, not UCB score
--+    }
--+}
--\ No newline at end of file
--diff --git a/src/mcts/mod.rs b/src/mcts/mod.rs
--index e69de29..9a9906a 100644
----- a/src/mcts/mod.rs
--+++ b/src/mcts/mod.rs
--@@ -0,0 +1,3 @@
--+pub mod mcts_node;
--+pub mod mcts_result;
--+pub mod algorithm;
--\ No newline at end of file
--diff --git a/src/mcts_vs_human.rs b/src/mcts_vs_human.rs
--index 95303c3..bec6730 100644
----- a/src/mcts_vs_human.rs
--+++ b/src/mcts_vs_human.rs
--@@ -1,19 +1,20 @@
---use crate::create_shuffle_deck::create_shuffle_deck;
---use crate::create_plateau_empty::create_plateau_empty;
---use crate::remove_tile_from_deck::replace_tile_in_deck;
--+use crate::game::create_deck::create_deck;
--+use crate::game::remove_tile_from_deck::replace_tile_in_deck;
-- use crate::generate_tile_image_names;
---use crate::result::result;
---use crate::test::{Deck, Plateau, Tile};
---use crate::{mcts_find_best_position_for_tile_with_nn, is_plateau_full};
--+use crate::{is_plateau_full};
-- 
-- use serde_json::json;
-- use tokio_tungstenite::tungstenite::protocol::Message;
-- use tokio_tungstenite::WebSocketStream;
-- use tokio::net::TcpStream;
---use futures_util::{StreamExt, SinkExt};
--+use futures_util::{SinkExt, StreamExt};
-- use futures_util::stream::SplitSink;
-- use rand::Rng;
---use crate::policy_value_net::{PolicyNet, ValueNet};
--+use crate::game::plateau::create_plateau_empty;
--+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
--+use crate::game::tile::Tile;
--+use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
--+use crate::scoring::scoring::result;
-- 
-- pub async fn play_mcts_vs_human(
--     policy_net: &PolicyNet,
--@@ -22,7 +23,7 @@ pub async fn play_mcts_vs_human(
--     write: &mut SplitSink<WebSocketStream<TcpStream>, Message>,
--     read: &mut (impl StreamExt<Item = Result<Message, tokio_tungstenite::tungstenite::Error>> + Unpin),
-- ) {
---    let mut deck = create_shuffle_deck();
--+    let mut deck = create_deck();
--     let mut plateau_human = create_plateau_empty();
--     let mut plateau_mcts = create_plateau_empty();
-- 
--diff --git a/src/mod.rs b/src/mod.rs
--index e69de29..909b9ab 100644
----- a/src/mod.rs
--+++ b/src/mod.rs
--@@ -0,0 +1,11 @@
--+pub mod game;
--+pub mod mcts;
--+
--+pub mod utils;
--+pub mod neural;
--+pub mod strategy;
--+pub mod scoring;
--+
--+pub mod data;
--+
--+pub mod training;
--\ No newline at end of file
--diff --git a/src/neural/mod.rs b/src/neural/mod.rs
--index e69de29..9082c6e 100644
----- a/src/neural/mod.rs
--+++ b/src/neural/mod.rs
--@@ -0,0 +1,4 @@
--+pub mod res_net_block;
--+pub mod policy_value_net;
--+pub mod tensor_conversion;
--+pub mod training;
--\ No newline at end of file
--diff --git a/src/neural/res_net_block.rs b/src/neural/res_net_block.rs
--index e9f3411..e40b131 100644
----- a/src/neural/res_net_block.rs
--+++ b/src/neural/res_net_block.rs
--@@ -1,6 +1,6 @@
-- use tch::{nn, Tensor};
-- 
---use crate::policy_value_net::initialize_weights;
--+use crate::neural::policy_value_net::initialize_weights;
-- 
-- /// Residual Block
-- pub struct ResNetBlock {
--diff --git a/src/neural/tensor_conversion.rs b/src/neural/tensor_conversion.rs
--index e69de29..95b6d19 100644
----- a/src/neural/tensor_conversion.rs
--+++ b/src/neural/tensor_conversion.rs
--@@ -0,0 +1,84 @@
--+use tch::Tensor;
--+use crate::game::deck::Deck;
--+use crate::game::plateau::Plateau;
--+use crate::game::tile::Tile;
--+
--+pub fn convert_plateau_to_tensor(
--+    plateau: &Plateau,
--+    _tile: &Tile, // Add underscore prefix
--+    _deck: &Deck, // Add underscore prefix
--+    current_turn: usize,
--+    total_turns: usize,
--+) -> Tensor {
--+    let mut features = vec![0.0; 5 * 47]; // 5 channels
--+
--+    // Channel 1-3: Plateau (only use plateau data, not tile/deck)
--+    for (i, t) in plateau.tiles.iter().enumerate() {
--+        if i < 19 {
--+            features[i] = (t.0 as f32 / 10.0).clamp(0.0, 1.0);
--+            features[47 + i] = (t.1 as f32 / 10.0).clamp(0.0, 1.0);
--+            features[2 * 47 + i] = (t.2 as f32 / 10.0).clamp(0.0, 1.0);
--+        }
--+    }
--+
--+    // Channel 4: Score Potential for each position
--+    let potential_scores = compute_potential_scores(plateau);
--+    for i in 0..19 {
--+        features[3 * 47 + i] = potential_scores[i];
--+    }
--+
--+    // Channel 5: Current Turn
--+    let turn_normalized = current_turn as f32 / total_turns as f32;
--+    for i in 0..19 {
--+        features[4 * 47 + i] = turn_normalized;
--+    }
--+
--+    Tensor::from_slice(&features).view([1, 5, 47, 1])
--+}
--+fn compute_potential_scores(plateau: &Plateau) -> Vec<f32> {
--+    let mut scores = vec![0.0; 19]; // Potential score for each position
--+
--+    let patterns: Vec<(&[usize], i32, Box<dyn Fn(&Tile) -> i32>)> = vec![
--+        (&[0, 1, 2], 3, Box::new(|tile: &Tile| tile.0)),
--+        (&[3, 4, 5, 6], 4, Box::new(|tile: &Tile| tile.0)),
--+        (&[7, 8, 9, 10, 11], 5, Box::new(|tile: &Tile| tile.0)),
--+        (&[12, 13, 14, 15], 4, Box::new(|tile: &Tile| tile.0)),
--+        (&[16, 17, 18], 3, Box::new(|tile: &Tile| tile.0)),
--+        (&[0, 3, 7], 3, Box::new(|tile: &Tile| tile.1)),
--+        (&[1, 4, 8, 12], 4, Box::new(|tile: &Tile| tile.1)),
--+        (&[2, 5, 9, 13, 16], 5, Box::new(|tile: &Tile| tile.1)),
--+        (&[6, 10, 14, 17], 4, Box::new(|tile: &Tile| tile.1)),
--+        (&[11, 15, 18], 3, Box::new(|tile: &Tile| tile.1)),
--+        (&[7, 12, 16], 3, Box::new(|tile: &Tile| tile.2)),
--+        (&[3, 8, 13, 17], 4, Box::new(|tile: &Tile| tile.2)),
--+        (&[0, 4, 9, 14, 18], 5, Box::new(|tile: &Tile| tile.2)),
--+        (&[1, 5, 10, 15], 4, Box::new(|tile: &Tile| tile.2)),
--+        (&[2, 6, 11], 3, Box::new(|tile: &Tile| tile.2)),
--+    ];
--+
--+    for (indices, multiplier, selector) in &patterns {
--+        let mut filled_values = Vec::new();
--+        let mut empty_positions = Vec::new();
--+
--+        for &pos in *indices {
--+            if plateau.tiles[pos] == Tile(0, 0, 0) {
--+                empty_positions.push(pos);
--+            } else {
--+                filled_values.push(selector(&plateau.tiles[pos]) as f32);
--+            }
--+        }
--+
--+        // If at least one tile is placed in the pattern
--+        if !filled_values.is_empty() {
--+            let avg_filled_value = filled_values.iter().sum::<f32>() / filled_values.len() as f32;
--+            let potential_score = avg_filled_value * (*multiplier as f32);
--+
--+            for &pos in empty_positions.iter() {
--+                scores[pos] += potential_score / empty_positions.len() as f32; // Distribute potential score
--+            }
--+        }
--+    }
--+
--+    scores
--+}
--+
--diff --git a/src/neural/training/gradient_clipping.rs b/src/neural/training/gradient_clipping.rs
--index e69de29..18052aa 100644
----- a/src/neural/training/gradient_clipping.rs
--+++ b/src/neural/training/gradient_clipping.rs
--@@ -0,0 +1,95 @@
--+//! Gestion des gradients et clipping pour stabiliser l'entraînement
--+
--+use tch::nn;
--+
--+/// Résultat du clipping des gradients
--+#[derive(Debug)]
--+pub struct GradientClippingResult {
--+    pub max_grad_value: f64,
--+    pub max_grad_policy: f64,
--+}
--+
--+/// Applique un clipping amélioré des gradients pour les réseaux value et policy
--+pub fn enhanced_gradient_clipping(
--+    vs_value: &nn::VarStore,
--+    vs_policy: &nn::VarStore,
--+) -> GradientClippingResult {
--+    let max_grad_value = clip_value_network_gradients(vs_value);
--+    let max_grad_policy = clip_policy_network_gradients(vs_policy);
--+
--+    log_gradient_norms(max_grad_value, max_grad_policy);
--+
--+    GradientClippingResult {
--+        max_grad_value,
--+        max_grad_policy,
--+    }
--+}
--+
--+/// Applique un clipping agressif pour le réseau de valeur
--+fn clip_value_network_gradients(vs_value: &nn::VarStore) -> f64 {
--+    let mut max_grad_value: f64 = 0.0;
--+
--+    tch::no_grad(|| {
--+        for (_name, tensor) in vs_value.variables() {
--+            if tensor.grad().defined() {
--+                let grad_norm = tensor.grad().norm().double_value(&[]);
--+                max_grad_value = max_grad_value.max(grad_norm);
--+
--+                // Clipping très agressif pour stabilité
--+                tensor.grad().clamp_(-0.5, 0.5);
--+            }
--+        }
--+    });
--+
--+    max_grad_value
--+}
--+
--+/// Applique un clipping modéré pour le réseau de policy
--+fn clip_policy_network_gradients(vs_policy: &nn::VarStore) -> f64 {
--+    let mut max_grad_policy: f64 = 0.0;
--+
--+    tch::no_grad(|| {
--+        for (_name, tensor) in vs_policy.variables() {
--+            if tensor.grad().defined() {
--+                let grad_norm = tensor.grad().norm().double_value(&[]);
--+                max_grad_policy = max_grad_policy.max(grad_norm);
--+
--+                // Clipping modéré
--+                tensor.grad().clamp_(-1.0, 1.0);
--+            }
--+        }
--+    });
--+
--+    max_grad_policy
--+}
--+
--+/// Log les normes de gradients si elles sont élevées
--+fn log_gradient_norms(max_grad_value: f64, max_grad_policy: f64) {
--+    if max_grad_value > 1.0 {
--+        log::warn!("🔥 Value grad norm: {:.3}", max_grad_value);
--+    }
--+    if max_grad_policy > 2.0 {
--+        log::warn!("🔥 Policy grad norm: {:.3}", max_grad_policy);
--+    }
--+}
--+
--+/// Version simple du clipping des gradients
--+pub fn simple_gradient_clipping(
--+    vs: &nn::VarStore,
--+    max_norm: f64,
--+) -> f64 {
--+    let mut max_grad: f64 = 0.0;
--+
--+    tch::no_grad(|| {
--+        for (_name, tensor) in vs.variables() {
--+            if tensor.grad().defined() {
--+                let grad_norm = tensor.grad().norm().double_value(&[]);
--+                max_grad = max_grad.max(grad_norm);
--+
--+                tensor.grad().clamp_(-max_norm, max_norm);
--+            }
--+        }
--+    });
--+
--+    max_grad
--+}
--\ No newline at end of file
--diff --git a/src/neural/training/mod.rs b/src/neural/training/mod.rs
--index e69de29..471498a 100644
----- a/src/neural/training/mod.rs
--+++ b/src/neural/training/mod.rs
--@@ -0,0 +1,5 @@
--+//! Module d'entraînement - Optimisation et stabilisation
--+
--+pub mod gradient_clipping;
--+pub mod normalization;
--+pub mod trainer;
--diff --git a/src/neural/training/normalization.rs b/src/neural/training/normalization.rs
--index e69de29..c2a44c6 100644
----- a/src/neural/training/normalization.rs
--+++ b/src/neural/training/normalization.rs
--@@ -0,0 +1,66 @@
--+//! Normalisation robuste des données pour l'entraînement
--+
--+use tch::{Tensor, IndexOp};
--+
--+/// Applique une normalisation robuste basée sur la médiane (MAD)
--+pub fn robust_state_normalization(state: &Tensor) -> Tensor {
--+    let clamped = clamp_extreme_values(state);
--+    let median = calculate_median(&clamped);
--+    let mad = calculate_mad(&clamped, median);
--+
--+    normalize_with_mad(&clamped, median, mad)
--+}
--+
--+/// Clamp les valeurs extrêmes pour éviter les outliers
--+fn clamp_extreme_values(state: &Tensor) -> Tensor {
--+    state.clamp(-10.0, 10.0)
--+}
--+
--+/// Calcule la médiane d'un tensor
--+fn calculate_median(tensor: &Tensor) -> f64 {
--+    let flattened = tensor.view(-1);
--+    let sorted = flattened.sort(0, false).0;
--+    let median_idx = sorted.size()[0] / 2;
--+    sorted.i(median_idx).double_value(&[])
--+}
--+
--+/// Calcule la Median Absolute Deviation (MAD)
--+fn calculate_mad(tensor: &Tensor, median: f64) -> f64 {
--+    let flattened = tensor.view(-1);
--+    let deviations = (flattened - median).abs();
--+    let sorted_dev = deviations.sort(0, false).0;
--+    let median_idx = sorted_dev.size()[0] / 2;
--+    sorted_dev.i(median_idx).double_value(&[]) * 1.4826
--+}
--+
--+/// Normalise avec MAD au lieu de l'écart-type standard
--+fn normalize_with_mad(tensor: &Tensor, median: f64, mad: f64) -> Tensor {
--+    let normalized = if mad > 1e-6 {
--+        (tensor - median) / mad.max(1e-6)
--+    } else {
--+        tensor - median
--+    };
--+
--+    // Clamp final pour éviter les valeurs extrêmes
--+    normalized.clamp(-3.0, 3.0)
--+}
--+
--+/// Version simple de normalisation z-score
--+pub fn simple_normalization(tensor: &Tensor) -> Tensor {
--+    let mean = tensor.mean(tch::Kind::Float);
--+    let std = tensor.std(false).clamp_min(1e-8);
--+    (tensor - mean) / std
--+}
--+
--+/// Normalisation min-max
--+pub fn min_max_normalization(tensor: &Tensor) -> Tensor {
--+    let min_val = tensor.min();
--+    let max_val = tensor.max();
--+    let range = max_val - &min_val;
--+
--+    if range.double_value(&[]) > 1e-8 {
--+        (tensor - min_val) / range
--+    } else {
--+        tensor.shallow_clone()
--+    }
--+}
--\ No newline at end of file
--diff --git a/src/neural/training/trainer.rs b/src/neural/training/trainer.rs
--index e69de29..95a6d39 100644
----- a/src/neural/training/trainer.rs
--+++ b/src/neural/training/trainer.rs
--@@ -0,0 +1,146 @@
--+use tch::{nn, IndexOp, Tensor};
--+use tch::nn::Optimizer;
--+use crate::mcts::mcts_result::MCTSResult;
--+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
--+use crate::neural::training::gradient_clipping::enhanced_gradient_clipping;
--+use crate::neural::training::normalization::robust_state_normalization;
--+
--+pub fn train_network_with_game_data(
--+    vs_policy: &nn::VarStore,
--+    vs_value: &nn::VarStore,
--+    game_data: &[MCTSResult],
--+    discount_factor: f64,
--+    policy_net: &PolicyNet,
--+    value_net: &ValueNet,
--+    optimizer_policy: &mut Optimizer,
--+    optimizer_value: &mut Optimizer,
--+) {
--+    // Hyperparameters
--+    let entropy_weight = 0.05;
--+    let gamma = 0.99;
--+    let epsilon = 1e-8;
--+
--+    // Initialize accumulators
--+    let mut predictions = Vec::new();
--+    let mut targets = Vec::new();
--+    let mut total_policy_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
--+    let mut total_value_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
--+    let mut total_entropy_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
--+
--+    // Initialize trajectory rewards and discounted sum
--+    let mut trajectory_rewards = Vec::new();
--+    let mut discounted_sum = Tensor::zeros(&[], (tch::Kind::Float, tch::Device::Cpu));
--+
--+    // === Training Loop ===
--+    for (step, result) in game_data.iter().rev().enumerate() {
--+        // 🛑 No Normalization: Use raw tensor
--+        let state = result.board_tensor.shallow_clone();
--+        let normalized_state = robust_state_normalization(&state);
--+
--+        // Forward pass through networks with normalized state
--+        let pred_policy = policy_net.forward(&normalized_state, true).clamp_min(1e-7);
--+        let pred_value = value_net.forward(&normalized_state, true);
--+
--+        // Forward pass through networks with normalized state
--+        // Normalize reward: divide by a constant max value (e.g., 100)
--+        let reward = Tensor::from(result.subscore).to_kind(tch::Kind::Float) / 100.0;
--+        let gamma_tensor = Tensor::from_slice(&[gamma]).to_kind(tch::Kind::Float);
--+
--+        // ✅ NaN & Inf Check for reward
--+        if reward.isnan().any().double_value(&[]) > 0.0
--+            || reward.isinf().any().double_value(&[]) > 0.0
--+        {
--+            log::error!("⚠️ NaN or Inf detected in reward at step {}", step);
--+            continue;
--+        }
--+
--+        // Update discounted sum with normalized reward
--+        discounted_sum = reward + gamma_tensor * discounted_sum;
--+
--+        // ✅ NaN & Inf Check for discounted sum
--+        if discounted_sum.isnan().any().double_value(&[]) > 0.0
--+            || discounted_sum.isinf().any().double_value(&[]) > 0.0
--+        {
--+            log::error!("⚠️ NaN or Inf detected in discounted sum at step {}", step);
--+            continue;
--+        }
--+
--+        // Store the value for analysis
--+        trajectory_rewards.push(discounted_sum.double_value(&[]));
--+
--+        // Generate target tensor directly from discounted sum
--+        let discounted_reward = discounted_sum.shallow_clone();
--+
--+        // Append for later analysis
--+        predictions.push(pred_value.double_value(&[]));
--+        targets.push(discounted_reward.double_value(&[]));
--+
--+        // === Compute Losses ===
--+        // Policy loss
--+        let best_position = result.best_position as i64;
--+        let target_policy = Tensor::zeros(&[1, pred_policy.size()[1]], tch::kind::FLOAT_CPU);
--+        target_policy.i((0, best_position)).fill_(1.0);
--+        let log_policy = pred_policy.log();
--+        let policy_loss = -(target_policy * log_policy.shallow_clone()).sum(tch::Kind::Float);
--+        total_policy_loss += policy_loss;
--+
--+        // Entropy loss
--+        let entropy_loss = -(pred_policy * (log_policy + epsilon)).sum(tch::Kind::Float);
--+        total_entropy_loss += entropy_loss;
--+
--+        // Value loss (Huber loss for better stability)
--+        let diff = discounted_reward.shallow_clone() - pred_value.shallow_clone();
--+        let abs_diff = diff.abs();
--+        let delta = 1.0;
--+        let value_loss = abs_diff.le(delta).to_kind(tch::Kind::Float) * 0.5 * &diff * &diff
--+            + abs_diff.gt(delta).to_kind(tch::Kind::Float) * (delta * (&abs_diff - 0.5 * delta));
--+        total_value_loss += value_loss.mean(tch::Kind::Float);
--+    }
--+
--+    // Fix: Add explicit type annotation for total_loss
--+    let total_loss: Tensor = total_policy_loss.shallow_clone()
--+        + total_value_loss.shallow_clone()
--+        + (entropy_weight * total_entropy_loss.shallow_clone());
--+
--+    // Log the loss before backpropagation
--+    log::info!(
--+        "💡 Total Loss before backward: {:.4}",
--+        total_loss.double_value(&[])
--+    );
--+
--+    // ✅ Enhanced NaN and Inf check before backpropagation
--+    if total_loss.isnan().any().double_value(&[]) > 0.0 {
--+        log::error!("⚠️ NaN detected in total loss! Skipping backpropagation.");
--+        return;
--+    }
--+    if total_loss.isinf().any().double_value(&[]) > 0.0 {
--+        log::error!("⚠️ Inf detected in total loss! Skipping backpropagation.");
--+        return;
--+    }
--+
--+    // Check if total_loss requires gradients before calling backward
--+    if !total_loss.requires_grad() {
--+        log::error!("⚠️ Total loss does not require gradients! Skipping backpropagation.");
--+        return;
--+    }
--+
--+    total_loss.backward();
--+
--+    // Utilisez :
--+    let gradient_result = enhanced_gradient_clipping(vs_value, vs_policy);
--+    let _max_grad_value = gradient_result.max_grad_value;
--+    let _max_grad_policy = gradient_result.max_grad_policy;
--+
--+    // === Optimizer Step ===
--+    optimizer_policy.step();
--+    optimizer_policy.zero_grad();
--+    optimizer_value.step();
--+    optimizer_value.zero_grad();
--+
--+    log::info!(
--+        "🎯 Update Complete | Policy Loss: {:.4}, Value Loss: {:.4}, Entropy Loss: {:.4}",
--+        total_policy_loss.double_value(&[]),
--+        total_value_loss.double_value(&[]),
--+        total_entropy_loss.double_value(&[])
--+    );
--+}
--\ No newline at end of file
--diff --git a/src/scoring/mod.rs b/src/scoring/mod.rs
--index 4c07743..80d0f3d 100644
----- a/src/scoring/mod.rs
--+++ b/src/scoring/mod.rs
--@@ -1,2 +1 @@
-- pub mod scoring;
---pub mod results;
--diff --git a/src/strategy/mod.rs b/src/strategy/mod.rs
--index e69de29..e775ccb 100644
----- a/src/strategy/mod.rs
--+++ b/src/strategy/mod.rs
--@@ -0,0 +1 @@
--+pub mod position_evaluation;
--\ No newline at end of file
--diff --git a/src/strategy/position_evaluation.rs b/src/strategy/position_evaluation.rs
--index e69de29..69e2403 100644
----- a/src/strategy/position_evaluation.rs
--+++ b/src/strategy/position_evaluation.rs
--@@ -0,0 +1,84 @@
--+use crate::game::plateau::Plateau;
--+use crate::game::tile::Tile;
--+use crate::scoring::scoring::compute_alignment_score;
--+
--+// Version simplifiée qui se concentre sur les positions stratégiques
--+pub fn calculate_line_completion_bonus(plateau: &Plateau, position: usize, tile: &Tile) -> f64 {
--+    let mut bonus = 0.0;
--+
--+    // Bonus basé sur les positions stratégiques identifiées dans tes données
--+    bonus += match position {
--+        8 => 5.0,                 // Position 8: 150.6 moyenne - excellente
--+        14 => 4.0,                // Position 14: 147.7 moyenne - très bonne
--+        2 => 4.0,                 // Position 2: 147.1 moyenne - très bonne
--+        5 => 3.0,                 // Position 5: 143.6 moyenne - bonne
--+        11 => 3.0,                // Position 11: 142.9 moyenne - bonne
--+        10 => 2.0,                // Position 10: 140.8 moyenne - correcte
--+        13 => 2.0,                // Position 13: 140.2 moyenne - correcte
--+        1 | 4 | 6 | 9 | 0 => 1.0, // Positions moyennes
--+        12 | 15 | 16 => 0.5,      // Positions plus faibles
--+        7 | 17 => 0.0,            // Positions les plus faibles
--+        _ => 0.0,
--+    };
--+
--+    // Bonus pour les valeurs de tuiles élevées (plus de points potentiels)
--+    let tile_value_bonus = ((tile.0 + tile.1) as f64) * 0.1;
--+    bonus += tile_value_bonus;
--+
--+    // Bonus pour la cohérence des couleurs/formes
--+    if tile.0 == tile.1 {
--+        bonus += 1.0; // Tuiles avec même couleur et forme
--+    }
--+
--+    // Bonus central légèrement plus complexe
--+    let row = position / 3;
--+    let col = position % 3;
--+    if row >= 1 && row <= 4 && col >= 1 && col <= 1 {
--+        bonus += 2.0; // Zone centrale du plateau
--+    }
--+
--+    bonus
--+}
--+
--+// ============================================================================
--+// ALTERNATIVE PLUS SIMPLE (Si la version ci-dessus pose encore problème)
--+// ============================================================================
--+
--+// Si vous préférez une version plus simple, utilisez celle-ci:
--+
--+pub fn enhanced_position_evaluation(
--+    plateau: &Plateau,
--+    position: usize,
--+    tile: &Tile,
--+    current_turn: usize,
--+) -> f64 {
--+    // Score de base alignement (votre fonction existante)
--+    let alignment_score = compute_alignment_score(plateau, position, tile);
--+
--+    // Bonus pour positions centrales stratégiques en début de partie
--+    let position_bonus = if current_turn < 8 {
--+        match position {
--+            7 | 8 | 9 | 10 | 11 => 5.0,           // Ligne centrale - critique
--+            4 | 5 | 6 | 12 | 13 | 14 | 15 => 3.0, // Positions stratégiques
--+            _ => 0.0,
--+        }
--+    } else {
--+        0.0 // En fin de partie, seul l'alignement compte
--+    };
--+
--+    // Malus pour positions coins/bords si début de partie
--+    let position_malus = if current_turn < 5 {
--+        match position {
--+            0 | 2 | 16 | 18 => -2.0, // Coins - à éviter en début
--+            1 | 17 => -1.0,          // Bords
--+            _ => 0.0,
--+        }
--+    } else {
--+        0.0
--+    };
--+
--+    // Bonus pour complétion de lignes
--+    let completion_bonus = calculate_line_completion_bonus(plateau, position, tile);
--+
--+    alignment_score + position_bonus + position_malus + completion_bonus
--+}
--diff --git a/src/test.rs b/src/test.rs
--index 2bb8cd8..896f3e0 100644
----- a/src/test.rs
--+++ b/src/test.rs
--@@ -1,31 +1,5 @@
---
---#[derive(Debug, Clone, PartialEq)]
---pub struct MCTSNode {
---    pub state: GameState,             // Current game state
---    pub visits: usize,                // Number of visits
---    pub value: f64,                   // Total value of the node
---    pub children: Vec<MCTSNode>,      // Child nodes
---    pub parent: Option<*mut MCTSNode>, // Pointer to the parent node (raw pointer to allow mutation)
---}
---
---
---#[derive(Debug, Clone, PartialEq, Copy,Hash,Eq)]
---pub(crate) struct Tile(pub i32, pub i32, pub i32);
---#[derive(Debug, Clone, PartialEq)]
---pub(crate) struct Plateau{
---    pub(crate) tiles: Vec<Tile>,
---}
---
---#[derive(Debug, Clone, PartialEq)]
---pub struct GameState {
---    pub plateau: Plateau,
---    pub deck: Deck,
---}
---
---#[derive(Debug, Clone, PartialEq)]
---pub struct Deck{
---    pub(crate) tiles: Vec<Tile>,
---}
--+use crate::game::plateau::Plateau;
--+use crate::game::tile::Tile;
-- 
-- #[cfg(test)]
-- pub(crate) mod tests {
--@@ -75,7 +49,7 @@ pub(crate) mod tests {
-- 
--     pub fn create_game_state() -> GameState {
--         let plateau = create_plateau_empty();
---        let deck = create_shuffle_deck();
--+        let deck = create_deck();
--         GameState { plateau, deck }
--     }
-- 
--@@ -155,21 +129,25 @@ pub(crate) mod tests {
--             (*current).value += score;
--         }
--     }
---    use crate::remove_tile_from_deck::remove_tile_from_deck;
--+    use crate::game::remove_tile_from_deck::remove_tile_from_deck;
-- use super::*;
-- 
-- 
--     use rand::Rng;
---    use crate::create_plateau_empty::create_plateau_empty;
---    use crate::create_shuffle_deck::create_shuffle_deck;
--+    use crate::game::create_deck::create_deck;
--     use crate::{convert_plateau_to_tensor, get_legal_moves, is_plateau_full, simulate_games};
---    use crate::result::result;
---    use crate::test::{  Deck, GameState,  MCTSNode, Plateau, Tile};
--+    use crate::game::deck::Deck;
--+    use crate::game::game_state::GameState;
--+    use crate::mcts::mcts_node::MCTSNode;
--+    use crate::game::plateau::{create_plateau_empty, Plateau};
--+    use crate::game::tile::Tile;
--+    use crate::scoring::scoring::result;
--+
--     #[test]
--     fn test_placement_tuile_valide_take_it_easy() {
--         let mut plateau:Plateau=create_plateau_empty();
---        let deckSfuffle:Deck= create_shuffle_deck();
---        let tuile = deckSfuffle.tiles[5].clone();
--+        let shuffled_deck:Deck= create_deck();
--+        let tuile = shuffled_deck.tiles[5].clone();
--         assert!(placer_tile(&mut plateau, tuile.clone(), 1));
--         assert_eq!(plateau.tiles[1], tuile);
--     }
--@@ -203,7 +181,7 @@ use super::*;
--     #[test]
--     fn test_simulate_games() {
--         let plateau = create_plateau_empty();
---        let deck = create_shuffle_deck();
--+        let deck = create_deck();
--         let num_simulations = 10;
-- 
--         let avg_score = simulate_games(plateau, deck);
--@@ -213,7 +191,7 @@ use super::*;
--     fn test_convert_plateau_to_tensor() {
--         let plateau = create_plateau_empty();
--         let tile = Tile(1, 2, 3);
---        let deck = create_shuffle_deck();
--+        let deck = create_deck();
-- 
--         let tensor = convert_plateau_to_tensor(&plateau, &tile, &deck, /* usize */0, 19/* usize */);
--         assert_eq!(tensor.size(), vec![1, 3, 5, 5]); // Ensure the tensor has the correct shape
--@@ -224,7 +202,7 @@ use super::*;
--     #[test]
--     fn test_placement_tuile_not_valide_take_it_easy() {
--         let mut plateau:Plateau=create_plateau_empty();
---        let deckSfuffle:Deck= create_shuffle_deck();
--+        let deckSfuffle:Deck= create_deck();
--         let tile = deckSfuffle.tiles[5].clone();
--         assert!(placer_tile(&mut plateau, tile.clone(), 1));
--         assert_eq!(plateau.tiles[1], tile);
--@@ -234,7 +212,7 @@ use super::*;
--     #[test]
--     fn test_choir_aleatorytile() {
--         // Crée un deck
---        let deck_shuffle: Deck = create_shuffle_deck();
--+        let deck_shuffle: Deck = create_deck();
-- 
--         // Génère un index aléatoire
--         let mut rng = rand::thread_rng();
--@@ -258,7 +236,7 @@ use super::*;
--         use rand::Rng; // Pour générer un indice aléatoire
-- 
--         // Crée un deck initial
---        let deck_shuffle: Deck = create_shuffle_deck();
--+        let deck_shuffle: Deck = create_deck();
-- 
--         // Génère un indice aléatoire
--         let mut rng = rand::thread_rng();
--@@ -282,7 +260,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
-- 
--         // Remplir le plateau
--@@ -300,7 +278,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_first_3_plateau_3_1() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
--         placer_tile(&mut plateau, deck.tiles[1].clone(), 1);
--@@ -310,7 +288,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_first_3_plateau_3_2() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[9].clone(), 0);
--         placer_tile(&mut plateau, deck.tiles[10].clone(), 1);
--@@ -320,7 +298,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_2_column_plateau_4_2() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[9].clone(), 3);
--         placer_tile(&mut plateau, deck.tiles[10].clone(), 4);
--@@ -334,7 +312,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_column_center_plateau_5_2() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[9].clone(), 7);
--         placer_tile(&mut plateau, deck.tiles[10].clone(), 8);
--@@ -349,7 +327,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_column_4_plateau_4_2() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[9].clone(), 12);
--         placer_tile(&mut plateau, deck.tiles[10].clone(), 13);
--@@ -363,7 +341,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_last_column_3_plateau_3_1() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 16);
--         placer_tile(&mut plateau, deck.tiles[1].clone(),17);
--@@ -373,7 +351,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_first_diag_plateau_0_3_7() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
--         placer_tile(&mut plateau, deck.tiles[4].clone(),3);
--@@ -383,7 +361,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_second_diag_plateau_1_4_8_12() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 1);
--         placer_tile(&mut plateau, deck.tiles[4].clone(),4);
--@@ -394,7 +372,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_third_diag_plateau_2_5_9_13_16() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 2);
--         placer_tile(&mut plateau, deck.tiles[4].clone(),5);
--@@ -406,7 +384,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_fourth_diag_plateau_6_10_14_17() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 6);
--         placer_tile(&mut plateau, deck.tiles[4].clone(),10);
--@@ -418,7 +396,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_last_diag_plateau_11_15_18() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 11);
--         placer_tile(&mut plateau, deck.tiles[4].clone(),15);
--@@ -430,7 +408,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_firdt_diag_left_plateau_7_12_16() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 7);
--         placer_tile(&mut plateau, deck.tiles[2].clone(),12);
--@@ -442,7 +420,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_second_diag_left_plateau_3_8_13_17() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 3);
--         placer_tile(&mut plateau, deck.tiles[2].clone(),8);
--@@ -455,7 +433,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_third_diag_left_plateau_0_4_9_14_18() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
--         placer_tile(&mut plateau, deck.tiles[2].clone(),4);
--@@ -470,7 +448,7 @@ use super::*;
-- 
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_fourth_diag_left_plateau_1_5_10_15() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 1);
--         placer_tile(&mut plateau, deck.tiles[2].clone(),5);
--@@ -483,7 +461,7 @@ use super::*;
--     }
--     #[test]
--     fn test_remplir_plateau_take_it_easy_count_last_diag_left_plateau_2_6_11() {
---        let mut deck = create_shuffle_deck();
--+        let mut deck = create_deck();
--         let mut plateau = create_plateau_empty();
--         placer_tile(&mut plateau, deck.tiles[0].clone(), 2);
--         placer_tile(&mut plateau, deck.tiles[2].clone(),6);
--diff --git a/src/training/evaluator.rs b/src/training/evaluator.rs
--index e69de29..052208b 100644
----- a/src/training/evaluator.rs
--+++ b/src/training/evaluator.rs
--@@ -0,0 +1,45 @@
--+use rand::{rng, Rng};
--+use crate::game::create_deck::create_deck;
--+use crate::game::plateau::create_plateau_empty;
--+use crate::game::plateau_is_full::is_plateau_full;
--+use crate::game::remove_tile_from_deck::replace_tile_in_deck;
--+use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
--+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
--+use crate::scoring::scoring::result;
--+
--+pub async fn evaluate_model(policy_net: &PolicyNet, value_net: &ValueNet, num_simulations: usize) {
--+    log::info!("Evaluating model...");
--+    let mut scores = Vec::new();
--+
--+    for _ in 0..10 {
--+        let mut deck = create_deck();
--+        let mut plateau = create_plateau_empty();
--+        let total_turns = 19; // The number of moves in the game
--+        let mut current_turn = 0;
--+        while !is_plateau_full(&plateau) {
--+            let tile_index = rng().random_range(0..deck.tiles.len());
--+            let chosen_tile = deck.tiles[tile_index];
--+            let game_result = mcts_find_best_position_for_tile_with_nn(
--+                &mut plateau,
--+                &mut deck,
--+                chosen_tile,
--+                policy_net,
--+                value_net,
--+                num_simulations,
--+                current_turn,
--+                total_turns,
--+            );
--+            let best_position = game_result.best_position;
--+            plateau.tiles[best_position] = chosen_tile;
--+            deck = replace_tile_in_deck(&deck, &chosen_tile);
--+            current_turn += 1; // Increment turn counter each time a tile is placed
--+        }
--+
--+        let game_score = result(&plateau);
--+        scores.push(game_score);
--+    }
--+
--+    let avg_score: f64 = scores.iter().copied().sum::<i32>() as f64 / scores.len() as f64;
--+    log::info!("Model Evaluation Complete. Avg Score: {:.2}", avg_score);
--+    // **Stop ping task**
--+}
--\ No newline at end of file
--diff --git a/src/training/mod.rs b/src/training/mod.rs
--index e69de29..0fe0e0c 100644
----- a/src/training/mod.rs
--+++ b/src/training/mod.rs
--@@ -0,0 +1,3 @@
--+pub mod websocket;
--+pub mod evaluator;
--+pub mod session;
--diff --git a/src/training/session.rs b/src/training/session.rs
--index e69de29..7b0fbaf 100644
----- a/src/training/session.rs
--+++ b/src/training/session.rs
--@@ -0,0 +1,276 @@
--+use crate::data::append_result::append_to_results_file;
--+use crate::data::load_data::load_game_data;
--+use crate::data::save_data::save_game_data;
--+use crate::game::create_deck::create_deck;
--+use crate::game::plateau::create_plateau_empty;
--+use crate::game::plateau_is_full::is_plateau_full;
--+use crate::game::remove_tile_from_deck::replace_tile_in_deck;
--+use crate::game::tile::Tile;
--+use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
--+use crate::mcts::mcts_result::MCTSResult;
--+use crate::mcts_vs_human::play_mcts_vs_human;
--+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
--+use crate::neural::training::trainer::train_network_with_game_data;
--+use crate::scoring::scoring::result;
--+use crate::training::evaluator::evaluate_model;
--+use crate::training::websocket::reconnect_websocket;
--+use crate::utils::image::generate_tile_image_names;
--+use crate::Config;
--+use futures_util::{SinkExt, StreamExt};
--+use rand::{rng, Rng};
--+use std::collections::HashMap;
--+use std::sync::Arc;
--+use tch::nn;
--+use tch::nn::Optimizer;
--+use tokio::net::TcpListener;
--+use tokio_tungstenite::accept_async;
--+use tokio_tungstenite::tungstenite::Message;
--+/// Lance une session MCTS vs Humain
--+
--+pub async fn train_and_evaluate(
--+    vs_policy: &nn::VarStore,
--+    vs_value: &nn::VarStore,
--+    policy_net: &mut PolicyNet,
--+    value_net: &mut ValueNet,
--+    optimizer_policy: &mut Optimizer,
--+    optimizer_value: &mut Optimizer,
--+    num_games: usize,
--+    num_simulations: usize,
--+    evaluation_interval: usize,
--+    listener: Arc<TcpListener>,
--+) {
--+    let mut total_score = 0;
--+    let mut games_played = 0;
--+    let results_file = "results.csv";
--+
--+    while let Ok((stream, _)) = listener.accept().await {
--+        let ws_stream = accept_async(stream)
--+            .await
--+            .expect("Failed to accept WebSocket");
--+        let (mut write, _) = ws_stream.split();
--+        let mut scores_by_position: HashMap<usize, Vec<i32>> = HashMap::new();
--+        let mut scores = Vec::new(); // Stocke les scores
--+        let evaluation_interval_average = 10;
--+
--+        while games_played < num_games {
--+            log::info!(
--+                "Starting training iteration {}/{}...",
--+                games_played + 1,
--+                num_games
--+            );
--+            log::info!(
--+                "\n🚀 Starting Batch {}",
--+                games_played / evaluation_interval + 1
--+            );
--+
--+            let mut batch_games_played = 0; // Tracks games processed in this evaluation interval
--+
--+            let max_memory_size = 1000; // Store last 500 games
--+
--+            for game in 0..evaluation_interval {
--+                let mut deck = create_deck();
--+                let mut plateau = create_plateau_empty();
--+                let mut game_data = Vec::new();
--+                let mut first_move: Option<(usize, Tile)> = None;
--+                let total_turns = 19; // The number of moves in the game
--+                let mut current_turn = 0;
--+                while !is_plateau_full(&plateau) {
--+                    let tile_index = rng().random_range(0..deck.tiles.len());
--+                    let chosen_tile = deck.tiles[tile_index];
--+                    // ✅ **Send preview before placement**
--+                    // ✅ **INSERT YOUR NEW CODE HERE**
--+                    let chosen_tile_image = format!(
--+                        "../image/{}{}{}.png",
--+                        chosen_tile.0, chosen_tile.1, chosen_tile.2
--+                    );
--+                    let payload = serde_json::json!({
--+                        "next_tile": chosen_tile_image,
--+                        "plateau_tiles": generate_tile_image_names(&plateau.tiles)
--+                    });
--+                    let serialized = serde_json::to_string(&payload).unwrap();
--+                    write.send(Message::Text(serialized)).await.unwrap();
--+
--+                    let game_result = mcts_find_best_position_for_tile_with_nn(
--+                        &mut plateau,
--+                        &mut deck,
--+                        chosen_tile,
--+                        policy_net,
--+                        value_net,
--+                        num_simulations,
--+                        current_turn,
--+                        total_turns,
--+                    );
--+
--+                    let best_position = game_result.best_position;
--+                    if first_move.is_none() {
--+                        first_move = Some((best_position, chosen_tile));
--+                    }
--+                    plateau.tiles[best_position] = chosen_tile;
--+                    deck = replace_tile_in_deck(&deck, &chosen_tile);
--+                    // ✅ INSERT THIS TO SEND SCORE TO CLIENT
--+                    let current_score = result(&plateau);
--+                    let score_payload = serde_json::json!({
--+                        "type": "score_update",
--+                        "current_score": current_score,
--+                    });
--+                    let serialized_score = serde_json::to_string(&score_payload).unwrap();
--+                    if let Err(e) = write.send(Message::Text(serialized_score)).await {
--+                        log::error!("WebSocket error when sending score: {:?}", e);
--+                        if let Some(new_write) = reconnect_websocket(&listener).await {
--+                            write = new_write;
--+                        } else {
--+                            log::error!("Failed to reconnect WebSocket. Exiting...");
--+                            break;
--+                        }
--+                    }
--+
--+                    game_data.push(game_result); // Store training data
--+
--+                    // ✅ **INSERT YOUR NEW CODE HERE**
--+                    let payload_after_placement = serde_json::json!({
--+                        "next_tile": null, // Clear preview
--+                        "plateau_tiles": generate_tile_image_names(&plateau.tiles) // new updated state
--+                    });
--+                    let serialized = serde_json::to_string(&payload_after_placement).unwrap();
--+
--+                    // ✅ Handle WebSocket disconnections
--+                    if let Err(e) = write.send(Message::Text(serialized.clone())).await {
--+                        log::error!("WebSocket error: {:?}. Attempting to reconnect...", e);
--+
--+                        // **Reconnect WebSocket**
--+                        if let Some(new_write) = reconnect_websocket(&listener).await {
--+                            write = new_write;
--+                        } else {
--+                            log::error!("Failed to reconnect WebSocket. Exiting...");
--+                            break;
--+                        }
--+                    }
--+                    current_turn += 1; // Increment turn counter each time a tile is placed
--+                }
--+
--+                let final_score = result(&plateau);
--+
--+                if let Some((position, _)) = first_move {
--+                    scores_by_position
--+                        .entry(position)
--+                        .or_insert_with(Vec::new)
--+                        .push(final_score);
--+                }
--+
--+                let mut batch_game_data = Vec::new();
--+
--+                // Prioritized historical data
--+                let prioritized_data: Vec<MCTSResult> = load_game_data("game_data")
--+                    .into_iter()
--+                    .filter(|r| r.subscore > 100.0) // Only select high-score games
--+                    .take(50) // Limit to 50 samples to prevent overfitting
--+                    .collect();
--+
--+                // Add historical data to batch
--+                batch_game_data.extend(prioritized_data);
--+
--+                // Add current game's data to batch
--+                batch_game_data.extend(game_data.iter().map(|result| MCTSResult {
--+                    best_position: result.best_position,
--+                    board_tensor: result.board_tensor.shallow_clone(),
--+                    subscore: result.subscore,
--+                }));
--+
--+                // Keep only last max_memory_size experiences
--+                if batch_game_data.len() > max_memory_size {
--+                    let to_remove = batch_game_data.len() - max_memory_size;
--+                    batch_game_data.drain(0..to_remove); // Remove oldest data
--+                }
--+
--+                // Train in batches
--+                let batch_size = 10;
--+                for batch in batch_game_data.chunks(batch_size) {
--+                    train_network_with_game_data(
--+                        &vs_policy,
--+                        &vs_value,
--+                        batch, // Use each batch directly
--+                        final_score.into(),
--+                        policy_net,
--+                        value_net,
--+                        optimizer_policy,
--+                        optimizer_value,
--+                    );
--+                }
--+
--+                log::info!("Game {} finished with score: {}", game + 1, final_score);
--+                scores.push(final_score);
--+
--+                // Update batch-specific counters
--+                batch_games_played += 1;
--+                total_score += final_score;
--+
--+                if game % evaluation_interval_average == 0 && game != 0 {
--+                    let moyenne: f64 = scores.iter().sum::<i32>() as f64 / scores.len() as f64;
--+                    log::info!(
--+                        "📊 [Batch {}] Avg Score: {:.2} | Games Played: {}",
--+                        games_played / evaluation_interval,
--+                        moyenne,
--+                        games_played
--+                    );
--+                    log::info!("batch {} - Score moyen: {:.2}", game, moyenne);
--+                    write
--+                        .send(Message::Text(format!("GAME_RESULT:{}", moyenne)))
--+                        .await
--+                        .unwrap();
--+                }
--+
--+                // Save current game data for future training
--+                save_game_data("game_data", game_data);
--+            }
--+
--+            // Update main game counters
--+            games_played += batch_games_played;
--+
--+            // Append results to the file
--+            let avg_score = total_score as f64 / games_played as f64;
--+            append_to_results_file(results_file, avg_score);
--+
--+            // Calculate and display averages
--+            let mut averages: Vec<(usize, f64)> = scores_by_position
--+                .iter()
--+                .map(|(position, scores)| {
--+                    let average_score: f64 =
--+                        scores.iter().sum::<i32>() as f64 / scores.len() as f64;
--+                    (*position, average_score)
--+                })
--+                .collect();
--+
--+            averages.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
--+
--+            log::info!("\n--- Average Scores by First Position (Sorted) ---");
--+            for (position, average_score) in averages {
--+                log::info!(
--+                    "Position: {}, Average Score: {:.2}",
--+                    position,
--+                    average_score
--+                );
--+            }
--+
--+            // Evaluate model after each interval
--+            evaluate_model(policy_net, value_net, num_simulations).await;
--+
--+            log::info!(
--+                "Games Played: {}, Total Score: {}, Avg Score: {:.2}",
--+                games_played,
--+                total_score,
--+                total_score as f32 / games_played as f32
--+            );
--+            let model_path = "model_weights";
--+            // Save model weights
--+            log::info!("Saving models to {}", model_path);
--+            log::info!("Saving model weights...");
--+            if let Err(e) = policy_net.save_model(vs_policy, "model_weights/policy/policy.params") {
--+                log::error!("Error saving PolicyNet weights: {:?}", e);
--+            }
--+            if let Err(e) = value_net.save_model(vs_value, "model_weights/value/value.params") {
--+                log::error!("Error saving ValueNet weights: {:?}", e);
--+            }
--+        }
--+        break; // Exit after handling one connection
--+    }
--+}
--diff --git a/src/training/websocket.rs b/src/training/websocket.rs
--index e69de29..3ca151d 100644
----- a/src/training/websocket.rs
--+++ b/src/training/websocket.rs
--@@ -0,0 +1,42 @@
--+use futures_util::stream::SplitSink;
--+use futures_util::{SinkExt, StreamExt};
--+use tokio::net::TcpListener;
--+use tokio_tungstenite::tungstenite::Message;
--+use tokio_tungstenite::{accept_async, WebSocketStream};
--+
--+pub async fn reconnect_websocket(
--+    listener: &TcpListener,
--+) -> Option<SplitSink<WebSocketStream<tokio::net::TcpStream>, Message>> {
--+    match listener.accept().await {
--+        Ok((stream, _)) => {
--+            log::info!("Re-establishing WebSocket connection...");
--+            let ws_stream = accept_async(stream)
--+                .await
--+                .expect("Failed to accept WebSocket");
--+            let (write, _) = ws_stream.split();
--+            Some(write)
--+        }
--+        Err(e) => {
--+            log::error!("Error while reconnecting WebSocket: {:?}", e);
--+            None
--+        }
--+    }
--+}
--+/// Envoie un message via WebSocket avec gestion d'erreur
--+pub async fn send_websocket_message(
--+    write: &mut SplitSink<WebSocketStream<tokio::net::TcpStream>, Message>,
--+    message: String,
--+    listener: &TcpListener,
--+) -> Result<(), Box<dyn std::error::Error>> {
--+    if let Err(e) = write.send(Message::Text(message.clone())).await {
--+        log::error!("WebSocket error: {:?}. Attempting to reconnect...", e);
--+
--+        if let Some(new_write) = reconnect_websocket(listener).await {
--+            *write = new_write;
--+            write.send(Message::Text(message)).await?;
--+        } else {
--+            return Err("Failed to reconnect WebSocket".into());
--+        }
--+    }
--+    Ok(())
--+}
--\ No newline at end of file
--diff --git a/src/utils/image.rs b/src/utils/image.rs
--index e69de29..8e5c04a 100644
----- a/src/utils/image.rs
--+++ b/src/utils/image.rs
--@@ -0,0 +1,8 @@
--+use crate::game::tile::Tile;
--+
--+pub fn generate_tile_image_names(tiles: &[Tile]) -> Vec<String> {
--+    tiles
--+        .iter()
--+        .map(|tile| format!("../image/{}{}{}.png", tile.0, tile.1, tile.2))
--+        .collect()
--+}
--\ No newline at end of file
--diff --git a/src/utils/mod.rs b/src/utils/mod.rs
--index e69de29..8a824bf 100644
----- a/src/utils/mod.rs
--+++ b/src/utils/mod.rs
--@@ -0,0 +1,2 @@
--+pub mod random_index;
--+pub mod image;
--\ No newline at end of file
--diff --git a/src/utils/random_index.rs b/src/utils/random_index.rs
--index e69de29..fe25ce6 100644
----- a/src/utils/random_index.rs
--+++ b/src/utils/random_index.rs
--@@ -0,0 +1,5 @@
--+pub fn random_index(max: usize) -> usize {
--+    use rand::Rng;
--+    let mut rng = rand::thread_rng();
--+    rng.gen_range(0..max)
--+}
--\ No newline at end of file
-diff --git a/src/build.rs b/src/build.rs
-index e69de29..508db92 100644
---- a/src/build.rs
-+++ b/src/build.rs
-@@ -0,0 +1,24 @@
-+fn main() -> Result<(), Box<dyn std::error::Error>> {
-+    // Configuration de tonic-build
-+    tonic_build::configure()
-+        .build_server(true)
-+        .build_client(true)
-+        .compile(
-+            &["proto/session_manager.proto"],
-+            &["proto/"],
-+        )?;
-+
-+    // Alternative si vous voulez plus de contrôle :
-+    /*
-+    tonic_build::configure()
-+        .out_dir("src/generated")  // Répertoire de sortie personnalisé
-+        .build_server(true)
-+        .build_client(true)
-+        .compile(
-+            &["proto/session_manager.proto"],
-+            &["proto/"],
-+        )?;
-+    */
-+
-+    Ok(())
-+}
-\ No newline at end of file
-diff --git a/src/data/append_result.rs b/src/data/append_result.rs
-index 5e0a05b..670e48f 100644
---- a/src/data/append_result.rs
-+++ b/src/data/append_result.rs
-@@ -1,11 +1,6 @@
- use std::fs::OpenOptions;
- use std::io::{BufWriter, Write};
- use chrono::Utc;
--use futures_util::stream::SplitSink;
--use futures_util::StreamExt;
--use tokio::net::TcpListener;
--use tokio_tungstenite::tungstenite::Message;
--use tokio_tungstenite::{accept_async, WebSocketStream};
- 
- pub fn append_to_results_file(file_path: &str, avg_score: f64) {
-     let timestamp = Utc::now().to_rfc3339();
-diff --git a/src/game/create_deck.rs b/src/game/create_deck.rs
-index 3a7c7f7..58577bd 100644
---- a/src/game/create_deck.rs
-+++ b/src/game/create_deck.rs
-@@ -40,7 +40,6 @@ pub(crate) fn new_tiles(x: i32, y: i32, z: i32) -> Tile {
- }
- #[cfg(test)]
- mod tests {
--    use crate::game::create_deck;
-     use crate::game::create_deck::create_deck;
-     use crate::game::tile::Tile;
- 
-diff --git a/src/game/remove_tile_from_deck.rs b/src/game/remove_tile_from_deck.rs
-index 59323aa..6499edb 100644
---- a/src/game/remove_tile_from_deck.rs
-+++ b/src/game/remove_tile_from_deck.rs
-@@ -17,37 +17,23 @@ use crate::game::tile::Tile;
- //
- //     Deck { tiles: new_tiles } // Return the new deck with replaced tiles
- // }
--pub(crate) fn replace_tile_in_deck(deck: &Deck, tile_to_remove: &Tile) -> Deck {
--    let mut found = false;
--
-+pub(crate) fn replace_tile_in_deck(deck: &Deck, tile_to_replace: &Tile) -> Deck {
-     let new_tiles: Vec<Tile> = deck
-         .tiles
-         .iter()
--        .cloned()
--        .filter(|tile| {
--            if !found && tile == tile_to_remove {
--                found = true; // remove only the first match
--                false
-+        .map(|tile| {
-+            if tile == tile_to_replace {
-+                Tile(0, 0, 0) // Replace the tile
-             } else {
--                true
-+                *tile // Keep the original tile
-             }
-         })
-         .collect();
- 
--    Deck { tiles: new_tiles }
-+    Deck { tiles: new_tiles } // Return the new deck with replaced tiles
- }
- 
--pub fn remove_tile_from_deck(deck: &Deck, tile_to_remove: &Tile) -> Deck {
--    // Filtre toutes les tuiles sauf celle à retirer
--    let new_tiles: Vec<Tile> = deck
--        .tiles
--        .iter()
--        .filter(|&tile| tile != tile_to_remove) // Conserve uniquement les tuiles différentes
--        .cloned() // Copie chaque tuile dans le nouveau vecteur
--        .collect();
- 
--    Deck { tiles: new_tiles } // Crée un nouveau deck
--}
- #[cfg(test)]
- mod tests {
-     use super::*;
-@@ -67,10 +53,9 @@ mod tests {
-         let tile_to_remove = Tile(4, 5, 6);
- 
-         // Remove the tile from the deck
--        let updated_deck = remove_tile_from_deck(&deck, &tile_to_remove);
-+        let updated_deck = replace_tile_in_deck(&deck, &tile_to_remove);
- 
-         // Ensure the tile is removed
--        assert_eq!(updated_deck.tiles.len(), 2);
-         assert!(!updated_deck.tiles.contains(&tile_to_remove));
- 
-         // Ensure other tiles are still present
-@@ -93,7 +78,7 @@ mod tests {
-         let tile_to_remove = Tile(0, 0, 0);
- 
-         // Remove the tile
--        let updated_deck = remove_tile_from_deck(&deck, &tile_to_remove);
-+        let updated_deck = replace_tile_in_deck(&deck, &tile_to_remove);
- 
-         // Ensure the deck size remains unchanged
-         assert_eq!(updated_deck.tiles.len(), 3);
-diff --git a/src/main.rs b/src/main.rs
-index 90a57dc..7176e02 100644
---- a/src/main.rs
-+++ b/src/main.rs
-@@ -1,49 +1,17 @@
--use chrono::Utc;
- use clap::Parser;
--use futures_util::stream::SplitSink;
--use futures_util::{SinkExt, StreamExt};
--use rand::{rng, Rng};
--use serde_json;
--use std::collections::HashMap;
--use std::fs::OpenOptions;
--use std::io::{BufWriter, Write};
-+use futures_util::StreamExt;
- use std::path::Path;
--use std::sync::Arc;
--use tch::nn::{Optimizer, OptimizerConfig};
--use tch::{nn, Device, IndexOp, Tensor};
-+use tch::nn::{self, OptimizerConfig};
-+use tch::Device;
- use tokio::net::TcpListener;
--use tokio_tungstenite::tungstenite::protocol::Message;
--use tokio_tungstenite::{accept_async, WebSocketStream};
-+use tokio_tungstenite::accept_async;
- 
--use crate::game::deck::Deck;
--use crate::game::plateau::create_plateau_empty;
- use crate::logging::setup_logging;
--use crate::mcts::mcts_result::MCTSResult;
- use crate::mcts_vs_human::play_mcts_vs_human;
--use game::create_deck::create_deck;
--use game::plateau::Plateau;
--use game::remove_tile_from_deck::replace_tile_in_deck;
--use game::tile::Tile;
- use neural::policy_value_net::{PolicyNet, ValueNet};
--use crate::data::append_result::append_to_results_file;
--use crate::data::load_data::load_game_data;
--use crate::data::save_data::save_game_data;
--use crate::game::get_legal_moves::get_legal_moves;
--use crate::game::plateau_is_full::is_plateau_full;
--use crate::game::simulate_game::simulate_games;
--use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
--use crate::neural::tensor_conversion::convert_plateau_to_tensor;
--use crate::neural::training::gradient_clipping::enhanced_gradient_clipping;
--use crate::neural::training::normalization::robust_state_normalization;
--use crate::neural::training::trainer::train_network_with_game_data;
--use crate::scoring::scoring::result;
--use crate::strategy::position_evaluation::enhanced_position_evaluation;
--use crate::training::evaluator::evaluate_model;
- use crate::training::session::train_and_evaluate;
--use crate::training::websocket::reconnect_websocket;
--use crate::utils::image::generate_tile_image_names;
--use crate::utils::random_index::random_index;
- 
-+#[cfg(test)]
- mod test;
- 
- mod game;
-@@ -68,11 +36,22 @@ struct Config {
-     #[arg(short = 's', long, default_value_t = 150)]
-     num_simulations: usize,
- 
--    /// Run MCTS vs Human instead of training
--    #[arg(long, default_value_t = true)]
--    mcts_vs_human: bool,
-+    /// Mode de jeu
-+    #[arg(long, value_enum, default_value = "mcts-vs-human")]
-+    mode: GameMode,
- }
- 
-+#[derive(clap::ValueEnum, Clone, Debug)]
-+enum GameMode {
-+    /// Mode entraînement normal
-+    Training,
-+    /// MCTS vs un seul humain
-+    MctsVsHuman,
-+    /// MCTS vs plusieurs humains (style Kahoot)
-+    Multiplayer,
-+}
-+
-+
- #[tokio::main]
- async fn main() {
-     let config = Config::parse();
-@@ -113,47 +92,63 @@ async fn main() {
-     .unwrap(); // Was 1e-3
- 
-     // ➕ Duel Mode: MCTS vs Human
--    if config.mcts_vs_human {
--        let listener = TcpListener::bind("127.0.0.1:9001")
--            .await
--            .expect("Unable to bind WebSocket on port 9001 for MCTS vs Human");
--
--        log::info!("🧍‍♂️🤖 Waiting for MCTS vs Human connection...");
--        let (stream, _) = listener.accept().await.unwrap();
--        let ws_stream = accept_async(stream).await.unwrap();
--        let (mut write, mut read) = ws_stream.split();
--
--        play_mcts_vs_human(
--            &policy_net,
--            &value_net,
--            config.num_simulations,
--            &mut write,
--            &mut read,
--        )
--        .await;
--
--        return; // Exit after duel game
--    }
-+    match config.mode {
-+        GameMode::Training => {
-+            log::info!("🧠 Starting training mode...");
-+            let listener = TcpListener::bind("127.0.0.1:9000")
-+                .await
-+                .expect("Unable to bind WebSocket on port 9000 for training");
-+            log::info!("🧠 Training WebSocket server started at ws://127.0.0.1:9000");
-+
-+            train_and_evaluate(
-+                &vs_policy,
-+                &vs_value,
-+                &mut policy_net,
-+                &mut value_net,
-+                &mut optimizer_policy,
-+                &mut optimizer_value,
-+                config.num_games,
-+                config.num_simulations,
-+                50,
-+                listener.into(),
-+            )
-+                .await;
-+        }
- 
--    // 🧠 Training Mode
--    let listener = TcpListener::bind("127.0.0.1:9000")
--        .await
--        .expect("Unable to bind WebSocket on port 9000 for training");
--    log::info!("🧠 Training WebSocket server started at ws://127.0.0.1:9000");
--
--    train_and_evaluate(
--        &vs_policy,
--        &vs_value,
--        &mut policy_net,
--        &mut value_net,
--        &mut optimizer_policy,
--        &mut optimizer_value,
--        config.num_games,
--        config.num_simulations,
--        50, // Evaluate every 50 games
--        listener.into(),
--    )
--    .await;
-+        GameMode::MctsVsHuman => {
-+            log::info!("🧍‍♂️🤖 Starting MCTS vs Human mode...");
-+            let listener = TcpListener::bind("127.0.0.1:9001")
-+                .await
-+                .expect("Unable to bind WebSocket on port 9001 for MCTS vs Human");
-+
-+            let (stream, _) = listener.accept().await.unwrap();
-+            let ws_stream = accept_async(stream).await.unwrap();
-+            let (mut write, mut read) = ws_stream.split();
-+
-+            play_mcts_vs_human(
-+                &policy_net,
-+                &value_net,
-+                config.num_simulations,
-+                &mut write,
-+                &mut read,
-+                (&listener).into(),
-+            )
-+                .await;
-+        }
-+
-+        GameMode::Multiplayer => {
-+            log::info!("🎮👥 Starting Multiplayer mode (MCTS vs Multiple Humans)...");
-+            log::info!("🔗 Players can connect and create/join sessions");
-+            log::info!("📋 Session codes will be generated for easy joining");
-+
-+            // start_multiplayer_server(
-+            //     policy_net,
-+            //     value_net,
-+            //     config.num_simulations,
-+            // )
-+            //     .await;
-+        }
-+    }
- }
- 
- 
-diff --git a/src/mcts/algorithm.rs b/src/mcts/algorithm.rs
-index 88c272f..144d95c 100644
---- a/src/mcts/algorithm.rs
-+++ b/src/mcts/algorithm.rs
-@@ -141,8 +141,8 @@ pub fn mcts_find_best_position_for_tile_with_nn(
-             let mut total_simulated_score = 0.0;
- 
-             for _ in 0..rollout_count {
--                let mut lookahead_plateau = temp_plateau.clone();
--                let mut lookahead_deck = temp_deck.clone();
-+                let lookahead_plateau = temp_plateau.clone();
-+                let lookahead_deck = temp_deck.clone();
- 
-                 // 🔮 Étape 1.1 — Tirer une tuile hypothétique (T2)
-                 if lookahead_deck.tiles.is_empty() {
-diff --git a/src/mcts_vs_human.rs b/src/mcts_vs_human.rs
-index bec6730..76e0c5a 100644
---- a/src/mcts_vs_human.rs
-+++ b/src/mcts_vs_human.rs
-@@ -1,20 +1,22 @@
- use crate::game::create_deck::create_deck;
-+use crate::game::plateau_is_full::is_plateau_full;
- use crate::game::remove_tile_from_deck::replace_tile_in_deck;
--use crate::generate_tile_image_names;
--use crate::{is_plateau_full};
-+use crate::training::websocket::send_websocket_message;
-+use crate::utils::image::generate_tile_image_names;
-+// Import de votre fonction
- 
--use serde_json::json;
--use tokio_tungstenite::tungstenite::protocol::Message;
--use tokio_tungstenite::WebSocketStream;
--use tokio::net::TcpStream;
--use futures_util::{SinkExt, StreamExt};
--use futures_util::stream::SplitSink;
--use rand::Rng;
- use crate::game::plateau::create_plateau_empty;
--use crate::neural::policy_value_net::{PolicyNet, ValueNet};
- use crate::game::tile::Tile;
- use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
-+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
- use crate::scoring::scoring::result;
-+use futures_util::stream::SplitSink;
-+use futures_util::StreamExt;
-+use rand::Rng;
-+use serde_json::json;
-+use tokio::net::{TcpListener, TcpStream};
-+use tokio_tungstenite::tungstenite::protocol::Message;
-+use tokio_tungstenite::WebSocketStream;
- 
- pub async fn play_mcts_vs_human(
-     policy_net: &PolicyNet,
-@@ -22,6 +24,7 @@ pub async fn play_mcts_vs_human(
-     num_simulations: usize,
-     write: &mut SplitSink<WebSocketStream<TcpStream>, Message>,
-     read: &mut (impl StreamExt<Item = Result<Message, tokio_tungstenite::tungstenite::Error>> + Unpin),
-+    listener: &TcpListener, // ✅ Ajout du listener pour votre fonction
- ) {
-     let mut deck = create_deck();
-     let mut plateau_human = create_plateau_empty();
-@@ -36,19 +39,25 @@ pub async fn play_mcts_vs_human(
-         deck = replace_tile_in_deck(&deck, &tile); // remove it from deck
-         let tile_image = format!("../image/{}{}{}.png", tile.0, tile.1, tile.2);
- 
--        // ✅ Send state to frontend
-+        // ✅ Send state to frontend - REFACTORISÉ
-         let payload = json!({
-             "type": "mcts_vs_human_turn",
-             "tile": tile_image,
-             "plateau_human": generate_tile_image_names(&plateau_human.tiles),
-             "plateau_mcts": generate_tile_image_names(&plateau_mcts.tiles)
-         });
--        if write.send(Message::Text(payload.to_string())).await.is_err() {
--            eprintln!("❌ Failed to send turn info to frontend (WebSocket closed?)");
-+
-+        // 🔄 REMPLACEMENT: write.send() simple → send_websocket_message()
-+        if let Err(e) = send_websocket_message(
-+            write,
-+            payload.to_string(),
-+            listener
-+        ).await {
-+            eprintln!("❌ Failed to send turn info to frontend: {}", e);
-             return;
-         }
- 
--        // ✅ Wait for HUMAN move
-+        // ✅ Wait for HUMAN move (pas de changement nécessaire ici)
-         let mut human_move: Option<usize> = None;
-         while let Some(msg) = read.next().await {
-             match msg {
-@@ -97,7 +106,7 @@ pub async fn play_mcts_vs_human(
-         current_turn += 1;
-     }
- 
--    // ✅ Game over - send results
-+    // ✅ Game over - send results - REFACTORISÉ
-     let score_human = result(&plateau_human);
-     let score_mcts = result(&plateau_mcts);
- 
-@@ -107,7 +116,12 @@ pub async fn play_mcts_vs_human(
-         "score_mcts": score_mcts
-     });
- 
--    if write.send(Message::Text(final_payload.to_string())).await.is_err() {
--        eprintln!("❌ Failed to send final results.");
-+    // 🔄 REMPLACEMENT: write.send() simple → send_websocket_message()
-+    if let Err(e) = send_websocket_message(
-+        write,
-+        final_payload.to_string(),
-+        listener
-+    ).await {
-+        eprintln!("❌ Failed to send final results: {}", e);
-     }
- }
-diff --git a/src/neural/policy_value_net.rs b/src/neural/policy_value_net.rs
-index 0f78c2c..2d9ee6a 100644
---- a/src/neural/policy_value_net.rs
-+++ b/src/neural/policy_value_net.rs
-@@ -105,7 +105,7 @@ pub fn initialize_weights(vs: &nn::VarStore) {
-             let fan_out = (size[0] * size[2] * size[3]) as f64;
-             let bound = (6.0 / (fan_in + fan_out)).sqrt();
-             tch::no_grad(|| {
--                param.f_uniform_(-bound, bound).unwrap();
-+                let _ = param.f_uniform_(-bound, bound).unwrap();
-             });
-         } else if size.len() == 2 {
-             // Xavier initialization for linear layers
-@@ -113,12 +113,12 @@ pub fn initialize_weights(vs: &nn::VarStore) {
-             let fan_out = size[0] as f64;
-             let bound = (6.0 / (fan_in + fan_out)).sqrt();
-             tch::no_grad(|| {
--                param.f_uniform_(-bound, bound).unwrap();
-+                let _ = param.f_uniform_(-bound, bound).unwrap();
-             });
-         } else if size.len() == 1 {
-             // Zero initialization for biases
-             tch::no_grad(|| {
--                param.f_zero_().unwrap();
-+                let _ = param.f_zero_().unwrap();
-             });
-         }
- 
-@@ -256,10 +256,11 @@ impl ValueNet {
- 
- 
- }
-+#[allow(dead_code)]
- fn kaiming_uniform(tensor: &mut Tensor, fan_in: f64) {
-     let bound = (6.0f64).sqrt() / fan_in.sqrt();
-     tch::no_grad(|| {
--        tensor.f_uniform_(-bound, bound).unwrap();
-+        let _ = tensor.f_uniform_(-bound, bound).unwrap();
-     });
- }
- 
-diff --git a/src/neural/res_net_block.rs b/src/neural/res_net_block.rs
-index e40b131..2da0303 100644
---- a/src/neural/res_net_block.rs
-+++ b/src/neural/res_net_block.rs
-@@ -1,7 +1,5 @@
- use tch::{nn, Tensor};
- 
--use crate::neural::policy_value_net::initialize_weights;
--
- /// Residual Block
- pub struct ResNetBlock {
-     pub(crate) conv1: nn::Conv2D,
-diff --git a/src/neural/training/gradient_clipping.rs b/src/neural/training/gradient_clipping.rs
-index 18052aa..2ff6d58 100644
---- a/src/neural/training/gradient_clipping.rs
-+++ b/src/neural/training/gradient_clipping.rs
-@@ -36,7 +36,7 @@ fn clip_value_network_gradients(vs_value: &nn::VarStore) -> f64 {
-                 max_grad_value = max_grad_value.max(grad_norm);
- 
-                 // Clipping très agressif pour stabilité
--                tensor.grad().clamp_(-0.5, 0.5);
-+                let _ = tensor.grad().clamp_(-0.5, 0.5);
-             }
-         }
-     });
-@@ -55,7 +55,7 @@ fn clip_policy_network_gradients(vs_policy: &nn::VarStore) -> f64 {
-                 max_grad_policy = max_grad_policy.max(grad_norm);
- 
-                 // Clipping modéré
--                tensor.grad().clamp_(-1.0, 1.0);
-+                let _ = tensor.grad().clamp_(-1.0, 1.0);
-             }
-         }
-     });
-@@ -74,6 +74,7 @@ fn log_gradient_norms(max_grad_value: f64, max_grad_policy: f64) {
- }
- 
- /// Version simple du clipping des gradients
-+#[allow(dead_code)]
- pub fn simple_gradient_clipping(
-     vs: &nn::VarStore,
-     max_norm: f64,
-@@ -86,7 +87,7 @@ pub fn simple_gradient_clipping(
-                 let grad_norm = tensor.grad().norm().double_value(&[]);
-                 max_grad = max_grad.max(grad_norm);
- 
--                tensor.grad().clamp_(-max_norm, max_norm);
-+                let _ = tensor.grad().clamp_(-max_norm, max_norm);
-             }
-         }
-     });
-diff --git a/src/neural/training/normalization.rs b/src/neural/training/normalization.rs
-index c2a44c6..7c4d3b8 100644
---- a/src/neural/training/normalization.rs
-+++ b/src/neural/training/normalization.rs
-@@ -46,6 +46,7 @@ fn normalize_with_mad(tensor: &Tensor, median: f64, mad: f64) -> Tensor {
- }
- 
- /// Version simple de normalisation z-score
-+#[allow(dead_code)]
- pub fn simple_normalization(tensor: &Tensor) -> Tensor {
-     let mean = tensor.mean(tch::Kind::Float);
-     let std = tensor.std(false).clamp_min(1e-8);
-@@ -53,6 +54,7 @@ pub fn simple_normalization(tensor: &Tensor) -> Tensor {
- }
- 
- /// Normalisation min-max
-+#[allow(dead_code)]
- pub fn min_max_normalization(tensor: &Tensor) -> Tensor {
-     let min_val = tensor.min();
-     let max_val = tensor.max();
-diff --git a/src/neural/training/trainer.rs b/src/neural/training/trainer.rs
-index 95a6d39..9b30739 100644
---- a/src/neural/training/trainer.rs
-+++ b/src/neural/training/trainer.rs
-@@ -9,7 +9,7 @@ pub fn train_network_with_game_data(
-     vs_policy: &nn::VarStore,
-     vs_value: &nn::VarStore,
-     game_data: &[MCTSResult],
--    discount_factor: f64,
-+    _discount_factor: f64,
-     policy_net: &PolicyNet,
-     value_net: &ValueNet,
-     optimizer_policy: &mut Optimizer,
-@@ -79,7 +79,7 @@ pub fn train_network_with_game_data(
-         // Policy loss
-         let best_position = result.best_position as i64;
-         let target_policy = Tensor::zeros(&[1, pred_policy.size()[1]], tch::kind::FLOAT_CPU);
--        target_policy.i((0, best_position)).fill_(1.0);
-+        let _ = target_policy.i((0, best_position)).fill_(1.0);
-         let log_policy = pred_policy.log();
-         let policy_loss = -(target_policy * log_policy.shallow_clone()).sum(tch::Kind::Float);
-         total_policy_loss += policy_loss;
-diff --git a/src/strategy/position_evaluation.rs b/src/strategy/position_evaluation.rs
-index 69e2403..48e76dc 100644
---- a/src/strategy/position_evaluation.rs
-+++ b/src/strategy/position_evaluation.rs
-@@ -3,7 +3,7 @@ use crate::game::tile::Tile;
- use crate::scoring::scoring::compute_alignment_score;
- 
- // Version simplifiée qui se concentre sur les positions stratégiques
--pub fn calculate_line_completion_bonus(plateau: &Plateau, position: usize, tile: &Tile) -> f64 {
-+pub fn calculate_line_completion_bonus(_plateau: &Plateau, position: usize, tile: &Tile) -> f64 {
-     let mut bonus = 0.0;
- 
-     // Bonus basé sur les positions stratégiques identifiées dans tes données
-diff --git a/src/test.rs b/src/test.rs
-index 896f3e0..66ef714 100644
---- a/src/test.rs
-+++ b/src/test.rs
-@@ -1,8 +1,7 @@
--use crate::game::plateau::Plateau;
--use crate::game::tile::Tile;
--
- #[cfg(test)]
- pub(crate) mod tests {
-+    use crate::game::plateau::Plateau;
-+    use crate::game::tile::Tile;
-     pub fn create_mcts_node(state: GameState, parent: Option<*mut MCTSNode>) -> MCTSNode {
-         MCTSNode {
-             state,
-@@ -61,7 +60,7 @@ pub(crate) mod tests {
-             placer_tile(&mut game_state.plateau, tile, position);
-             let new_plateau = game_state.plateau.clone();
-             let mut new_deck = game_state.deck.clone();
--            new_deck = remove_tile_from_deck(&new_deck, &tile);
-+            new_deck = replace_tile_in_deck(&new_deck, &tile);
- 
- 
-             Some(GameState {
-@@ -129,18 +128,17 @@ pub(crate) mod tests {
-             (*current).value += score;
-         }
-     }
--    use crate::game::remove_tile_from_deck::remove_tile_from_deck;
--use super::*;
--
--
-     use rand::Rng;
-     use crate::game::create_deck::create_deck;
--    use crate::{convert_plateau_to_tensor, get_legal_moves, is_plateau_full, simulate_games};
-+    use crate::game::get_legal_moves::get_legal_moves;
-+    use crate::game::plateau_is_full::is_plateau_full;
-+    use crate::game::simulate_game::simulate_games;
-+    use crate::neural::tensor_conversion::convert_plateau_to_tensor;
-     use crate::game::deck::Deck;
-     use crate::game::game_state::GameState;
-     use crate::mcts::mcts_node::MCTSNode;
--    use crate::game::plateau::{create_plateau_empty, Plateau};
--    use crate::game::tile::Tile;
-+    use crate::game::plateau::create_plateau_empty;
-+    use crate::game::remove_tile_from_deck::replace_tile_in_deck;
-     use crate::scoring::scoring::result;
- 
-     #[test]
-@@ -182,7 +180,7 @@ use super::*;
-     fn test_simulate_games() {
-         let plateau = create_plateau_empty();
-         let deck = create_deck();
--        let num_simulations = 10;
-+        let _num_simulations = 10;
- 
-         let avg_score = simulate_games(plateau, deck);
-         assert!(avg_score >= 0); // Score should be non-negative
-@@ -194,7 +192,7 @@ use super::*;
-         let deck = create_deck();
- 
-         let tensor = convert_plateau_to_tensor(&plateau, &tile, &deck, /* usize */0, 19/* usize */);
--        assert_eq!(tensor.size(), vec![1, 3, 5, 5]); // Ensure the tensor has the correct shape
-+        assert_eq!(tensor.size(), vec![1, 5, 47, 1]); // Ensure the tensor has the correct shape
-     }
- 
- 
-@@ -202,11 +200,11 @@ use super::*;
-     #[test]
-     fn test_placement_tuile_not_valide_take_it_easy() {
-         let mut plateau:Plateau=create_plateau_empty();
--        let deckSfuffle:Deck= create_deck();
--        let tile = deckSfuffle.tiles[5].clone();
-+        let deck_sfuffle: Deck = create_deck();
-+        let tile = deck_sfuffle.tiles[5].clone();
-         assert!(placer_tile(&mut plateau, tile.clone(), 1));
-         assert_eq!(plateau.tiles[1], tile);
--        let tile = deckSfuffle.tiles[5].clone();
-+        let tile = deck_sfuffle.tiles[5].clone();
-         assert!(!placer_tile(&mut plateau, tile.clone(), 1));
-     }
-     #[test]
-@@ -215,8 +213,8 @@ use super::*;
-         let deck_shuffle: Deck = create_deck();
- 
-         // Génère un index aléatoire
--        let mut rng = rand::thread_rng();
--        let index = rng.gen_range(0..deck_shuffle.tiles.len());
-+        let mut rng = rand::rng();
-+        let index = rng.random_range(0..deck_shuffle.tiles.len());
- 
-         // Sélectionne une tuile aléatoire
-         let tuile = deck_shuffle.tiles[index].clone();
-@@ -239,17 +237,18 @@ use super::*;
-         let deck_shuffle: Deck = create_deck();
- 
-         // Génère un indice aléatoire
--        let mut rng = rand::thread_rng();
--        let index = rng.gen_range(0..deck_shuffle.tiles.len());
-+        let mut rng = rand::rng();
-+        let index = rng.random_range(0..deck_shuffle.tiles.len());
- 
-         // Récupère la tuile choisie aléatoirement
-         let tuile_choisie = deck_shuffle.tiles[index].clone();
- 
-         // Supprime la tuile du deck
--        let nouveau_deck = remove_tile_from_deck(&deck_shuffle, &tuile_choisie);
-+        let nouveau_deck = replace_tile_in_deck(&deck_shuffle, &tuile_choisie);
-+        
- 
-         // Vérifie que la nouvelle taille du deck est réduite de 1
--        assert_eq!(nouveau_deck.tiles.len(), deck_shuffle.tiles.len() - 1);
-+        assert_eq!(27-nouveau_deck.tiles.iter().filter(|&&tile| tile == Tile(0, 0, 0)).count(),26);
- 
-         // Vérifie que la tuile choisie n'est plus présente dans le nouveau deck
-         assert!(!nouveau_deck.tiles.contains(&tuile_choisie));
-@@ -278,7 +277,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_first_3_plateau_3_1() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
-         placer_tile(&mut plateau, deck.tiles[1].clone(), 1);
-@@ -288,7 +287,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_first_3_plateau_3_2() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[9].clone(), 0);
-         placer_tile(&mut plateau, deck.tiles[10].clone(), 1);
-@@ -298,7 +297,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_2_column_plateau_4_2() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[9].clone(), 3);
-         placer_tile(&mut plateau, deck.tiles[10].clone(), 4);
-@@ -312,7 +311,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_column_center_plateau_5_2() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[9].clone(), 7);
-         placer_tile(&mut plateau, deck.tiles[10].clone(), 8);
-@@ -327,7 +326,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_column_4_plateau_4_2() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[9].clone(), 12);
-         placer_tile(&mut plateau, deck.tiles[10].clone(), 13);
-@@ -341,7 +340,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_last_column_3_plateau_3_1() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 16);
-         placer_tile(&mut plateau, deck.tiles[1].clone(),17);
-@@ -351,7 +350,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_first_diag_plateau_0_3_7() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
-         placer_tile(&mut plateau, deck.tiles[4].clone(),3);
-@@ -361,7 +360,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_second_diag_plateau_1_4_8_12() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 1);
-         placer_tile(&mut plateau, deck.tiles[4].clone(),4);
-@@ -372,7 +371,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_third_diag_plateau_2_5_9_13_16() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 2);
-         placer_tile(&mut plateau, deck.tiles[4].clone(),5);
-@@ -384,7 +383,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_fourth_diag_plateau_6_10_14_17() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 6);
-         placer_tile(&mut plateau, deck.tiles[4].clone(),10);
-@@ -396,7 +395,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_last_diag_plateau_11_15_18() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 11);
-         placer_tile(&mut plateau, deck.tiles[4].clone(),15);
-@@ -408,7 +407,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_firdt_diag_left_plateau_7_12_16() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 7);
-         placer_tile(&mut plateau, deck.tiles[2].clone(),12);
-@@ -420,7 +419,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_second_diag_left_plateau_3_8_13_17() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 3);
-         placer_tile(&mut plateau, deck.tiles[2].clone(),8);
-@@ -433,7 +432,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_third_diag_left_plateau_0_4_9_14_18() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
-         placer_tile(&mut plateau, deck.tiles[2].clone(),4);
-@@ -448,7 +447,7 @@ use super::*;
- 
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_fourth_diag_left_plateau_1_5_10_15() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 1);
-         placer_tile(&mut plateau, deck.tiles[2].clone(),5);
-@@ -461,7 +460,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_last_diag_left_plateau_2_6_11() {
--        let mut deck = create_deck();
-+        let deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 2);
-         placer_tile(&mut plateau, deck.tiles[2].clone(),6);
-@@ -530,9 +529,9 @@ use super::*;
-                 break; // No more moves possible
-             }
- 
--            let mut rng = rand::thread_rng();
--            let position = legal_moves[rng.gen_range(0..legal_moves.len())].clone();
--            let tile_index = rng.gen_range(0..simulated_state.deck.tiles.len());
-+            let mut rng = rand::rng();
-+            let position = legal_moves[rng.random_range(0..legal_moves.len())].clone();
-+            let tile_index = rng.random_range(0..simulated_state.deck.tiles.len());
-             let chosen_tile = simulated_state.deck.tiles[tile_index].clone();
-             simulated_state = apply_move(simulated_state,chosen_tile, position).unwrap();
-         }
-@@ -546,16 +545,14 @@ use super::*;
- 
-         // Game is not over at the beginning
-         assert!(!is_game_over(state.clone()));
--
-+        let mut position = 0;
-         while state.plateau.tiles.contains(&Tile(0, 0, 0)) {
--            for position in 0..state.plateau.tiles.len() {
--                if let Some(empty_tile) = state.deck.tiles.first() {
--                    if let Some(new_state) = apply_move(state.clone(), *empty_tile, position) {
-+                if let Some(empty_tile) = state.deck.tiles.iter().filter(|tile| **tile != Tile(0, 0, 0)).collect::<Vec<_>>().first() {
-+                    if let Some(new_state) = apply_move(state.clone(), **empty_tile, position) {
-                         state = new_state;
--                        break; // Move to the next iteration after placing a tile
-                     }
-                 }
--            }
-+            position += 1;
-         }
- 
- 
-@@ -639,7 +636,7 @@ use super::*;
-     fn test_backpropagate_with_parent() {
-         let mut root = create_mcts_node(create_game_state(), None);
- 
--        let mut child = create_mcts_node(create_game_state(), Some(&mut root as *mut _));
-+        let child = create_mcts_node(create_game_state(), Some(&mut root as *mut _));
-         root.children.push(child);
- 
-         let  leaf = create_mcts_node(create_game_state(), Some(&mut root.children[0] as *mut _));
-@@ -731,10 +728,10 @@ use super::*;
-     #[test]
-     fn test_backpropagation_step() {
-         let mut root = create_mcts_node(create_game_state(), None);
--        let mut child = create_mcts_node(create_game_state(), Some(&mut root as *mut _));
-+        let child = create_mcts_node(create_game_state(), Some(&mut root as *mut _));
-         root.children.push(child);
- 
--        let mut leaf = create_mcts_node(create_game_state(), Some(&mut root.children[0] as *mut _));
-+        let leaf = create_mcts_node(create_game_state(), Some(&mut root.children[0] as *mut _));
-         root.children[0].children.push(leaf);
- 
-         let leaf_mut = &mut root.children[0].children[0];
-@@ -762,17 +759,17 @@ use super::*;
-             // Expansion
-             let legal_moves = get_legal_moves(selected_node.state.plateau.clone());
-             if !legal_moves.is_empty() {
--                let mut rng = rand::thread_rng();
--                let position = legal_moves[rng.gen_range(0..legal_moves.len())];
--                let tile_index = rng.gen_range(0..selected_node.state.deck.tiles.len());
-+                let mut rng = rand::rng();
-+                let position = legal_moves[rng.random_range(0..legal_moves.len())];
-+                let tile_index = rng.random_range(0..selected_node.state.deck.tiles.len());
-                 let chosen_tile = selected_node.state.deck.tiles[tile_index];
--                let deck_size_before = selected_node.state.deck.tiles.len();
-+                let deck_size_before = selected_node.state.deck.tiles.iter().filter(|tile| **tile != Tile(0, 0, 0)).collect::<Vec<_>>().len();
-                 println!("Deck size before expansion: {}", deck_size_before);
- 
-                 if let Some(new_state) = apply_move(selected_node.state.clone(), chosen_tile, position) {
-                     expand(selected_node.clone(), new_state.clone());
- 
--                    let deck_size_after = new_state.deck.tiles.len();
-+                    let deck_size_after = new_state.deck.tiles.iter().filter(|tile| **tile != Tile(0, 0, 0)).collect::<Vec<_>>().len();
-                     println!("Deck size after expansion: {}", deck_size_after);
- 
-                     assert_eq!(deck_size_after, deck_size_before - 1, "Deck size did not decrement correctly!");
-diff --git a/src/training/session.rs b/src/training/session.rs
-index 7b0fbaf..63d48a6 100644
---- a/src/training/session.rs
-+++ b/src/training/session.rs
-@@ -8,15 +8,13 @@ use crate::game::remove_tile_from_deck::replace_tile_in_deck;
- use crate::game::tile::Tile;
- use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
- use crate::mcts::mcts_result::MCTSResult;
--use crate::mcts_vs_human::play_mcts_vs_human;
- use crate::neural::policy_value_net::{PolicyNet, ValueNet};
- use crate::neural::training::trainer::train_network_with_game_data;
- use crate::scoring::scoring::result;
- use crate::training::evaluator::evaluate_model;
--use crate::training::websocket::reconnect_websocket;
-+use crate::training::websocket::{send_websocket_message};
- use crate::utils::image::generate_tile_image_names;
--use crate::Config;
--use futures_util::{SinkExt, StreamExt};
-+use futures_util::{StreamExt};
- use rand::{rng, Rng};
- use std::collections::HashMap;
- use std::sync::Arc;
-@@ -24,9 +22,8 @@ use tch::nn;
- use tch::nn::Optimizer;
- use tokio::net::TcpListener;
- use tokio_tungstenite::accept_async;
--use tokio_tungstenite::tungstenite::Message;
--/// Lance une session MCTS vs Humain
- 
-+/// Lance une session MCTS vs Humain - Version refactorisée avec send_websocket_message
- pub async fn train_and_evaluate(
-     vs_policy: &nn::VarStore,
-     vs_value: &nn::VarStore,
-@@ -64,7 +61,6 @@ pub async fn train_and_evaluate(
-             );
- 
-             let mut batch_games_played = 0; // Tracks games processed in this evaluation interval
--
-             let max_memory_size = 1000; // Store last 500 games
- 
-             for game in 0..evaluation_interval {
-@@ -74,11 +70,12 @@ pub async fn train_and_evaluate(
-                 let mut first_move: Option<(usize, Tile)> = None;
-                 let total_turns = 19; // The number of moves in the game
-                 let mut current_turn = 0;
-+
-                 while !is_plateau_full(&plateau) {
-                     let tile_index = rng().random_range(0..deck.tiles.len());
-                     let chosen_tile = deck.tiles[tile_index];
--                    // ✅ **Send preview before placement**
--                    // ✅ **INSERT YOUR NEW CODE HERE**
-+
-+                    // ✅ Send preview before placement - REFACTORISÉ
-                     let chosen_tile_image = format!(
-                         "../image/{}{}{}.png",
-                         chosen_tile.0, chosen_tile.1, chosen_tile.2
-@@ -87,8 +84,16 @@ pub async fn train_and_evaluate(
-                         "next_tile": chosen_tile_image,
-                         "plateau_tiles": generate_tile_image_names(&plateau.tiles)
-                     });
--                    let serialized = serde_json::to_string(&payload).unwrap();
--                    write.send(Message::Text(serialized)).await.unwrap();
-+
-+                    // 🔄 REMPLACEMENT: write.send() → send_websocket_message()
-+                    if let Err(e) = send_websocket_message(
-+                        &mut write,
-+                        payload.to_string(),
-+                        &listener
-+                    ).await {
-+                        log::error!("Failed to send tile preview: {}", e);
-+                        break;
-+                    }
- 
-                     let game_result = mcts_find_best_position_for_tile_with_nn(
-                         &mut plateau,
-@@ -107,44 +112,42 @@ pub async fn train_and_evaluate(
-                     }
-                     plateau.tiles[best_position] = chosen_tile;
-                     deck = replace_tile_in_deck(&deck, &chosen_tile);
--                    // ✅ INSERT THIS TO SEND SCORE TO CLIENT
-+
-+                    // ✅ Send score to client - REFACTORISÉ
-                     let current_score = result(&plateau);
-                     let score_payload = serde_json::json!({
-                         "type": "score_update",
-                         "current_score": current_score,
-                     });
--                    let serialized_score = serde_json::to_string(&score_payload).unwrap();
--                    if let Err(e) = write.send(Message::Text(serialized_score)).await {
--                        log::error!("WebSocket error when sending score: {:?}", e);
--                        if let Some(new_write) = reconnect_websocket(&listener).await {
--                            write = new_write;
--                        } else {
--                            log::error!("Failed to reconnect WebSocket. Exiting...");
--                            break;
--                        }
-+
-+                    // 🔄 REMPLACEMENT: Logique complexe de reconnexion → send_websocket_message()
-+                    if let Err(e) = send_websocket_message(
-+                        &mut write,
-+                        score_payload.to_string(),
-+                        &listener
-+                    ).await {
-+                        log::error!("Failed to send score update: {}", e);
-+                        break;
-                     }
- 
-                     game_data.push(game_result); // Store training data
- 
--                    // ✅ **INSERT YOUR NEW CODE HERE**
-+                    // ✅ Send updated plateau state - REFACTORISÉ
-                     let payload_after_placement = serde_json::json!({
-                         "next_tile": null, // Clear preview
-                         "plateau_tiles": generate_tile_image_names(&plateau.tiles) // new updated state
-                     });
--                    let serialized = serde_json::to_string(&payload_after_placement).unwrap();
--
--                    // ✅ Handle WebSocket disconnections
--                    if let Err(e) = write.send(Message::Text(serialized.clone())).await {
--                        log::error!("WebSocket error: {:?}. Attempting to reconnect...", e);
--
--                        // **Reconnect WebSocket**
--                        if let Some(new_write) = reconnect_websocket(&listener).await {
--                            write = new_write;
--                        } else {
--                            log::error!("Failed to reconnect WebSocket. Exiting...");
--                            break;
--                        }
-+
-+                    // 🔄 REMPLACEMENT: Logique complexe de reconnexion → send_websocket_message()
-+                    if let Err(e) = send_websocket_message(
-+                        &mut write,
-+                        payload_after_placement.to_string(),
-+                        &listener
-+                    ).await {
-+                        log::error!("Failed to send plateau update: {}", e);
-+                        break;
-                     }
-+
-                     current_turn += 1; // Increment turn counter each time a tile is placed
-                 }
- 
-@@ -213,10 +216,16 @@ pub async fn train_and_evaluate(
-                         games_played
-                     );
-                     log::info!("batch {} - Score moyen: {:.2}", game, moyenne);
--                    write
--                        .send(Message::Text(format!("GAME_RESULT:{}", moyenne)))
--                        .await
--                        .unwrap();
-+
-+                    // 🔄 REMPLACEMENT: write.send().await.unwrap() → send_websocket_message()
-+                    let result_message = format!("GAME_RESULT:{}", moyenne);
-+                    if let Err(e) = send_websocket_message(
-+                        &mut write,
-+                        result_message,
-+                        &listener
-+                    ).await {
-+                        log::error!("Failed to send game result: {}", e);
-+                    }
-                 }
- 
-                 // Save current game data for future training
-diff --git a/src/utils/random_index.rs b/src/utils/random_index.rs
-index fe25ce6..53059d0 100644
---- a/src/utils/random_index.rs
-+++ b/src/utils/random_index.rs
-@@ -1,5 +1,5 @@
- pub fn random_index(max: usize) -> usize {
-     use rand::Rng;
--    let mut rng = rand::thread_rng();
--    rng.gen_range(0..max)
-+    let mut rng = rand::rng();
-+    rng.random_range(0..max)
- }
-\ No newline at end of file
diff --git a/frontend/complete_codebase.md b/frontend/complete_codebase.md
index 7465b99..3522032 100644
--- a/frontend/complete_codebase.md
+++ b/frontend/complete_codebase.md
@@ -3392,3 +3392,3397 @@ export interface CreateSessionRequest {
 // ... (fichier tronqué)
 ```
 
+## 📄 package.json
+```json
+{
+  "name": "vite-template-solid",
+  "version": "0.0.0",
+  "description": "",
+  "type": "module",
+  "scripts": {
+    "start": "vite",
+    "dev": "vite",
+    "build": "vite build",
+    "serve": "vite preview",
+    "test": "vitest"
+  },
+  "license": "MIT",
+  "devDependencies": {
+    "@protobuf-ts/plugin": "^2.11.0",
+    "@solidjs/testing-library": "^0.8.10",
+    "@testing-library/jest-dom": "^6.6.3",
+    "jsdom": "^25.0.1",
+    "typescript": "^5.7.2",
+    "vite": "^6.0.0",
+    "vite-plugin-solid": "2.11.2",
+    "vitest": "^3.0.0"
+  },
+  "dependencies": {
+    "@protobuf-ts/grpcweb-transport": "^2.11.0",
+    "@protobuf-ts/runtime": "^2.11.0",
+    "@protobuf-ts/runtime-rpc": "^2.11.0",
+    "solid-js": "^1.9.5"
+  }
+}
+```
+
+## 📄 vite.config.ts
+```ts
+import { defineConfig } from 'vite';
+import solid from 'vite-plugin-solid';
+
+export default defineConfig({
+  plugins: [solid()],
+  server: {
+    port: 3000,
+    proxy: {
+      // Proxy pour gRPC-Web - redirige vers votre serveur Rust
+      '/takeiteasygame.v1.SessionService': {
+        target: 'http://localhost:50051',
+        changeOrigin: true,
+        headers: {
+          'Content-Type': 'application/grpc-web+proto'
+        }
+      },
+      '/takeiteasygame.v1.GameService': {
+        target: 'http://localhost:50051',
+        changeOrigin: true,
+        headers: {
+          'Content-Type': 'application/grpc-web+proto'
+        }
+      }
+    }
+  },
+  define: {
+    // Variables d'environnement pour le développement
+    __GRPC_WEB_ENDPOINT__: JSON.stringify('http://localhost:50051'),
+  },
+  optimizeDeps: {
+    // Inclure les dépendances gRPC-Web dans l'optimisation
+    include: [
+      '@protobuf-ts/runtime',
+      '@protobuf-ts/runtime-rpc',
+      '@protobuf-ts/grpcweb-transport'
+    ]
+  }
+});```
+
+## 📄 tsconfig.json
+```json
+{
+  "compilerOptions": {
+    "strict": true,
+    "target": "ESNext",
+    "module": "ESNext",
+    "moduleResolution": "node",
+    "allowSyntheticDefaultImports": true,
+    "esModuleInterop": true,
+    "jsx": "preserve",
+    "jsxImportSource": "solid-js",
+    "types": ["vite/client", "@testing-library/jest-dom"]
+  }
+}
+```
+
+## 📄 src/todo-list.tsx
+```tsx
+import { For } from 'solid-js';
+import { createStore } from 'solid-js/store';
+
+type Todo = { id: number; text: string; completed: boolean };
+
+export const TodoList = () => {
+  let input!: HTMLInputElement;
+  const [todos, setTodos] = createStore<Todo[]>([]);
+  const addTodo = (text: string) => {
+    setTodos(todos.length, { id: todos.length, text, completed: false });
+  };
+  const toggleTodo = (id: number) => {
+    setTodos(id, 'completed', (c) => !c);
+  };
+
+  return (
+    <>
+      <div>
+        <input placeholder="new todo here" ref={input} />
+        <button
+          onClick={() => {
+            if (!input.value.trim()) return;
+            addTodo(input.value);
+            input.value = '';
+          }}
+        >
+          Add Todo
+        </button>
+      </div>
+      <div>
+        <For each={todos}>
+          {(todo) => {
+            const { id, text } = todo;
+            return (
+              <div>
+                <input
+                  type="checkbox"
+                  checked={todo.completed}
+                  onchange={[toggleTodo, id]}
+                />
+                <span
+                  style={{
+                    'text-decoration': todo.completed ? 'line-through' : 'none',
+                  }}
+                >
+                  {text}
+                </span>
+              </div>
+            );
+          }}
+        </For>
+      </div>
+    </>
+  );
+};
+```
+
+## 📄 src/generated/session_service.client.ts
+```ts
+// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
+// tslint:disable
+import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
+import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
+import { SessionService } from "./session_service";
+import type { GetSessionStateResponse } from "./session_service";
+import type { GetSessionStateRequest } from "./session_service";
+import type { SetReadyResponse } from "./session_service";
+import type { SetReadyRequest } from "./session_service";
+import type { JoinSessionResponse } from "./session_service";
+import type { JoinSessionRequest } from "./session_service";
+import { stackIntercept } from "@protobuf-ts/runtime-rpc";
+import type { CreateSessionResponse } from "./session_service";
+import type { CreateSessionRequest } from "./session_service";
+import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
+import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
+/**
+ * @generated from protobuf service takeiteasygame.v1.SessionService
+ */
+export interface ISessionServiceClient {
+    /**
+     * @generated from protobuf rpc: CreateSession
+     */
+    createSession(input: CreateSessionRequest, options?: RpcOptions): UnaryCall<CreateSessionRequest, CreateSessionResponse>;
+    /**
+     * @generated from protobuf rpc: JoinSession
+     */
+    joinSession(input: JoinSessionRequest, options?: RpcOptions): UnaryCall<JoinSessionRequest, JoinSessionResponse>;
+    /**
+     * @generated from protobuf rpc: SetReady
+     */
+    setReady(input: SetReadyRequest, options?: RpcOptions): UnaryCall<SetReadyRequest, SetReadyResponse>;
+    /**
+     * @generated from protobuf rpc: GetSessionState
+     */
+    getSessionState(input: GetSessionStateRequest, options?: RpcOptions): UnaryCall<GetSessionStateRequest, GetSessionStateResponse>;
+}
+/**
+ * @generated from protobuf service takeiteasygame.v1.SessionService
+ */
+export class SessionServiceClient implements ISessionServiceClient, ServiceInfo {
+    typeName = SessionService.typeName;
+    methods = SessionService.methods;
+    options = SessionService.options;
+    constructor(private readonly _transport: RpcTransport) {
+    }
+    /**
+     * @generated from protobuf rpc: CreateSession
+     */
+    createSession(input: CreateSessionRequest, options?: RpcOptions): UnaryCall<CreateSessionRequest, CreateSessionResponse> {
+        const method = this.methods[0], opt = this._transport.mergeOptions(options);
+        return stackIntercept<CreateSessionRequest, CreateSessionResponse>("unary", this._transport, method, opt, input);
+    }
+    /**
+     * @generated from protobuf rpc: JoinSession
+     */
+    joinSession(input: JoinSessionRequest, options?: RpcOptions): UnaryCall<JoinSessionRequest, JoinSessionResponse> {
+        const method = this.methods[1], opt = this._transport.mergeOptions(options);
+        return stackIntercept<JoinSessionRequest, JoinSessionResponse>("unary", this._transport, method, opt, input);
+    }
+    /**
+     * @generated from protobuf rpc: SetReady
+     */
+    setReady(input: SetReadyRequest, options?: RpcOptions): UnaryCall<SetReadyRequest, SetReadyResponse> {
+        const method = this.methods[2], opt = this._transport.mergeOptions(options);
+        return stackIntercept<SetReadyRequest, SetReadyResponse>("unary", this._transport, method, opt, input);
+    }
+    /**
+     * @generated from protobuf rpc: GetSessionState
+     */
+    getSessionState(input: GetSessionStateRequest, options?: RpcOptions): UnaryCall<GetSessionStateRequest, GetSessionStateResponse> {
+        const method = this.methods[3], opt = this._transport.mergeOptions(options);
+        return stackIntercept<GetSessionStateRequest, GetSessionStateResponse>("unary", this._transport, method, opt, input);
+    }
+}
+```
+
+## 📄 src/generated/game_service.ts
+```ts
+// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
+// tslint:disable
+import { ServiceType } from "@protobuf-ts/runtime-rpc";
+import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
+import type { IBinaryWriter } from "@protobuf-ts/runtime";
+import { WireType } from "@protobuf-ts/runtime";
+import type { BinaryReadOptions } from "@protobuf-ts/runtime";
+import type { IBinaryReader } from "@protobuf-ts/runtime";
+import { UnknownFieldHandler } from "@protobuf-ts/runtime";
+import type { PartialMessage } from "@protobuf-ts/runtime";
+import { reflectionMergePartial } from "@protobuf-ts/runtime";
+import { MessageType } from "@protobuf-ts/runtime";
+import { GameState } from "./common";
+import { Error } from "./common";
+/**
+ * @generated from protobuf message takeiteasygame.v1.MakeMoveRequest
+ */
+export interface MakeMoveRequest {
+    /**
+     * @generated from protobuf field: string session_id = 1
+     */
+    sessionId: string;
+    /**
+     * @generated from protobuf field: string player_id = 2
+     */
+    playerId: string;
+    /**
+     * @generated from protobuf field: string move_data = 3
+     */
+    moveData: string; // JSON du mouvement
+    /**
+     * @generated from protobuf field: int64 timestamp = 4
+     */
+    timestamp: bigint;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.MakeMoveResponse
+ */
+export interface MakeMoveResponse {
+    /**
+     * @generated from protobuf oneof: result
+     */
+    result: {
+        oneofKind: "success";
+        /**
+         * @generated from protobuf field: takeiteasygame.v1.MakeMoveSuccess success = 1
+         */
+        success: MakeMoveSuccess;
+    } | {
+        oneofKind: "error";
+        /**
+         * @generated from protobuf field: takeiteasygame.v1.Error error = 2
+         */
+        error: Error;
+    } | {
+        oneofKind: undefined;
+    };
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.MakeMoveSuccess
+ */
+export interface MakeMoveSuccess {
+    /**
+     * @generated from protobuf field: takeiteasygame.v1.GameState new_game_state = 1
+     */
+    newGameState?: GameState;
+    /**
+     * @generated from protobuf field: string mcts_response = 2
+     */
+    mctsResponse: string; // Réponse de l'IA si applicable
+    /**
+     * @generated from protobuf field: int32 points_earned = 3
+     */
+    pointsEarned: number;
+    /**
+     * @generated from protobuf field: bool is_game_over = 4
+     */
+    isGameOver: boolean;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.GetAvailableMovesRequest
+ */
+export interface GetAvailableMovesRequest {
+    /**
+     * @generated from protobuf field: string session_id = 1
+     */
+    sessionId: string;
+    /**
+     * @generated from protobuf field: string player_id = 2
+     */
+    playerId: string;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.GetAvailableMovesResponse
+ */
+export interface GetAvailableMovesResponse {
+    /**
+     * @generated from protobuf field: repeated string available_moves = 1
+     */
+    availableMoves: string[]; // JSON des mouvements possibles
+    /**
+     * @generated from protobuf field: takeiteasygame.v1.Error error = 2
+     */
+    error?: Error;
+}
+// @generated message type with reflection information, may provide speed optimized methods
+class MakeMoveRequest$Type extends MessageType<MakeMoveRequest> {
+    constructor() {
+        super("takeiteasygame.v1.MakeMoveRequest", [
+            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 3, name: "move_data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 4, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
+        ]);
+    }
+    create(value?: PartialMessage<MakeMoveRequest>): MakeMoveRequest {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.sessionId = "";
+        message.playerId = "";
+        message.moveData = "";
+        message.timestamp = 0n;
+        if (value !== undefined)
+            reflectionMergePartial<MakeMoveRequest>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveRequest): MakeMoveRequest {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string session_id */ 1:
+                    message.sessionId = reader.string();
+                    break;
+                case /* string player_id */ 2:
+                    message.playerId = reader.string();
+                    break;
+                case /* string move_data */ 3:
+                    message.moveData = reader.string();
+                    break;
+                case /* int64 timestamp */ 4:
+                    message.timestamp = reader.int64().toBigInt();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: MakeMoveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string session_id = 1; */
+        if (message.sessionId !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
+        /* string player_id = 2; */
+        if (message.playerId !== "")
+            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
+        /* string move_data = 3; */
+        if (message.moveData !== "")
+            writer.tag(3, WireType.LengthDelimited).string(message.moveData);
+        /* int64 timestamp = 4; */
+        if (message.timestamp !== 0n)
+            writer.tag(4, WireType.Varint).int64(message.timestamp);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveRequest
+ */
+export const MakeMoveRequest = new MakeMoveRequest$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class MakeMoveResponse$Type extends MessageType<MakeMoveResponse> {
+    constructor() {
+        super("takeiteasygame.v1.MakeMoveResponse", [
+            { no: 1, name: "success", kind: "message", oneof: "result", T: () => MakeMoveSuccess },
+            { no: 2, name: "error", kind: "message", oneof: "result", T: () => Error }
+        ]);
+    }
+    create(value?: PartialMessage<MakeMoveResponse>): MakeMoveResponse {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.result = { oneofKind: undefined };
+        if (value !== undefined)
+            reflectionMergePartial<MakeMoveResponse>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveResponse): MakeMoveResponse {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* takeiteasygame.v1.MakeMoveSuccess success */ 1:
+                    message.result = {
+                        oneofKind: "success",
+                        success: MakeMoveSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
+                    };
+                    break;
+                case /* takeiteasygame.v1.Error error */ 2:
+                    message.result = {
+                        oneofKind: "error",
+                        error: Error.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
+                    };
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: MakeMoveResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* takeiteasygame.v1.MakeMoveSuccess success = 1; */
+        if (message.result.oneofKind === "success")
+            MakeMoveSuccess.internalBinaryWrite(message.result.success, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
+        /* takeiteasygame.v1.Error error = 2; */
+        if (message.result.oneofKind === "error")
+            Error.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveResponse
+ */
+export const MakeMoveResponse = new MakeMoveResponse$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class MakeMoveSuccess$Type extends MessageType<MakeMoveSuccess> {
+    constructor() {
+        super("takeiteasygame.v1.MakeMoveSuccess", [
+            { no: 1, name: "new_game_state", kind: "message", T: () => GameState },
+            { no: 2, name: "mcts_response", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 3, name: "points_earned", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
+            { no: 4, name: "is_game_over", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
+        ]);
+    }
+    create(value?: PartialMessage<MakeMoveSuccess>): MakeMoveSuccess {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.mctsResponse = "";
+        message.pointsEarned = 0;
+        message.isGameOver = false;
+        if (value !== undefined)
+            reflectionMergePartial<MakeMoveSuccess>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakeMoveSuccess): MakeMoveSuccess {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* takeiteasygame.v1.GameState new_game_state */ 1:
+                    message.newGameState = GameState.internalBinaryRead(reader, reader.uint32(), options, message.newGameState);
+                    break;
+                case /* string mcts_response */ 2:
+                    message.mctsResponse = reader.string();
+                    break;
+                case /* int32 points_earned */ 3:
+                    message.pointsEarned = reader.int32();
+                    break;
+                case /* bool is_game_over */ 4:
+                    message.isGameOver = reader.bool();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: MakeMoveSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* takeiteasygame.v1.GameState new_game_state = 1; */
+        if (message.newGameState)
+            GameState.internalBinaryWrite(message.newGameState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
+        /* string mcts_response = 2; */
+        if (message.mctsResponse !== "")
+            writer.tag(2, WireType.LengthDelimited).string(message.mctsResponse);
+        /* int32 points_earned = 3; */
+        if (message.pointsEarned !== 0)
+            writer.tag(3, WireType.Varint).int32(message.pointsEarned);
+        /* bool is_game_over = 4; */
+        if (message.isGameOver !== false)
+            writer.tag(4, WireType.Varint).bool(message.isGameOver);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.MakeMoveSuccess
+ */
+export const MakeMoveSuccess = new MakeMoveSuccess$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class GetAvailableMovesRequest$Type extends MessageType<GetAvailableMovesRequest> {
+    constructor() {
+        super("takeiteasygame.v1.GetAvailableMovesRequest", [
+            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
+        ]);
+    }
+    create(value?: PartialMessage<GetAvailableMovesRequest>): GetAvailableMovesRequest {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.sessionId = "";
+        message.playerId = "";
+        if (value !== undefined)
+            reflectionMergePartial<GetAvailableMovesRequest>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAvailableMovesRequest): GetAvailableMovesRequest {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string session_id */ 1:
+                    message.sessionId = reader.string();
+                    break;
+                case /* string player_id */ 2:
+                    message.playerId = reader.string();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: GetAvailableMovesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string session_id = 1; */
+        if (message.sessionId !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
+        /* string player_id = 2; */
+        if (message.playerId !== "")
+            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.GetAvailableMovesRequest
+ */
+export const GetAvailableMovesRequest = new GetAvailableMovesRequest$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class GetAvailableMovesResponse$Type extends MessageType<GetAvailableMovesResponse> {
+    constructor() {
+        super("takeiteasygame.v1.GetAvailableMovesResponse", [
+            { no: 1, name: "available_moves", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
+            { no: 2, name: "error", kind: "message", T: () => Error }
+        ]);
+    }
+    create(value?: PartialMessage<GetAvailableMovesResponse>): GetAvailableMovesResponse {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.availableMoves = [];
+        if (value !== undefined)
+            reflectionMergePartial<GetAvailableMovesResponse>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAvailableMovesResponse): GetAvailableMovesResponse {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* repeated string available_moves */ 1:
+                    message.availableMoves.push(reader.string());
+                    break;
+                case /* takeiteasygame.v1.Error error */ 2:
+                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: GetAvailableMovesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* repeated string available_moves = 1; */
+        for (let i = 0; i < message.availableMoves.length; i++)
+            writer.tag(1, WireType.LengthDelimited).string(message.availableMoves[i]);
+        /* takeiteasygame.v1.Error error = 2; */
+        if (message.error)
+            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.GetAvailableMovesResponse
+ */
+export const GetAvailableMovesResponse = new GetAvailableMovesResponse$Type();
+/**
+ * @generated ServiceType for protobuf service takeiteasygame.v1.GameService
+ */
+export const GameService = new ServiceType("takeiteasygame.v1.GameService", [
+    { name: "MakeMove", options: {}, I: MakeMoveRequest, O: MakeMoveResponse },
+    { name: "GetAvailableMoves", options: {}, I: GetAvailableMovesRequest, O: GetAvailableMovesResponse }
+]);
+```
+
+## 📄 src/generated/session_service.ts
+```ts
+// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
+// tslint:disable
+import { ServiceType } from "@protobuf-ts/runtime-rpc";
+import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
+import type { IBinaryWriter } from "@protobuf-ts/runtime";
+import { WireType } from "@protobuf-ts/runtime";
+import type { BinaryReadOptions } from "@protobuf-ts/runtime";
+import type { IBinaryReader } from "@protobuf-ts/runtime";
+import { UnknownFieldHandler } from "@protobuf-ts/runtime";
+import type { PartialMessage } from "@protobuf-ts/runtime";
+import { reflectionMergePartial } from "@protobuf-ts/runtime";
+import { MessageType } from "@protobuf-ts/runtime";
+import { GameState } from "./common";
+import { Error } from "./common";
+import { Player } from "./common";
+// ============================================================================
+// MESSAGES SESSION SERVICE
+// ============================================================================
+
+/**
+ * @generated from protobuf message takeiteasygame.v1.CreateSessionRequest
+ */
+export interface CreateSessionRequest {
+    /**
+     * @generated from protobuf field: string player_name = 1
+     */
+    playerName: string;
+    /**
+     * @generated from protobuf field: int32 max_players = 2
+     */
+    maxPlayers: number;
+    /**
+     * @generated from protobuf field: string game_mode = 3
+     */
+    gameMode: string;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.CreateSessionSuccess
+ */
+export interface CreateSessionSuccess {
+    /**
+     * @generated from protobuf field: string session_code = 1
+     */
+    sessionCode: string;
+    /**
+     * @generated from protobuf field: string session_id = 2
+     */
+    sessionId: string;
+    /**
+     * @generated from protobuf field: string player_id = 3
+     */
+    playerId: string;
+    /**
+     * @generated from protobuf field: takeiteasygame.v1.Player player = 4
+     */
+    player?: Player;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.CreateSessionResponse
+ */
+export interface CreateSessionResponse {
+    /**
+     * @generated from protobuf oneof: result
+     */
+    result: {
+        oneofKind: "success";
+        /**
+         * @generated from protobuf field: takeiteasygame.v1.CreateSessionSuccess success = 1
+         */
+        success: CreateSessionSuccess;
+    } | {
+        oneofKind: "error";
+        /**
+         * @generated from protobuf field: takeiteasygame.v1.Error error = 2
+         */
+        error: Error;
+    } | {
+        oneofKind: undefined;
+    };
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.JoinSessionRequest
+ */
+export interface JoinSessionRequest {
+    /**
+     * @generated from protobuf field: string session_code = 1
+     */
+    sessionCode: string;
+    /**
+     * @generated from protobuf field: string player_name = 2
+     */
+    playerName: string;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.JoinSessionSuccess
+ */
+export interface JoinSessionSuccess {
+    /**
+     * @generated from protobuf field: string session_id = 1
+     */
+    sessionId: string;
+    /**
+     * @generated from protobuf field: string player_id = 2
+     */
+    playerId: string;
+    /**
+     * @generated from protobuf field: takeiteasygame.v1.GameState game_state = 3
+     */
+    gameState?: GameState;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.JoinSessionResponse
+ */
+export interface JoinSessionResponse {
+    /**
+     * @generated from protobuf oneof: result
+     */
+    result: {
+        oneofKind: "success";
+        /**
+         * @generated from protobuf field: takeiteasygame.v1.JoinSessionSuccess success = 1
+         */
+        success: JoinSessionSuccess;
+    } | {
+        oneofKind: "error";
+        /**
+         * @generated from protobuf field: takeiteasygame.v1.Error error = 2
+         */
+        error: Error;
+    } | {
+        oneofKind: undefined;
+    };
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.SetReadyRequest
+ */
+export interface SetReadyRequest {
+    /**
+     * @generated from protobuf field: string session_id = 1
+     */
+    sessionId: string;
+    /**
+     * @generated from protobuf field: string player_id = 2
+     */
+    playerId: string;
+    /**
+     * @generated from protobuf field: bool ready = 3
+     */
+    ready: boolean;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.SetReadyResponse
+ */
+export interface SetReadyResponse {
+    /**
+     * @generated from protobuf field: bool success = 1
+     */
+    success: boolean;
+    /**
+     * @generated from protobuf field: takeiteasygame.v1.Error error = 2
+     */
+    error?: Error;
+    /**
+     * @generated from protobuf field: bool game_started = 3
+     */
+    gameStarted: boolean;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.GetSessionStateRequest
+ */
+export interface GetSessionStateRequest {
+    /**
+     * @generated from protobuf field: string session_id = 1
+     */
+    sessionId: string;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.GetSessionStateResponse
+ */
+export interface GetSessionStateResponse {
+    /**
+     * @generated from protobuf field: takeiteasygame.v1.GameState game_state = 1
+     */
+    gameState?: GameState;
+    /**
+     * @generated from protobuf field: takeiteasygame.v1.Error error = 2
+     */
+    error?: Error;
+}
+// @generated message type with reflection information, may provide speed optimized methods
+class CreateSessionRequest$Type extends MessageType<CreateSessionRequest> {
+    constructor() {
+        super("takeiteasygame.v1.CreateSessionRequest", [
+            { no: 1, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 2, name: "max_players", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
+            { no: 3, name: "game_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
+        ]);
+    }
+    create(value?: PartialMessage<CreateSessionRequest>): CreateSessionRequest {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.playerName = "";
+        message.maxPlayers = 0;
+        message.gameMode = "";
+        if (value !== undefined)
+            reflectionMergePartial<CreateSessionRequest>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionRequest): CreateSessionRequest {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string player_name */ 1:
+                    message.playerName = reader.string();
+                    break;
+                case /* int32 max_players */ 2:
+                    message.maxPlayers = reader.int32();
+                    break;
+                case /* string game_mode */ 3:
+                    message.gameMode = reader.string();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: CreateSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string player_name = 1; */
+        if (message.playerName !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.playerName);
+        /* int32 max_players = 2; */
+        if (message.maxPlayers !== 0)
+            writer.tag(2, WireType.Varint).int32(message.maxPlayers);
+        /* string game_mode = 3; */
+        if (message.gameMode !== "")
+            writer.tag(3, WireType.LengthDelimited).string(message.gameMode);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.CreateSessionRequest
+ */
+export const CreateSessionRequest = new CreateSessionRequest$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class CreateSessionSuccess$Type extends MessageType<CreateSessionSuccess> {
+    constructor() {
+        super("takeiteasygame.v1.CreateSessionSuccess", [
+            { no: 1, name: "session_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 2, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 3, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 4, name: "player", kind: "message", T: () => Player }
+        ]);
+    }
+    create(value?: PartialMessage<CreateSessionSuccess>): CreateSessionSuccess {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.sessionCode = "";
+        message.sessionId = "";
+        message.playerId = "";
+        if (value !== undefined)
+            reflectionMergePartial<CreateSessionSuccess>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionSuccess): CreateSessionSuccess {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string session_code */ 1:
+                    message.sessionCode = reader.string();
+                    break;
+                case /* string session_id */ 2:
+                    message.sessionId = reader.string();
+                    break;
+                case /* string player_id */ 3:
+                    message.playerId = reader.string();
+                    break;
+                case /* takeiteasygame.v1.Player player */ 4:
+                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: CreateSessionSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string session_code = 1; */
+        if (message.sessionCode !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.sessionCode);
+        /* string session_id = 2; */
+        if (message.sessionId !== "")
+            writer.tag(2, WireType.LengthDelimited).string(message.sessionId);
+        /* string player_id = 3; */
+        if (message.playerId !== "")
+            writer.tag(3, WireType.LengthDelimited).string(message.playerId);
+        /* takeiteasygame.v1.Player player = 4; */
+        if (message.player)
+            Player.internalBinaryWrite(message.player, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.CreateSessionSuccess
+ */
+export const CreateSessionSuccess = new CreateSessionSuccess$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class CreateSessionResponse$Type extends MessageType<CreateSessionResponse> {
+    constructor() {
+        super("takeiteasygame.v1.CreateSessionResponse", [
+            { no: 1, name: "success", kind: "message", oneof: "result", T: () => CreateSessionSuccess },
+            { no: 2, name: "error", kind: "message", oneof: "result", T: () => Error }
+        ]);
+    }
+    create(value?: PartialMessage<CreateSessionResponse>): CreateSessionResponse {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.result = { oneofKind: undefined };
+        if (value !== undefined)
+            reflectionMergePartial<CreateSessionResponse>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSessionResponse): CreateSessionResponse {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* takeiteasygame.v1.CreateSessionSuccess success */ 1:
+                    message.result = {
+                        oneofKind: "success",
+                        success: CreateSessionSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
+                    };
+                    break;
+                case /* takeiteasygame.v1.Error error */ 2:
+                    message.result = {
+                        oneofKind: "error",
+                        error: Error.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
+                    };
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: CreateSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* takeiteasygame.v1.CreateSessionSuccess success = 1; */
+        if (message.result.oneofKind === "success")
+            CreateSessionSuccess.internalBinaryWrite(message.result.success, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
+        /* takeiteasygame.v1.Error error = 2; */
+        if (message.result.oneofKind === "error")
+            Error.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.CreateSessionResponse
+ */
+export const CreateSessionResponse = new CreateSessionResponse$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class JoinSessionRequest$Type extends MessageType<JoinSessionRequest> {
+    constructor() {
+        super("takeiteasygame.v1.JoinSessionRequest", [
+            { no: 1, name: "session_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 2, name: "player_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
+        ]);
+    }
+    create(value?: PartialMessage<JoinSessionRequest>): JoinSessionRequest {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.sessionCode = "";
+        message.playerName = "";
+        if (value !== undefined)
+            reflectionMergePartial<JoinSessionRequest>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinSessionRequest): JoinSessionRequest {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string session_code */ 1:
+                    message.sessionCode = reader.string();
+                    break;
+                case /* string player_name */ 2:
+                    message.playerName = reader.string();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: JoinSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string session_code = 1; */
+        if (message.sessionCode !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.sessionCode);
+        /* string player_name = 2; */
+        if (message.playerName !== "")
+            writer.tag(2, WireType.LengthDelimited).string(message.playerName);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.JoinSessionRequest
+ */
+export const JoinSessionRequest = new JoinSessionRequest$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class JoinSessionSuccess$Type extends MessageType<JoinSessionSuccess> {
+    constructor() {
+        super("takeiteasygame.v1.JoinSessionSuccess", [
+            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 3, name: "game_state", kind: "message", T: () => GameState }
+        ]);
+    }
+    create(value?: PartialMessage<JoinSessionSuccess>): JoinSessionSuccess {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.sessionId = "";
+        message.playerId = "";
+        if (value !== undefined)
+            reflectionMergePartial<JoinSessionSuccess>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinSessionSuccess): JoinSessionSuccess {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string session_id */ 1:
+                    message.sessionId = reader.string();
+                    break;
+                case /* string player_id */ 2:
+                    message.playerId = reader.string();
+                    break;
+                case /* takeiteasygame.v1.GameState game_state */ 3:
+                    message.gameState = GameState.internalBinaryRead(reader, reader.uint32(), options, message.gameState);
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: JoinSessionSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string session_id = 1; */
+        if (message.sessionId !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
+        /* string player_id = 2; */
+        if (message.playerId !== "")
+            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
+        /* takeiteasygame.v1.GameState game_state = 3; */
+        if (message.gameState)
+            GameState.internalBinaryWrite(message.gameState, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.JoinSessionSuccess
+ */
+export const JoinSessionSuccess = new JoinSessionSuccess$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class JoinSessionResponse$Type extends MessageType<JoinSessionResponse> {
+    constructor() {
+        super("takeiteasygame.v1.JoinSessionResponse", [
+            { no: 1, name: "success", kind: "message", oneof: "result", T: () => JoinSessionSuccess },
+            { no: 2, name: "error", kind: "message", oneof: "result", T: () => Error }
+        ]);
+    }
+    create(value?: PartialMessage<JoinSessionResponse>): JoinSessionResponse {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.result = { oneofKind: undefined };
+        if (value !== undefined)
+            reflectionMergePartial<JoinSessionResponse>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinSessionResponse): JoinSessionResponse {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* takeiteasygame.v1.JoinSessionSuccess success */ 1:
+                    message.result = {
+                        oneofKind: "success",
+                        success: JoinSessionSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).success)
+                    };
+                    break;
+                case /* takeiteasygame.v1.Error error */ 2:
+                    message.result = {
+                        oneofKind: "error",
+                        error: Error.internalBinaryRead(reader, reader.uint32(), options, (message.result as any).error)
+                    };
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: JoinSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* takeiteasygame.v1.JoinSessionSuccess success = 1; */
+        if (message.result.oneofKind === "success")
+            JoinSessionSuccess.internalBinaryWrite(message.result.success, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
+        /* takeiteasygame.v1.Error error = 2; */
+        if (message.result.oneofKind === "error")
+            Error.internalBinaryWrite(message.result.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.JoinSessionResponse
+ */
+export const JoinSessionResponse = new JoinSessionResponse$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class SetReadyRequest$Type extends MessageType<SetReadyRequest> {
+    constructor() {
+        super("takeiteasygame.v1.SetReadyRequest", [
+            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 2, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 3, name: "ready", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
+        ]);
+    }
+    create(value?: PartialMessage<SetReadyRequest>): SetReadyRequest {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.sessionId = "";
+        message.playerId = "";
+        message.ready = false;
+        if (value !== undefined)
+            reflectionMergePartial<SetReadyRequest>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReadyRequest): SetReadyRequest {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string session_id */ 1:
+                    message.sessionId = reader.string();
+                    break;
+                case /* string player_id */ 2:
+                    message.playerId = reader.string();
+                    break;
+                case /* bool ready */ 3:
+                    message.ready = reader.bool();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: SetReadyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string session_id = 1; */
+        if (message.sessionId !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
+        /* string player_id = 2; */
+        if (message.playerId !== "")
+            writer.tag(2, WireType.LengthDelimited).string(message.playerId);
+        /* bool ready = 3; */
+        if (message.ready !== false)
+            writer.tag(3, WireType.Varint).bool(message.ready);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.SetReadyRequest
+ */
+export const SetReadyRequest = new SetReadyRequest$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class SetReadyResponse$Type extends MessageType<SetReadyResponse> {
+    constructor() {
+        super("takeiteasygame.v1.SetReadyResponse", [
+            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
+            { no: 2, name: "error", kind: "message", T: () => Error },
+            { no: 3, name: "game_started", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
+        ]);
+    }
+    create(value?: PartialMessage<SetReadyResponse>): SetReadyResponse {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.success = false;
+        message.gameStarted = false;
+        if (value !== undefined)
+            reflectionMergePartial<SetReadyResponse>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReadyResponse): SetReadyResponse {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* bool success */ 1:
+                    message.success = reader.bool();
+                    break;
+                case /* takeiteasygame.v1.Error error */ 2:
+                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
+                    break;
+                case /* bool game_started */ 3:
+                    message.gameStarted = reader.bool();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: SetReadyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* bool success = 1; */
+        if (message.success !== false)
+            writer.tag(1, WireType.Varint).bool(message.success);
+        /* takeiteasygame.v1.Error error = 2; */
+        if (message.error)
+            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
+        /* bool game_started = 3; */
+        if (message.gameStarted !== false)
+            writer.tag(3, WireType.Varint).bool(message.gameStarted);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.SetReadyResponse
+ */
+export const SetReadyResponse = new SetReadyResponse$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class GetSessionStateRequest$Type extends MessageType<GetSessionStateRequest> {
+    constructor() {
+        super("takeiteasygame.v1.GetSessionStateRequest", [
+            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
+        ]);
+    }
+    create(value?: PartialMessage<GetSessionStateRequest>): GetSessionStateRequest {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.sessionId = "";
+        if (value !== undefined)
+            reflectionMergePartial<GetSessionStateRequest>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSessionStateRequest): GetSessionStateRequest {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string session_id */ 1:
+                    message.sessionId = reader.string();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: GetSessionStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string session_id = 1; */
+        if (message.sessionId !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.GetSessionStateRequest
+ */
+export const GetSessionStateRequest = new GetSessionStateRequest$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class GetSessionStateResponse$Type extends MessageType<GetSessionStateResponse> {
+    constructor() {
+        super("takeiteasygame.v1.GetSessionStateResponse", [
+            { no: 1, name: "game_state", kind: "message", T: () => GameState },
+            { no: 2, name: "error", kind: "message", T: () => Error }
+        ]);
+    }
+    create(value?: PartialMessage<GetSessionStateResponse>): GetSessionStateResponse {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        if (value !== undefined)
+            reflectionMergePartial<GetSessionStateResponse>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSessionStateResponse): GetSessionStateResponse {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* takeiteasygame.v1.GameState game_state */ 1:
+                    message.gameState = GameState.internalBinaryRead(reader, reader.uint32(), options, message.gameState);
+                    break;
+                case /* takeiteasygame.v1.Error error */ 2:
+                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: GetSessionStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* takeiteasygame.v1.GameState game_state = 1; */
+        if (message.gameState)
+            GameState.internalBinaryWrite(message.gameState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
+        /* takeiteasygame.v1.Error error = 2; */
+        if (message.error)
+            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.GetSessionStateResponse
+ */
+export const GetSessionStateResponse = new GetSessionStateResponse$Type();
+/**
+ * @generated ServiceType for protobuf service takeiteasygame.v1.SessionService
+ */
+export const SessionService = new ServiceType("takeiteasygame.v1.SessionService", [
+    { name: "CreateSession", options: {}, I: CreateSessionRequest, O: CreateSessionResponse },
+    { name: "JoinSession", options: {}, I: JoinSessionRequest, O: JoinSessionResponse },
+    { name: "SetReady", options: {}, I: SetReadyRequest, O: SetReadyResponse },
+    { name: "GetSessionState", options: {}, I: GetSessionStateRequest, O: GetSessionStateResponse }
+]);
+```
+
+## 📄 src/generated/common.ts
+```ts
+// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated from protobuf file "common.proto" (package "takeiteasygame.v1", syntax proto3)
+// tslint:disable
+import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
+import type { IBinaryWriter } from "@protobuf-ts/runtime";
+import { WireType } from "@protobuf-ts/runtime";
+import type { BinaryReadOptions } from "@protobuf-ts/runtime";
+import type { IBinaryReader } from "@protobuf-ts/runtime";
+import { UnknownFieldHandler } from "@protobuf-ts/runtime";
+import type { PartialMessage } from "@protobuf-ts/runtime";
+import { reflectionMergePartial } from "@protobuf-ts/runtime";
+import { MessageType } from "@protobuf-ts/runtime";
+/**
+ * Types communs partagés entre services
+ *
+ * @generated from protobuf message takeiteasygame.v1.Player
+ */
+export interface Player {
+    /**
+     * @generated from protobuf field: string id = 1
+     */
+    id: string;
+    /**
+     * @generated from protobuf field: string name = 2
+     */
+    name: string;
+    /**
+     * @generated from protobuf field: int32 score = 3
+     */
+    score: number;
+    /**
+     * @generated from protobuf field: bool is_ready = 4
+     */
+    isReady: boolean;
+    /**
+     * @generated from protobuf field: bool is_connected = 5
+     */
+    isConnected: boolean;
+    /**
+     * @generated from protobuf field: int64 joined_at = 6
+     */
+    joinedAt: bigint;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.GameState
+ */
+export interface GameState {
+    /**
+     * @generated from protobuf field: string session_id = 1
+     */
+    sessionId: string;
+    /**
+     * @generated from protobuf field: repeated takeiteasygame.v1.Player players = 2
+     */
+    players: Player[];
+    /**
+     * @generated from protobuf field: string current_player_id = 3
+     */
+    currentPlayerId: string;
+    /**
+     * @generated from protobuf field: takeiteasygame.v1.SessionState state = 4
+     */
+    state: SessionState;
+    /**
+     * @generated from protobuf field: string board_state = 5
+     */
+    boardState: string; // JSON serialized board
+    /**
+     * @generated from protobuf field: int32 turn_number = 6
+     */
+    turnNumber: number;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.Error
+ */
+export interface Error {
+    /**
+     * @generated from protobuf field: string code = 1
+     */
+    code: string;
+    /**
+     * @generated from protobuf field: string message = 2
+     */
+    message: string;
+    /**
+     * @generated from protobuf field: map<string, string> details = 3
+     */
+    details: {
+        [key: string]: string;
+    };
+}
+/**
+ * @generated from protobuf enum takeiteasygame.v1.SessionState
+ */
+export enum SessionState {
+    /**
+     * @generated from protobuf enum value: WAITING = 0;
+     */
+    WAITING = 0,
+    /**
+     * @generated from protobuf enum value: IN_PROGRESS = 1;
+     */
+    IN_PROGRESS = 1,
+    /**
+     * @generated from protobuf enum value: FINISHED = 2;
+     */
+    FINISHED = 2,
+    /**
+     * @generated from protobuf enum value: CANCELLED = 3;
+     */
+    CANCELLED = 3
+}
+// @generated message type with reflection information, may provide speed optimized methods
+class Player$Type extends MessageType<Player> {
+    constructor() {
+        super("takeiteasygame.v1.Player", [
+            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 3, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
+            { no: 4, name: "is_ready", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
+            { no: 5, name: "is_connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
+            { no: 6, name: "joined_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
+        ]);
+    }
+    create(value?: PartialMessage<Player>): Player {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.id = "";
+        message.name = "";
+        message.score = 0;
+        message.isReady = false;
+        message.isConnected = false;
+        message.joinedAt = 0n;
+        if (value !== undefined)
+            reflectionMergePartial<Player>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Player): Player {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string id */ 1:
+                    message.id = reader.string();
+                    break;
+                case /* string name */ 2:
+                    message.name = reader.string();
+                    break;
+                case /* int32 score */ 3:
+                    message.score = reader.int32();
+                    break;
+                case /* bool is_ready */ 4:
+                    message.isReady = reader.bool();
+                    break;
+                case /* bool is_connected */ 5:
+                    message.isConnected = reader.bool();
+                    break;
+                case /* int64 joined_at */ 6:
+                    message.joinedAt = reader.int64().toBigInt();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string id = 1; */
+        if (message.id !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.id);
+        /* string name = 2; */
+        if (message.name !== "")
+            writer.tag(2, WireType.LengthDelimited).string(message.name);
+        /* int32 score = 3; */
+        if (message.score !== 0)
+            writer.tag(3, WireType.Varint).int32(message.score);
+        /* bool is_ready = 4; */
+        if (message.isReady !== false)
+            writer.tag(4, WireType.Varint).bool(message.isReady);
+        /* bool is_connected = 5; */
+        if (message.isConnected !== false)
+            writer.tag(5, WireType.Varint).bool(message.isConnected);
+        /* int64 joined_at = 6; */
+        if (message.joinedAt !== 0n)
+            writer.tag(6, WireType.Varint).int64(message.joinedAt);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.Player
+ */
+export const Player = new Player$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class GameState$Type extends MessageType<GameState> {
+    constructor() {
+        super("takeiteasygame.v1.GameState", [
+            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 2, name: "players", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Player },
+            { no: 3, name: "current_player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 4, name: "state", kind: "enum", T: () => ["takeiteasygame.v1.SessionState", SessionState] },
+            { no: 5, name: "board_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 6, name: "turn_number", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
+        ]);
+    }
+    create(value?: PartialMessage<GameState>): GameState {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.sessionId = "";
+        message.players = [];
+        message.currentPlayerId = "";
+        message.state = 0;
+        message.boardState = "";
+        message.turnNumber = 0;
+        if (value !== undefined)
+            reflectionMergePartial<GameState>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameState): GameState {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string session_id */ 1:
+                    message.sessionId = reader.string();
+                    break;
+                case /* repeated takeiteasygame.v1.Player players */ 2:
+                    message.players.push(Player.internalBinaryRead(reader, reader.uint32(), options));
+                    break;
+                case /* string current_player_id */ 3:
+                    message.currentPlayerId = reader.string();
+                    break;
+                case /* takeiteasygame.v1.SessionState state */ 4:
+                    message.state = reader.int32();
+                    break;
+                case /* string board_state */ 5:
+                    message.boardState = reader.string();
+                    break;
+                case /* int32 turn_number */ 6:
+                    message.turnNumber = reader.int32();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: GameState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string session_id = 1; */
+        if (message.sessionId !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
+        /* repeated takeiteasygame.v1.Player players = 2; */
+        for (let i = 0; i < message.players.length; i++)
+            Player.internalBinaryWrite(message.players[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
+        /* string current_player_id = 3; */
+        if (message.currentPlayerId !== "")
+            writer.tag(3, WireType.LengthDelimited).string(message.currentPlayerId);
+        /* takeiteasygame.v1.SessionState state = 4; */
+        if (message.state !== 0)
+            writer.tag(4, WireType.Varint).int32(message.state);
+        /* string board_state = 5; */
+        if (message.boardState !== "")
+            writer.tag(5, WireType.LengthDelimited).string(message.boardState);
+        /* int32 turn_number = 6; */
+        if (message.turnNumber !== 0)
+            writer.tag(6, WireType.Varint).int32(message.turnNumber);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.GameState
+ */
+export const GameState = new GameState$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class Error$Type extends MessageType<Error> {
+    constructor() {
+        super("takeiteasygame.v1.Error", [
+            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 3, name: "details", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
+        ]);
+    }
+    create(value?: PartialMessage<Error>): Error {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.code = "";
+        message.message = "";
+        message.details = {};
+        if (value !== undefined)
+            reflectionMergePartial<Error>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Error): Error {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string code */ 1:
+                    message.code = reader.string();
+                    break;
+                case /* string message */ 2:
+                    message.message = reader.string();
+                    break;
+                case /* map<string, string> details */ 3:
+                    this.binaryReadMap3(message.details, reader, options);
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    private binaryReadMap3(map: Error["details"], reader: IBinaryReader, options: BinaryReadOptions): void {
+        let len = reader.uint32(), end = reader.pos + len, key: keyof Error["details"] | undefined, val: Error["details"][any] | undefined;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case 1:
+                    key = reader.string();
+                    break;
+                case 2:
+                    val = reader.string();
+                    break;
+                default: throw new globalThis.Error("unknown map entry field for takeiteasygame.v1.Error.details");
+            }
+        }
+        map[key ?? ""] = val ?? "";
+    }
+    internalBinaryWrite(message: Error, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string code = 1; */
+        if (message.code !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.code);
+        /* string message = 2; */
+        if (message.message !== "")
+            writer.tag(2, WireType.LengthDelimited).string(message.message);
+        /* map<string, string> details = 3; */
+        for (let k of globalThis.Object.keys(message.details))
+            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.details[k]).join();
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.Error
+ */
+export const Error = new Error$Type();
+```
+
+## 📄 src/generated/game_service.client.ts
+```ts
+// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
+// tslint:disable
+import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
+import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
+import { GameService } from "./game_service";
+import type { GetAvailableMovesResponse } from "./game_service";
+import type { GetAvailableMovesRequest } from "./game_service";
+import { stackIntercept } from "@protobuf-ts/runtime-rpc";
+import type { MakeMoveResponse } from "./game_service";
+import type { MakeMoveRequest } from "./game_service";
+import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
+import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
+/**
+ * @generated from protobuf service takeiteasygame.v1.GameService
+ */
+export interface IGameServiceClient {
+    /**
+     * Faire un mouvement
+     *
+     * @generated from protobuf rpc: MakeMove
+     */
+    makeMove(input: MakeMoveRequest, options?: RpcOptions): UnaryCall<MakeMoveRequest, MakeMoveResponse>;
+    /**
+     * Obtenir les mouvements disponibles
+     *
+     * @generated from protobuf rpc: GetAvailableMoves
+     */
+    getAvailableMoves(input: GetAvailableMovesRequest, options?: RpcOptions): UnaryCall<GetAvailableMovesRequest, GetAvailableMovesResponse>;
+}
+/**
+ * @generated from protobuf service takeiteasygame.v1.GameService
+ */
+export class GameServiceClient implements IGameServiceClient, ServiceInfo {
+    typeName = GameService.typeName;
+    methods = GameService.methods;
+    options = GameService.options;
+    constructor(private readonly _transport: RpcTransport) {
+    }
+    /**
+     * Faire un mouvement
+     *
+     * @generated from protobuf rpc: MakeMove
+     */
+    makeMove(input: MakeMoveRequest, options?: RpcOptions): UnaryCall<MakeMoveRequest, MakeMoveResponse> {
+        const method = this.methods[0], opt = this._transport.mergeOptions(options);
+        return stackIntercept<MakeMoveRequest, MakeMoveResponse>("unary", this._transport, method, opt, input);
+    }
+    /**
+     * Obtenir les mouvements disponibles
+     *
+     * @generated from protobuf rpc: GetAvailableMoves
+     */
+    getAvailableMoves(input: GetAvailableMovesRequest, options?: RpcOptions): UnaryCall<GetAvailableMovesRequest, GetAvailableMovesResponse> {
+        const method = this.methods[1], opt = this._transport.mergeOptions(options);
+        return stackIntercept<GetAvailableMovesRequest, GetAvailableMovesResponse>("unary", this._transport, method, opt, input);
+    }
+}
+```
+
+## 📄 src/index.tsx
+```tsx
+// src/index.tsx
+import { render } from 'solid-js/web';
+import MultiplayerApp from './components/MultiplayerApp';
+
+const root = document.getElementById('root');
+
+if (import.meta.env.DEV && !(root instanceof HTMLElement)) {
+  throw new Error(
+      'Root element not found. Did you forget to add it to your index.html? Or maybe the id attribute got misspelled?',
+  );
+}
+
+render(() => <MultiplayerApp />, root!);```
+
+## 📄 src/todo-list.test.tsx
+```tsx
+import { render, fireEvent } from '@solidjs/testing-library';
+
+import { TodoList } from './todo-list';
+import { describe, expect, test } from 'vitest';
+
+describe('<TodoList />', () => {
+  test('it will render an text input and a button', () => {
+    const { getByPlaceholderText, getByText } = render(() => <TodoList />);
+    expect(getByPlaceholderText('new todo here')).toBeInTheDocument();
+    expect(getByText('Add Todo')).toBeInTheDocument();
+  });
+
+  test('it will add a new todo', async () => {
+    const { getByPlaceholderText, getByText } = render(() => <TodoList />);
+    const input = getByPlaceholderText('new todo here') as HTMLInputElement;
+    const button = getByText('Add Todo');
+    input.value = 'test new todo';
+    fireEvent.click(button as HTMLInputElement);
+    expect(input.value).toBe('');
+    expect(getByText(/test new todo/)).toBeInTheDocument();
+  });
+
+  test('it will mark a todo as completed', async () => {
+    const { getByPlaceholderText, findByRole, getByText } = render(() => (
+      <TodoList />
+    ));
+    const input = getByPlaceholderText('new todo here') as HTMLInputElement;
+    const button = getByText('Add Todo') as HTMLButtonElement;
+    input.value = 'mark new todo as completed';
+    fireEvent.click(button);
+    const completed = (await findByRole('checkbox')) as HTMLInputElement;
+    expect(completed?.checked).toBe(false);
+    fireEvent.click(completed);
+    expect(completed?.checked).toBe(true);
+    const text = getByText('mark new todo as completed') as HTMLSpanElement;
+    expect(text).toHaveStyle({ 'text-decoration': 'line-through' });
+  });
+});
+```
+
+## 📄 src/components/MultiplayerApp.tsx
+```tsx
+// src/components/MultiplayerApp.tsx - Interface multiplayer avec gRPC
+import { Component, createSignal, createEffect, onMount, Show, For, onCleanup } from 'solid-js';
+import { gameClient } from '../services/GameClient';
+
+// Import des types générés depuis vos fichiers
+import { SessionState } from '../generated/common';
+import type { Player as ProtoPlayer, GameState as ProtoGameState } from '../generated/common';
+
+// Types pour l'état local (adaptés de vos protos)
+interface Player {
+    id: string;
+    name: string;
+    score: number;
+    isReady: boolean;
+    isConnected: boolean;
+    joinedAt: string;
+}
+
+interface GameState {
+    sessionCode: string;
+    state: SessionState;
+    players: Player[];
+    boardState: string;
+    currentTurn?: string;
+}
+
+interface Session {
+    playerId: string;
+    sessionCode: string;
+    sessionId: string; // Ajout du sessionId pour les appels gRPC
+}
+
+const MultiplayerApp: Component = () => {
+    // Signaux SolidJS
+    const [playerName, setPlayerName] = createSignal('');
+    const [sessionCode, setSessionCode] = createSignal('');
+    const [gameState, setGameState] = createSignal<GameState | null>(null);
+    const [session, setSession] = createSignal<Session | null>(null);
+    const [loading, setLoading] = createSignal(false);
+    const [error, setError] = createSignal('');
+    const [statusMessage, setStatusMessage] = createSignal('');
+
+    // Polling pour l'état du jeu
+    let pollInterval: number | undefined;
+
+    // Démarrer le polling quand on rejoint une session
+    createEffect(() => {
+        const currentSession = session();
+        if (currentSession) {
+            // Réactiver le polling pour synchroniser les joueurs
+            startPolling(currentSession.sessionId);
+            console.log('Polling activé pour session:', currentSession.sessionCode, 'ID:', currentSession.sessionId);
+        } else {
+            stopPolling();
+        }
+    });
+
+    // Nettoyage au démontage
+    onCleanup(() => {
+        stopPolling();
+        gameClient.dispose();
+    });
+
+    // Fonctions utilitaires
+    const isPlayerReady = () => {
+        const state = gameState();
+        const currentSession = session();
+        if (!state || !currentSession) return false;
+
+        const player = state.players.find(p => p.id === currentSession.playerId);
+        return player?.isReady || false;
+    };
+
+    const isCurrentPlayer = (playerId: string) => {
+        const currentSession = session();
+        return currentSession?.playerId === playerId;
+    };
+
+    const getPlayerStatus = (player: Player) => {
+        if (player.isReady) {
+            return "✅ Prêt";
+        }
+        return "⏳ En attente";
+    };
+
+    const getSessionStateLabel = (state: SessionState) => {
+        switch (state) {
+            case SessionState.WAITING: return "En attente";
+            case SessionState.IN_PROGRESS: return "En cours";
+            case SessionState.FINISHED: return "Terminée";
+            case SessionState.CANCELLED: return "Annulée";
+            default: return "Inconnue";
+        }
+    };
+
+    // Actions gRPC
+    const createSession = async () => {
+        if (!playerName().trim()) {
+            setError('Veuillez entrer votre nom');
+            return;
+        }
+
+        setLoading(true);
+        setError('');
+
+        const result = await gameClient.createSession(playerName());
+
+        if (result.success) {
+            setSession({
+                playerId: result.playerId!,
+                sessionCode: result.sessionCode!,
+                sessionId: result.sessionId! // Stocker le sessionId aussi
+            });
+
+            // Convertir la réponse gRPC en état local
+            if (result.sessionState) {
+                setGameState(convertSessionState(result.sessionState));
+            } else {
+                // Créer un état initial si pas de sessionState
+                setGameState({
+                    sessionCode: result.sessionCode!,
+                    state: SessionState.WAITING,
+                    players: [{
+                        id: result.playerId!,
+                        name: playerName(),
+                        score: 0,
+                        isReady: true, // Le créateur est automatiquement prêt
+                        isConnected: true,
+                        joinedAt: Date.now().toString()
+                    }],
+                    boardState: "{}"
+                });
+            }
+
+            setStatusMessage(`Session créée ! Code: ${result.sessionCode}`);
+        } else {
+            setError(result.error || 'Erreur lors de la création');
+        }
+
+        setLoading(false);
+    };
+
+    const joinSession = async () => {
+        if (!playerName().trim() || !sessionCode().trim()) {
+            setError('Veuillez entrer votre nom et le code de session');
+            return;
+        }
+
+        setLoading(true);
+        setError('');
+
+        const result = await gameClient.joinSession(sessionCode(), playerName());
+
+        if (result.success) {
+            setSession({
+                playerId: result.playerId!,
+                sessionCode: result.sessionCode!,
+                sessionId: result.sessionId! // Stocker le sessionId aussi
+            });
+
+            if (result.sessionState) {
+                setGameState(convertSessionState(result.sessionState));
+            } else {
+                // Créer un état initial si pas de sessionState
+                setGameState({
+                    sessionCode: result.sessionCode!,
+                    state: SessionState.WAITING,
+                    players: [{
+                        id: result.playerId!,
+                        name: playerName(),
+                        score: 0,
+                        isReady: false, // Le nouveau joueur n'est pas encore prêt
+                        isConnected: true,
+                        joinedAt: Date.now().toString()
+                    }],
+                    boardState: "{}"
+                });
+            }
+
+            setStatusMessage(`Rejoint la session ${result.sessionCode}`);
+        } else {
+            setError(result.error || 'Erreur lors du join');
+        }
+
+        setLoading(false);
+    };
+
+    const setReady = async () => {
+        const currentSession = session();
+        if (!currentSession) return;
+
+        setLoading(true);
+
+        // Note: Utiliser sessionId pour les appels gRPC
+        const result = await gameClient.setPlayerReady(
+            currentSession.sessionId, // Utiliser sessionId maintenant
+            currentSession.playerId
+        );
+
+        if (result.success) {
+            // Mettre à jour l'état local directement
+            setGameState(prev => {
+                if (!prev) return null;
+                return {
+                    ...prev,
+                    players: prev.players.map(p =>
+                        p.id === currentSession.playerId
+                            ? { ...p, isReady: true }
+                            : p
+                    )
+                };
+            });
+
+            setStatusMessage('Vous êtes maintenant prêt !');
+
+            // Vérifier si la partie a commencé
+            if (result.gameStarted) {
+                setGameState(prev => prev ? { ...prev, state: SessionState.IN_PROGRESS } : null);
+                setStatusMessage('La partie commence !');
+            }
+        } else {
+            setError(result.error || 'Erreur');
+        }
+
+        setLoading(false);
+    };
+
+    const leaveSession = async () => {
+        const currentSession = session();
+        if (currentSession) {
+            await gameClient.leaveSession(currentSession.sessionId, currentSession.playerId); // Utiliser sessionId
+        }
+
+        setSession(null);
+        setGameState(null);
+        setError('');
+        setStatusMessage('');
+        setSessionCode('');
+    };
+
+    // Polling de l'état du jeu
+    const startPolling = (sessionId: string) => {
+        stopPolling();
+
+        const poll = async () => {
+            try {
+                const result = await gameClient.getSessionState(sessionId);
+                if (result.success && result.sessionState) {
+                    setGameState(convertSessionState(result.sessionState));
+                } else if (result.error) {
+                    console.warn('Erreur polling:', result.error);
+                    // Ne pas afficher l'erreur à l'utilisateur pour éviter le spam
+                }
+            } catch (error) {
+                console.warn('Erreur polling:', error);
+                // En cas d'erreur répétée, on peut arrêter le polling
+            }
+        };
+
+        // Poll immédiat puis toutes les 2 secondes
+        poll();
+        pollInterval = window.setInterval(poll, 2000);
+    };
+
+    const stopPolling = () => {
+        if (pollInterval) {
+            clearInterval(pollInterval);
+            pollInterval = undefined;
+        }
+    };
+
+    // Convertir SessionState gRPC vers état local
+    const convertSessionState = (sessionState: ProtoGameState): GameState => {
+        return {
+            sessionCode: sessionState.sessionId || '', // Note: sessionId dans le proto
+            state: sessionState.state,
+            players: sessionState.players.map((p: ProtoPlayer) => ({
+                id: p.id,
+                name: p.name,
+                score: p.score,
+                isReady: p.isReady,
+                isConnected: p.isConnected,
+                joinedAt: p.joinedAt.toString() // bigint vers string
+            })),
+            boardState: sessionState.boardState || '{}',
+            currentTurn: sessionState.currentPlayerId
+        };
+    };
+
+    // Rendu des joueurs
+    const renderPlayers = () => {
+        const state = gameState();
+        if (!state) return null;
+
+        return (
+            <div class="players-section">
+                <h3>Joueurs ({state.players.length})</h3>
+                <div class="players-list">
+                    <For each={state.players}>
+                        {(player) => (
+                            <div
+                                class={`player-card ${isCurrentPlayer(player.id) ? 'current-player' : ''}`}
+                            >
+                                <div class="player-info">
+                  <span class="player-name">
+                    {player.name}
+                      {isCurrentPlayer(player.id) && <span class="you-indicator"> (Vous)</span>}
+                  </span>
+                                    <span class="player-score">Score: {player.score}</span>
+                                </div>
+                                <div class="player-status">
+                                    {getPlayerStatus(player)}
+                                </div>
+                            </div>
+                        )}
+                    </For>
+                </div>
+
+                {/* Section bouton "Je suis prêt" */}
+                <Show when={gameState()?.state === SessionState.WAITING}>
+                    <div class="ready-section">
+                        <Show when={!isPlayerReady()}>
+                            <button
+                                onClick={setReady}
+                                disabled={loading()}
+                                class="ready-button"
+                            >
+                                Je suis prêt !
+                            </button>
+                        </Show>
+                        <Show when={isPlayerReady()}>
+                            <div class="ready-status">
+                                ✅ Vous êtes prêt ! En attente des autres joueurs...
+                            </div>
+                        </Show>
+                    </div>
+                </Show>
+            </div>
+        );
+    };
+
+    // Rendu du plateau de jeu
+    const renderGameBoard = () => {
+        const state = gameState();
+        if (!state) return null;
+
+        return (
+            <div class="game-board-section">
+                <h3>🎮 Plateau de Jeu</h3>
+
+                <div class="game-status">
+                    <strong>État: {getSessionStateLabel(state.state)}</strong>
+                    <Show when={state.currentTurn}>
+                        <span class="current-turn">Tour de: <strong>{state.currentTurn}</strong></span>
+                    </Show>
+                </div>
+
+                <Show when={state.state === SessionState.WAITING}>
+                    <div class="waiting-message">
+                        <p>⏳ En attente que tous les joueurs soient prêts...</p>
+                        <p>Dès que tous les joueurs seront prêts, le plateau hexagonal apparaîtra !</p>
+                    </div>
+                </Show>
+
+                <Show when={state.state === SessionState.IN_PROGRESS}>
+                    <div class="active-game">
+                        <GameBoard gameState={state} />
+                    </div>
+                </Show>
+
+                <Show when={state.boardState && state.boardState !== "{}"}>
+                    <div class="board-preview">
+                        <h4>État du plateau (debug) :</h4>
+                        <pre class="board-data">
+              {JSON.stringify(JSON.parse(state.boardState), null, 2)}
+            </pre>
+                    </div>
+                </Show>
+            </div>
+        );
+    };
+
+    // Composant plateau de jeu hexagonal
+    const GameBoard = (props: { gameState: GameState }) => {
+        let canvasRef: HTMLCanvasElement;
+        let nextTileCanvasRef: HTMLCanvasElement;
+
+        const [nextTile, setNextTile] = createSignal<string | null>(null);
+        const [plateauTiles, setPlateauTiles] = createSignal<string[]>(new Array(19).fill(''));
+
+        // Positions hexagonales (identiques à votre App.tsx)
+        const hexPositions = [
+            [-2, 2], [-2.3, 4], [-2.65, 6], [-1, 1], [-1.3, 3], [-1.6, 5], [-1.95, 7],
+            [0, 0],
+            [-0.3, 2], [-0.6, 4], [-0.9, 6], [-1.25, 8],
+            [0.7, 1], [0.4, 3], [0.1, 5], [-0.2, 7],
+            [1.4, 2], [1.1, 4], [0.8, 6],
+        ];
+
+        const hexRadius = 35; // Plus petit pour le multiplayer
+        const hexWidth = Math.sqrt(3) * hexRadius;
+        const hexHeight = 2 * hexRadius;
+        const offsetY = 0.45 * hexHeight;
+
+        const drawHexagon = (ctx: CanvasRenderingContext2D, x: number, y: number, radius: number) => {
+            const angleStep = Math.PI / 3;
+            ctx.beginPath();
+            for (let i = 0; i < 6; i++) {
+                const angle = angleStep * i;
+                const xOffset = x + radius * Math.cos(angle);
+                const yOffset = y + radius * Math.sin(angle);
+                if (i === 0) ctx.moveTo(xOffset, yOffset);
+                else ctx.lineTo(xOffset, yOffset);
+            }
+            ctx.closePath();
+            ctx.strokeStyle = 'white';
+            ctx.lineWidth = 2;
+            ctx.stroke();
+        };
+
+        const drawHexagonalGrid = (ctx: CanvasRenderingContext2D, images: string[], canvas: HTMLCanvasElement, onClick?: (index: number) => void) => {
+            ctx.clearRect(0, 0, canvas.width, canvas.height);
+            ctx.fillStyle = '#1e1e1e';
+            ctx.fillRect(0, 0, canvas.width, canvas.height);
+
+            const gridOriginX = canvas.width / 2 - hexWidth;
+            const gridOriginY = canvas.height / 2 - 2 * offsetY;
+
+            const clickableAreas: { x: number; y: number; index: number }[] = [];
+
+            hexPositions.forEach(([q, r], index) => {
+                const x = gridOriginX + q * hexWidth + r * (hexWidth / 6) + 50;
+                const y = gridOriginY + r * offsetY - 50;
+
+                // Dessiner l'hexagone
+                drawHexagon(ctx, x, y, hexRadius);
+
+                // Dessiner l'image si elle existe
+                if (images[index]) {
+                    const img = new Image();
+                    img.src = images[index];
+                    img.onload = () => {
+                        const scaledWidth = img.width / 3;
+                        const scaledHeight = img.height / 3;
+                        ctx.drawImage(img, x - scaledWidth / 2, y - scaledHeight / 2, scaledWidth, scaledHeight);
+                        drawHexagon(ctx, x, y, hexRadius);
+                    };
+                }
+
+                if (onClick) {
+                    clickableAreas.push({ x, y, index });
+                }
+            });
+
+            if (onClick) {
+                canvas.onclick = (e) => {
+                    const rect = canvas.getBoundingClientRect();
+                    const clickX = e.clientX - rect.left;
+                    const clickY = e.clientY - rect.top;
+
+                    for (const area of clickableAreas) {
+                        const dx = clickX - area.x;
+                        const dy = clickY - area.y;
+                        if (Math.sqrt(dx * dx + dy * dy) < hexRadius) {
+                            onClick(area.index);
+                            break;
+                        }
+                    }
+                };
+            }
+        };
+
+        const handleTileClick = (index: number) => {
+            const currentSession = session();
+            if (!currentSession) return;
+
+            // Vérifier si c'est le tour du joueur
+            if (props.gameState.currentTurn !== currentSession.playerId) {
+                setStatusMessage("Ce n'est pas votre tour !");
+                return;
+            }
+
+            // TODO: Implémenter le mouvement via gRPC
+            console.log(`Clic sur la position ${index}`);
+            setStatusMessage(`Mouvement sur la position ${index}`);
+        };
+
+        createEffect(() => {
+            if (canvasRef) {
+                const ctx = canvasRef.getContext('2d');
+                if (ctx) {
+                    const currentSession = session();
+                    const canClick = currentSession && props.gameState.currentTurn === currentSession.playerId;
+                    drawHexagonalGrid(ctx, plateauTiles(), canvasRef, canClick ? handleTileClick : undefined);
+                }
+            }
+        });
+
+        createEffect(() => {
+            if (nextTileCanvasRef && nextTile()) {
+                const ctx = nextTileCanvasRef.getContext('2d');
+                if (ctx) {
+                    ctx.clearRect(0, 0, nextTileCanvasRef.width, nextTileCanvasRef.height);
+                    const img = new Image();
+                    img.src = nextTile()!;
+                    img.onload = () => {
+                        const scale = 0.4;
+                        const w = img.width * scale;
+                        const h = img.height * scale;
+                        ctx.drawImage(img, (120 - w) / 2, (120 - h) / 2, w, h);
+                    };
+                }
+            }
+        });
+
+        return (
+            <div class="game-board-container">
+                <div class="game-controls">
+                    <div class="next-tile-section">
+                        <h4>Prochaine tuile</h4>
+                        <canvas
+                            ref={nextTileCanvasRef!}
+                            width="120"
+                            height="120"
+                            class="next-tile-canvas"
+                        />
+                        <button
+                            onClick={() => setNextTile(`/api/tiles/random-${Math.floor(Math.random() * 10)}.png`)}
+                            class="generate-tile-button"
+                        >
+                            🎲 Générer tuile
+                        </button>
+                    </div>
+
+                    <div class="turn-info">
+                        <Show when={props.gameState.currentTurn}>
+                            <div class="current-turn-display">
+                                <h4>Tour actuel</h4>
+                                <p class="turn-player">
+                                    {props.gameState.players.find(p => p.id === props.gameState.currentTurn)?.name || 'Inconnu'}
+                                </p>
+                                <Show when={session()?.playerId === props.gameState.currentTurn}>
+                                    <div class="your-turn">🎯 À votre tour !</div>
+                                </Show>
+                            </div>
+                        </Show>
+                    </div>
+                </div>
+
+                <div class="board-canvas-container">
+                    <canvas
+                        ref={canvasRef!}
+                        width="500"
+                        height="500"
+                        class="game-canvas"
+                    />
+                    <div class="canvas-instructions">
+                        <Show when={session()?.playerId === props.gameState.currentTurn}>
+                            <p>✨ Cliquez sur un hexagone pour placer votre tuile</p>
+                        </Show>
+                        <Show when={session()?.playerId !== props.gameState.currentTurn}>
+                            <p>⏳ En attente du tour de l'autre joueur...</p>
+                        </Show>
+                    </div>
+                </div>
+            </div>
+        );
+    };
+
+    return (
+        <div class="multiplayer-app">
+            <h1>🎮 Take It Easy - Multiplayer</h1>
+
+            {/* Messages d'erreur et de statut */}
+            <Show when={error()}>
+                <div class="error-message">{error()}</div>
+            </Show>
+
+            <Show when={statusMessage()}>
+                <div class="status-message">{statusMessage()}</div>
+            </Show>
+
+            {/* Interface de connexion */}
+            <Show when={!session()}>
+                <div class="connection-section">
+                    <div class="input-group">
+                        <label for="player-name">Nom du joueur :</label>
+                        <input
+                            id="player-name"
+                            type="text"
+                            class="player-name-input"
+                            value={playerName()}
+                            onInput={(e) => setPlayerName(e.target.value)}
+                            placeholder="Entrez votre nom"
+                            maxLength={20}
+                        />
+                    </div>
+
+                    <div class="actions">
+                        <button
+                            onClick={createSession}
+                            disabled={loading()}
+                            class="create-button"
+                        >
+                            {loading() ? 'Création...' : 'Créer une nouvelle session'}
+                        </button>
+
+                        <div class="join-section">
+                            <input
+                                type="text"
+                                class="session-code-input"
+                                value={sessionCode()}
+                                onInput={(e) => setSessionCode(e.target.value.toUpperCase())}
+                                placeholder="CODE"
+                                maxLength={6}
+                            />
+                            <button
+                                onClick={joinSession}
+                                disabled={loading()}
+                                class="join-button"
+                            >
+                                {loading() ? 'Connexion...' : 'Rejoindre'}
+                            </button>
+                        </div>
+                    </div>
+                </div>
+            </Show>
+
+            {/* Interface de jeu */}
+            <Show when={session()}>
+                <div class="session-info">
+                    <div class="session-details">
+                        <h2>🎮 Session: {session()?.sessionCode}</h2>
+                        <p>Joueur: <strong>{playerName()}</strong></p>
+                        <p class="player-id">ID: {session()?.playerId}</p>
+                    </div>
+                    <button onClick={leaveSession} class="leave-button">
+                        Quitter la session
+                    </button>
+                </div>
+
+                {renderPlayers()}
+                {renderGameBoard()}
+            </Show>
+
+            {/* Styles CSS intégrés */}
+            <style jsx>{`
+                .multiplayer-app {
+                    max-width: 900px;
+                    margin: 0 auto;
+                    padding: 20px;
+                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
+                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
+                    min-height: 100vh;
+                    color: white;
+                }
+
+                h1 {
+                    text-align: center;
+                    margin-bottom: 30px;
+                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
+                }
+
+                .connection-section {
+                    background: rgba(255,255,255,0.95);
+                    color: #333;
+                    padding: 30px;
+                    border-radius: 16px;
+                    margin-bottom: 20px;
+                    box-shadow: 0 8px 32px rgba(0,0,0,0.1);
+                }
+
+                .input-group {
+                    margin-bottom: 20px;
+                }
+
+                .input-group label {
+                    display: block;
+                    margin-bottom: 8px;
+                    font-weight: 600;
+                    color: #555;
+                }
+
+                .player-name-input, .session-code-input {
+                    width: 100%;
+                    padding: 14px;
+                    border: 2px solid #e0e6ed;
+                    border-radius: 10px;
+                    font-size: 16px;
+                    transition: all 0.3s ease;
+                }
+
+                .player-name-input:focus, .session-code-input:focus {
+                    outline: none;
+                    border-color: #667eea;
+                    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
+                }
+
+                .session-code-input {
+                    text-transform: uppercase;
+                    letter-spacing: 3px;
+                    text-align: center;
+                    font-weight: bold;
+                    font-size: 18px;
+                }
+
+                .actions {
+                    display: flex;
+                    flex-direction: column;
+                    gap: 15px;
+                }
+
+                .join-section {
+                    display: flex;
+                    gap: 12px;
+                }
+
+                .join-section input {
+                    flex: 1;
+                }
+
+                button {
+                    padding: 14px 28px;
+                    border: none;
+                    border-radius: 10px;
+                    font-size: 16px;
+                    font-weight: 600;
+                    cursor: pointer;
+                    transition: all 0.3s ease;
+                    text-transform: uppercase;
+                    letter-spacing: 0.5px;
+                }
+
+                .create-button {
+                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
+                    color: white;
+                }
+
+                .join-button {
+                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
+                    color: white;
+                }
+
+                .leave-button {
+                    background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
+                    color: #333;
+                }
+
+                .ready-button {
+                    background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
+                    color: #333;
+                    font-size: 18px;
+                    padding: 16px 32px;
+                }
+
+                button:hover:not(:disabled) {
+                    transform: translateY(-2px);
+                    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
+                }
+
+                button:disabled {
+                    opacity: 0.6;
+                    cursor: not-allowed;
+                    transform: none;
+                }
+
+                .session-info {
+                    background: rgba(255,255,255,0.1);
+                    backdrop-filter: blur(10px);
+                    padding: 24px;
+                    border-radius: 16px;
+                    margin-bottom: 24px;
+                    display: flex;
+                    justify-content: space-between;
+                    align-items: center;
+                    border: 1px solid rgba(255,255,255,0.2);
+                }
+
+                .session-details h2 {
+                    margin: 0 0 8px 0;
+                    font-size: 24px;
+                }
+
+                .session-details p {
+                    margin: 4px 0;
+                    opacity: 0.9;
+                }
+
+                .player-id {
+                    font-size: 12px;
+                    font-family: monospace;
+                    opacity: 0.7;
+                }
+
+                .status-message {
+                    background: rgba(16, 185, 129, 0.2);
+                    color: #10b981;
+                    padding: 12px;
+                    border-radius: 8px;
+                    margin: 10px 0;
+                    border: 1px solid rgba(16, 185, 129, 0.3);
+                    backdrop-filter: blur(10px);
+                }
+
+                .error-message {
+                    background: rgba(239, 68, 68, 0.2);
+                    color: #ef4444;
+                    padding: 12px;
+                    border-radius: 8px;
+                    margin: 10px 0;
+                    border: 1px solid rgba(239, 68, 68, 0.3);
+                    backdrop-filter: blur(10px);
+                }
+
+                /* Styles pour les joueurs */
+                .players-section {
+                    background: rgba(255,255,255,0.1);
+                    backdrop-filter: blur(10px);
+                    padding: 24px;
+                    border-radius: 16px;
+                    margin: 24px 0;
+                    border: 1px solid rgba(255,255,255,0.2);
+                }
+
+                .players-section h3 {
+                    margin: 0 0 20px 0;
+                    font-size: 20px;
+                }
+
+                .players-list {
+                    display: flex;
+                    flex-direction: column;
+                    gap: 12px;
+                    margin: 20px 0;
+                }
+
+                .player-card {
+                    display: flex;
+                    justify-content: space-between;
+                    align-items: center;
+                    padding: 16px;
+                    background: rgba(255,255,255,0.1);
+                    border-radius: 12px;
+                    border: 1px solid rgba(255,255,255,0.2);
+                    backdrop-filter: blur(5px);
+                }
+
+                .player-card.current-player {
+                    border: 2px solid #a8edea;
+                    background: rgba(168, 237, 234, 0.2);
+                }
+
+                .player-info {
+                    display: flex;
+                    flex-direction: column;
+                    gap: 4px;
+                }
+
+                .player-name {
+                    font-weight: bold;
+                    font-size: 16px;
+                }
+
+                .you-indicator {
+                    color: #a8edea;
+                    font-size: 12px;
+                }
+
+                .player-score {
+                    font-size: 14px;
+                    opacity: 0.8;
+                }
+
+                .player-status {
+                    font-size: 14px;
+                    font-weight: bold;
+                }
+
+                .ready-section {
+                    text-align: center;
+                    margin: 24px 0;
+                    padding: 20px;
+                    border-radius: 12px;
+                    background: rgba(255,255,255,0.05);
+                }
+
+                .ready-status {
+                    background: rgba(16, 185, 129, 0.2);
+                    color: #10b981;
+                    padding: 16px;
+                    border-radius: 8px;
+                    font-weight: bold;
+                    border: 1px solid rgba(16, 185, 129, 0.3);
+                }
+
+                /* Styles pour le plateau de jeu */
+                .game-board-section {
+                    background: rgba(255,255,255,0.1);
+                    backdrop-filter: blur(10px);
+                    padding: 24px;
+                    border-radius: 16px;
+                    margin: 24px 0;
+                    border: 1px solid rgba(255,255,255,0.2);
+                }
+
+                .game-board-section h3 {
+                    margin: 0 0 16px 0;
+                    font-size: 20px;
+                }
+
+                .game-status {
+                    background: rgba(255,255,255,0.1);
+                    padding: 12px;
+                    border-radius: 8px;
+                    margin-bottom: 16px;
+                    text-align: center;
+                    display: flex;
+                    justify-content: space-between;
+                    align-items: center;
+                }
+
+                .current-turn {
+                    color: #a8edea;
+                    font-weight: bold;
+                }
+
+                .waiting-message {
+                    text-align: center;
+                    font-style: italic;
+                    opacity: 0.8;
+                    margin: 20px 0;
+                }
+
+                .active-game {
+                    margin: 20px 0;
+                }
+
+                .game-board-container {
+                    display: flex;
+                    flex-direction: column;
+                    align-items: center;
+                    gap: 20px;
+                    margin: 20px 0;
+                }
+
+                .game-controls {
+                    display: flex;
+                    gap: 30px;
+                    align-items: flex-start;
+                    background: rgba(255,255,255,0.05);
+                    padding: 20px;
+                    border-radius: 12px;
+                }
+
+                .next-tile-section {
+                    display: flex;
+                    flex-direction: column;
+                    align-items: center;
+                    gap: 10px;
+                }
+
+                .next-tile-section h4 {
+                    margin: 0;
+                    color: #a8edea;
+                }
+
+                .next-tile-canvas {
+                    border: 2px solid rgba(255,255,255,0.2);
+                    border-radius: 8px;
+                    background: #1e1e1e;
+                }
+
+                .generate-tile-button {
+                    background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
+                    color: white;
+                    border: none;
+                    padding: 8px 16px;
+                    border-radius: 6px;
+                    font-size: 14px;
+                    cursor: pointer;
+                    transition: all 0.2s;
+                }
+
+                .generate-tile-button:hover {
+                    transform: translateY(-1px);
+                    box-shadow: 0 4px 12px rgba(255, 216, 155, 0.3);
+                }
+
+                .turn-info {
+                    display: flex;
+                    flex-direction: column;
+                    align-items: center;
+                    min-width: 150px;
+                }
+
+                .current-turn-display h4 {
+                    margin: 0 0 8px 0;
+                    color: #a8edea;
+                }
+
+                .turn-player {
+                    font-size: 18px;
+                    font-weight: bold;
+                    color: white;
+                    margin: 0;
+                    text-align: center;
+                }
+
+                .your-turn {
+                    background: rgba(168, 237, 234, 0.2);
+                    color: #a8edea;
+                    padding: 8px 12px;
+                    border-radius: 6px;
+                    font-weight: bold;
+                    margin-top: 8px;
+                    text-align: center;
+                    border: 1px solid #a8edea;
+                    animation: pulse 2s infinite;
+                }
+
+                @keyframes pulse {
+                    0% { opacity: 1; }
+                    50% { opacity: 0.7; }
+                    100% { opacity: 1; }
+                }
+
+                .board-canvas-container {
+                    display: flex;
+                    flex-direction: column;
+                    align-items: center;
+                    gap: 15px;
+                }
+
+                .game-canvas {
+                    border: 3px solid rgba(255,255,255,0.2);
+                    border-radius: 12px;
+                    background: #1e1e1e;
+                    cursor: pointer;
+                    transition: all 0.3s ease;
+                }
+
+                .game-canvas:hover {
+                    border-color: #a8edea;
+                    box-shadow: 0 0 20px rgba(168, 237, 234, 0.3);
+                }
+
+                .canvas-instructions {
+                    text-align: center;
+                    font-style: italic;
+                    color: rgba(255,255,255,0.8);
+                }
+
+                .canvas-instructions p {
+                    margin: 0;
+                    padding: 8px 16px;
+                    background: rgba(255,255,255,0.05);
+                    border-radius: 6px;
+                    border: 1px solid rgba(255,255,255,0.1);
+                }
+
+                .board-preview {
+                    margin-top: 20px;
+                }
+
+                .board-preview h4 {
+                    margin: 0 0 12px 0;
+                    font-size: 16px;
+                }
+
+                .board-data {
+                    background: rgba(0,0,0,0.3);
+                    color: #e2e8f0;
+                    padding: 16px;
+                    border-radius: 8px;
+                    font-size: 12px;
+                    max-height: 200px;
+                    overflow-y: auto;
+                    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
+                    border: 1px solid rgba(255,255,255,0.1);
+                }
+
+                /* Responsive */
+                @media (max-width: 600px) {
+                    .multiplayer-app {
+                        padding: 12px;
+                    }
+
+                    .join-section {
+                        flex-direction: column;
+                    }
+
+                    .session-info {
+                        flex-direction: column;
+                        gap: 16px;
+                        text-align: center;
+                    }
+
+                    button {
+                        padding: 12px 20px;
+                        font-size: 14px;
+                    }
+                }
+            `}</style>
+        </div>
+    );
+};
+
+export default MultiplayerApp;```
+
+## 📄 src/services/GameClient.ts
+```ts
+// src/services/GameClient.ts - Client gRPC-Web unifié pour Take It Easy
+import { GrpcWebFetchTransport } from '@protobuf-ts/grpcweb-transport';
+import { SessionServiceClient } from '../generated/session_service.client';
+import { GameServiceClient } from '../generated/game_service.client';
+import {
+    CreateSessionRequest,
+    JoinSessionRequest,
+    SetReadyRequest,
+    GetSessionStateRequest
+} from '../generated/session_service';
+import type { GameState } from '../generated/common';
+
+export class GameClient {
+    private sessionClient: SessionServiceClient;
+    private gameClient: GameServiceClient;
+    private transport: GrpcWebFetchTransport;
+
+    constructor() {
+        // Test direct au serveur Rust pour éviter les problèmes de proxy
+        this.transport = new GrpcWebFetchTransport({
+            baseUrl: 'http://localhost:50051', // Direct vers le serveur Rust
+            fetchInit: {
+                mode: 'cors', // Activer CORS
+                credentials: 'omit' // Pas de credentials pour éviter les conflits
+            },
+            // Configuration gRPC-Web spécifique
+            format: "binary",
+            compress: false,
+            timeout: 10000, // 10 secondes de timeout
+            // Headers explicites
+            meta: {
+                'content-type': 'application/grpc-web+proto',
+                'accept': 'application/grpc-web+proto'
+            }
+        });
+
+        this.sessionClient = new SessionServiceClient(this.transport);
+        this.gameClient = new GameServiceClient(this.transport);
+    }
+
+    // Créer une nouvelle session
+    async createSession(playerName: string) {
+        try {
+            const request: CreateSessionRequest = {
+                playerName: playerName,
+                maxPlayers: 4, // Valeur par défaut
+                gameMode: "multiplayer"
+            };
+
+            const { response } = await this.sessionClient.createSession(request);
+
+            if (response.result.oneofKind === "success") {
+                const success = response.result.success;
+                return {
+                    success: true,
+                    sessionCode: success.sessionCode,
+                    sessionId: success.sessionId, // Ajouter sessionId
+                    playerId: success.playerId,
+                    sessionState: success.player ? {
+                        sessionId: success.sessionId,
+                        players: [success.player],
+                        currentPlayerId: success.playerId,
+                        state: 0, // WAITING
+                        boardState: "{}",
+                        turnNumber: 0
+                    } as GameState : undefined
+                };
+            } else if (response.result.oneofKind === "error") {
+                return {
+                    success: false,
+                    error: response.result.error.message
+                };
+            }
+
+            return {
+                success: false,
+                error: "Réponse invalide du serveur"
+            };
+        } catch (error) {
+            console.error('Erreur création session:', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    // Rejoindre une session existante
+    async joinSession(sessionCode: string, playerName: string) {
+        try {
+            const request: JoinSessionRequest = {
+                sessionCode: sessionCode.toUpperCase(),
+                playerName: playerName
+            };
+
+            const { response } = await this.sessionClient.joinSession(request);
+
+            if (response.result.oneofKind === "success") {
+                const success = response.result.success;
+                return {
+                    success: true,
+                    sessionCode: sessionCode,
+                    sessionId: success.sessionId, // Ajouter sessionId
+                    playerId: success.playerId,
+                    sessionState: success.gameState
+                };
+            } else if (response.result.oneofKind === "error") {
+                return {
+                    success: false,
+                    error: response.result.error.message
+                };
+            }
+
+            return {
+                success: false,
+                error: "Réponse invalide du serveur"
+            };
+        } catch (error) {
+            console.error('Erreur join session:', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    // Marquer un joueur comme prêt
+    async setPlayerReady(sessionId: string, playerId: string) {
+        try {
+            const request: SetReadyRequest = {
+                sessionId: sessionId,
+                playerId: playerId,
+                ready: true
+            };
+
+            const { response } = await this.sessionClient.setReady(request);
+
+            if (response.success) {
+                return {
+                    success: true,
+                    gameStarted: response.gameStarted
+                };
+            } else if (response.error) {
+                return {
+                    success: false,
+                    error: response.error.message
+                };
+            }
+
+            return {
+                success: false,
+                error: "Échec de la requête"
+            };
+        } catch (error) {
+            console.error('Erreur set ready:', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    // Obtenir l'état d'une session
+    async getSessionState(sessionId: string) {
+        try {
+            const request: GetSessionStateRequest = {
+                sessionId: sessionId
+            };
+
+            const { response } = await this.sessionClient.getSessionState(request);
+
+            if (response.gameState) {
+                return {
+                    success: true,
+                    sessionState: response.gameState
+                };
+            } else if (response.error) {
+                return {
+                    success: false,
+                    error: response.error.message
+                };
+            }
+
+            return {
+                success: false,
+                error: "Aucun état de session retourné"
+            };
+        } catch (error) {
+            console.error('Erreur get session state:', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    // Quitter une session
+    async leaveSession(sessionId: string, playerId: string) {
+        try {
+            // Note: Vous devez implémenter une méthode LeaveSession dans votre .proto
+            // Pour l'instant, on retourne simplement success
+            return { success: true };
+        } catch (error) {
+            console.error('Erreur leave session:', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    // Extraire le message d'erreur
+    private extractErrorMessage(error: any): string {
+        if (error?.message) {
+            return error.message;
+        }
+        if (typeof error === 'string') {
+            return error;
+        }
+        return 'Erreur de connexion au serveur';
+    }
+
+    // Fermer les connexions
+    dispose() {
+        // Nettoyage si nécessaire
+    }
+}
+
+// Instance singleton
+export const gameClient = new GameClient();```
+
+## 📡 Frontend Generated: src/generated/session_service.client.ts (extrait)
+```typescript
+// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
+// tslint:disable
+import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
+import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
+import { SessionService } from "./session_service";
+import type { GetSessionStateResponse } from "./session_service";
+import type { GetSessionStateRequest } from "./session_service";
+import type { SetReadyResponse } from "./session_service";
+import type { SetReadyRequest } from "./session_service";
+import type { JoinSessionResponse } from "./session_service";
+import type { JoinSessionRequest } from "./session_service";
+import { stackIntercept } from "@protobuf-ts/runtime-rpc";
+import type { CreateSessionResponse } from "./session_service";
+import type { CreateSessionRequest } from "./session_service";
+import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
+import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
+/**
+ * @generated from protobuf service takeiteasygame.v1.SessionService
+ */
+export interface ISessionServiceClient {
+    /**
+     * @generated from protobuf rpc: CreateSession
+     */
+    createSession(input: CreateSessionRequest, options?: RpcOptions): UnaryCall<CreateSessionRequest, CreateSessionResponse>;
+    /**
+     * @generated from protobuf rpc: JoinSession
+     */
+    joinSession(input: JoinSessionRequest, options?: RpcOptions): UnaryCall<JoinSessionRequest, JoinSessionResponse>;
+    /**
+// ... (fichier tronqué)
+```
+
+## 📡 Frontend Generated: src/generated/game_service.ts (extrait)
+```typescript
+// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
+// tslint:disable
+import { ServiceType } from "@protobuf-ts/runtime-rpc";
+import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
+import type { IBinaryWriter } from "@protobuf-ts/runtime";
+import { WireType } from "@protobuf-ts/runtime";
+import type { BinaryReadOptions } from "@protobuf-ts/runtime";
+import type { IBinaryReader } from "@protobuf-ts/runtime";
+import { UnknownFieldHandler } from "@protobuf-ts/runtime";
+import type { PartialMessage } from "@protobuf-ts/runtime";
+import { reflectionMergePartial } from "@protobuf-ts/runtime";
+import { MessageType } from "@protobuf-ts/runtime";
+import { GameState } from "./common";
+import { Error } from "./common";
+/**
+ * @generated from protobuf message takeiteasygame.v1.MakeMoveRequest
+ */
+export interface MakeMoveRequest {
+    /**
+     * @generated from protobuf field: string session_id = 1
+     */
+    sessionId: string;
+    /**
+     * @generated from protobuf field: string player_id = 2
+     */
+    playerId: string;
+    /**
+     * @generated from protobuf field: string move_data = 3
+     */
+// ... (fichier tronqué)
+```
+
+## 📡 Frontend Generated: src/generated/session_service.ts (extrait)
+```typescript
+// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
+// tslint:disable
+import { ServiceType } from "@protobuf-ts/runtime-rpc";
+import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
+import type { IBinaryWriter } from "@protobuf-ts/runtime";
+import { WireType } from "@protobuf-ts/runtime";
+import type { BinaryReadOptions } from "@protobuf-ts/runtime";
+import type { IBinaryReader } from "@protobuf-ts/runtime";
+import { UnknownFieldHandler } from "@protobuf-ts/runtime";
+import type { PartialMessage } from "@protobuf-ts/runtime";
+import { reflectionMergePartial } from "@protobuf-ts/runtime";
+import { MessageType } from "@protobuf-ts/runtime";
+import { GameState } from "./common";
+import { Error } from "./common";
+import { Player } from "./common";
+// ============================================================================
+// MESSAGES SESSION SERVICE
+// ============================================================================
+
+/**
+ * @generated from protobuf message takeiteasygame.v1.CreateSessionRequest
+ */
+export interface CreateSessionRequest {
+    /**
+     * @generated from protobuf field: string player_name = 1
+     */
+    playerName: string;
+    /**
+     * @generated from protobuf field: int32 max_players = 2
+// ... (fichier tronqué)
+```
+
diff --git a/frontend/package.json b/frontend/package.json
index bee3b23..1b935cc 100644
--- a/frontend/package.json
+++ b/frontend/package.json
@@ -12,6 +12,7 @@
   },
   "license": "MIT",
   "devDependencies": {
+    "@protobuf-ts/plugin": "^2.11.0",
     "@solidjs/testing-library": "^0.8.10",
     "@testing-library/jest-dom": "^6.6.3",
     "jsdom": "^25.0.1",
@@ -21,6 +22,9 @@
     "vitest": "^3.0.0"
   },
   "dependencies": {
+    "@protobuf-ts/grpcweb-transport": "^2.11.0",
+    "@protobuf-ts/runtime": "^2.11.0",
+    "@protobuf-ts/runtime-rpc": "^2.11.0",
     "solid-js": "^1.9.5"
   }
 }
diff --git a/frontend/src/components/.MultiplayerApp.tsx.swp b/frontend/src/components/.MultiplayerApp.tsx.swp
deleted file mode 100644
index 35d065a..0000000
Binary files a/frontend/src/components/.MultiplayerApp.tsx.swp and /dev/null differ
diff --git a/frontend/src/components/MultiplayerApp.tsx b/frontend/src/components/MultiplayerApp.tsx
index 794961e..1a83fca 100644
--- a/frontend/src/components/MultiplayerApp.tsx
+++ b/frontend/src/components/MultiplayerApp.tsx
@@ -1,4 +1,4 @@
-// src/components/MultiplayerApp.refactored.tsx - Version refactorisée et modulaire
+// src/components/MultiplayerApp.tsx - Version refactorisée et modulaire
 import { Component, createEffect, onMount, Show } from 'solid-js';
 import { SessionState } from '../generated/common';
 
@@ -15,8 +15,8 @@ import { ConnectionInterface } from './ui/ConnectionInterface';
 import { PlayersList } from './ui/PlayersList';
 import { CurrentTileDisplay } from './ui/CurrentTileDisplay';
 import { StatusMessages } from './ui/StatusMessages';
-import { DebugPanel } from './ui/DebugPanel';
 import { MCTSInterface } from './ui/MCTSInterface';
+import { HexagonalGameBoard } from './ui/HexagonalGameBoard'; // ⚠️ IMPORT CORRIGÉ
 
 // Import du CSS externe
 import '../styles/multiplayer.css';
@@ -31,7 +31,28 @@ const MultiplayerApp: Component = () => {
     // ============================================================================
 
     const gameState = useGameState();
-    
+    const updatePlateauFunction = () => {
+        const currentSession = gameState.session();
+        if (currentSession && currentSession.playerId.includes('viewer')) {
+            // Mode viewer : afficher tous les plateaux
+            return (state: any) => GameStateManager.updatePlateauTilesForViewer(
+                state,
+                gameState.setPlateauTiles,
+                gameState.setAvailablePositions,
+                gameState.session,
+                gameState.addDebugLog
+            );
+        } else {
+            // Mode normal : afficher le plateau du joueur
+            return (state: any) => GameStateManager.updatePlateauTiles(
+                state,
+                gameState.setPlateauTiles,
+                gameState.setAvailablePositions,
+                gameState.session,
+                gameState.addDebugLog
+            );
+        }
+    };
     const gameActions = useGameActions(
         gameState.session,
         gameState.setLoading,
@@ -43,15 +64,8 @@ const MultiplayerApp: Component = () => {
         gameState.setIsGameStarted,
         gameState.setMyTurn,
         gameState.setMctsLastMove,
-        (state) => GameStateManager.updatePlateauTiles(
-            state,
-            gameState.setPlateauTiles,
-            gameState.setAvailablePositions,
-            gameState.session,
-            gameState.addDebugLog
-        ),
-        gameState.addDebugLog,
-        GameStateManager.generateTileImagePath
+        updatePlateauFunction(), // ✅ Fonction adaptée
+        gameState.addDebugLog
     );
 
     const polling = usePolling(
@@ -64,14 +78,7 @@ const MultiplayerApp: Component = () => {
         gameState.setMyTurn,
         gameState.setIsGameStarted,
         gameState.setStatusMessage,
-        (state) => GameStateManager.updatePlateauTiles(
-            state,
-            gameState.setPlateauTiles,
-            gameState.setAvailablePositions,
-            gameState.session,
-            gameState.addDebugLog
-        ),
-        GameStateManager.generateTileImagePath,
+        updatePlateauFunction(), // ✅ Fonction adaptée
         GameStateManager.convertSessionState,
         gameState.addDebugLog
     );
@@ -173,7 +180,7 @@ const MultiplayerApp: Component = () => {
     };
 
     // ============================================================================
-    // RENDU DU PLATEAU DE JEU (simplifié)
+    // RENDU DU PLATEAU DE JEU (CORRIGÉ AVEC HEXAGONES)
     // ============================================================================
 
     const renderGameBoard = () => {
@@ -241,33 +248,31 @@ const MultiplayerApp: Component = () => {
                             </Show>
                         </div>
 
-                        {/* Plateau Canvas - pour l'instant gardé simple */}
-                        <div class="classic-board-area">
-                            <canvas
-                                width="500"
-                                height="500"
-                                class="classic-game-canvas"
-                                onClick={(e) => {
-                                    // Logique de clic sur le plateau - simplifiée pour l'exemple
-                                    // En production, on extrairait aussi ceci dans un composant GameCanvas
-                                    if (gameState.myTurn()) {
-                                        // Mock click handler - position aléatoire pour l'exemple
-                                        const availablePos = gameState.availablePositions();
-                                        if (availablePos.length > 0) {
-                                            handlePlayMove(availablePos[0]);
-                                        }
-                                    }
-                                }}
-                            />
-                            <div class="classic-instructions">
-                                <Show when={gameState.myTurn()}>
-                                    <p>✨ Cliquez sur un hexagone en surbrillance pour placer votre tuile</p>
-                                </Show>
-                                <Show when={!gameState.myTurn() && gameState.isGameStarted()}>
-                                    <p>⏳ En attente du tour de l'autre joueur ou de MCTS...</p>
-                                </Show>
-                            </div>
-                        </div>
+                        {/* 🔧 PLATEAU HEXAGONAL COMPLET - REMPLACEMENT DU CANVAS VIDE */}
+                        <HexagonalGameBoard
+                            plateauTiles={gameState.plateauTiles}
+                            availablePositions={gameState.availablePositions}
+                            myTurn={gameState.myTurn}
+                            session={gameState.session}
+                            onTileClick={handlePlayMove}
+                            addDebugLog={gameState.addDebugLog}
+                        />
+                    </div>
+                </Show>
+
+                <Show when={state.state === SessionState.FINISHED}>
+                    <div class="game-finished">
+                        <h2>🎉 Partie terminée !</h2>
+                        <PlayersList
+                            gameState={gameState.gameState}
+                            isCurrentPlayer={gameState.isCurrentPlayer}
+                            getPlayerStatus={gameState.getPlayerStatus}
+                            isPlayerReady={gameState.isPlayerReady}
+                            loading={gameState.loading}
+                            onSetReady={handleSetReady}
+                            onOpenMctsSession={handleOpenMctsSession}
+                            session={gameState.session}
+                        />
                     </div>
                 </Show>
             </div>
@@ -293,13 +298,7 @@ const MultiplayerApp: Component = () => {
             <Show when={!gameState.session() || gameState.session()?.playerId !== 'mcts_ai'}>
                 <h1>🎮 Take It Easy - Multiplayer vs MCTS</h1>
 
-                {/* Panel de debug */}
-                <DebugPanel
-                    showDebugLogs={gameState.showDebugLogs}
-                    setShowDebugLogs={gameState.setShowDebugLogs}
-                    debugLogs={gameState.debugLogs}
-                    setDebugLogs={gameState.setDebugLogs}
-                />
+
 
                 {/* Messages d'état */}
                 <StatusMessages
diff --git a/frontend/src/components/ui/HexagonalGameBoard.tsx b/frontend/src/components/ui/HexagonalGameBoard.tsx
index e69de29..b73d753 100644
--- a/frontend/src/components/ui/HexagonalGameBoard.tsx
+++ b/frontend/src/components/ui/HexagonalGameBoard.tsx
@@ -0,0 +1,398 @@
+// components/ui/HexagonalGameBoard.tsx - Version optimisée
+import { Component, createEffect, createSignal, onCleanup, Show } from 'solid-js';
+
+interface HexagonalGameBoardProps {
+    plateauTiles: () => {[playerId: string]: string[]};
+    availablePositions: () => number[];
+    myTurn: () => boolean;
+    session: () => { playerId: string } | null;
+    onTileClick: (position: number) => void;
+    addDebugLog: (message: string) => void;
+}
+
+export const HexagonalGameBoard: Component<HexagonalGameBoardProps> = (props) => {
+    let canvasRef: HTMLCanvasElement | undefined;
+
+    // 🚀 CACHE D'IMAGES POUR ÉVITER LES RECHARGEMENTS
+    const [imageCache, setImageCache] = createSignal<Map<string, HTMLImageElement>>(new Map());
+
+    // 🚀 ÉTAT PRÉCÉDENT POUR ÉVITER LES REDRAWS INUTILES
+    const [lastDrawState, setLastDrawState] = createSignal<string>('');
+
+    // Positions hexagonales exactes du plateau Take It Easy
+    const hexPositions = [
+        [-2, 2], [-2.3, 4], [-2.65, 6],
+        [-1, 1], [-1.3, 3], [-1.6, 5], [-1.95, 7],
+        [0, 0], [-0.3, 2], [-0.6, 4], [-0.9, 6], [-1.25, 8],
+        [0.7, 1], [0.4, 3], [0.1, 5], [-0.2, 7],
+        [1.4, 2], [1.1, 4], [0.8, 6]
+    ];
+
+    const hexRadius = 35;
+    const hexWidth = Math.sqrt(3) * hexRadius;
+    const hexHeight = 2 * hexRadius;
+    const offsetY = 0.45 * hexHeight;
+
+    /**
+     * 🚀 CACHE D'IMAGES OPTIMISÉ
+     */
+    const loadImageCached = (src: string): Promise<HTMLImageElement> => {
+        return new Promise((resolve, reject) => {
+            // ✅ SKIP pour chaînes vides ou images 000.png
+            if (!src || src === '' || src.includes('000.png')) {
+                // Créer une image vide fictive
+                const emptyImg = new Image();
+                emptyImg.width = 1;
+                emptyImg.height = 1;
+                resolve(emptyImg);
+                return;
+            }
+
+            const cache = imageCache();
+
+            // Vérifier si l'image est déjà en cache
+            if (cache.has(src)) {
+                resolve(cache.get(src)!);
+                return;
+            }
+
+            // Charger l'image une seule fois
+            const img = new Image();
+            img.onload = () => {
+                // Ajouter au cache
+                const newCache = new Map(cache);
+                newCache.set(src, img);
+                setImageCache(newCache);
+                resolve(img);
+            };
+            img.onerror = (error) => {
+                // ✅ GÉRER l'erreur gracieusement au lieu de rejeter
+                console.warn(`⚠️ Image non trouvée: ${src}`);
+                // Retourner image vide au lieu d'erreur
+                const emptyImg = new Image();
+                emptyImg.width = 1;
+                emptyImg.height = 1;
+                resolve(emptyImg);
+            };
+            img.src = src;
+        });
+    };
+
+    /**
+     * Dessiner un hexagone individuel
+     */
+    const drawHexagon = (ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, fillColor?: string) => {
+        const angleStep = Math.PI / 3;
+
+        ctx.beginPath();
+        for (let i = 0; i < 6; i++) {
+            const angle = angleStep * i;
+            const xOffset = x + radius * Math.cos(angle);
+            const yOffset = y + radius * Math.sin(angle);
+            if (i === 0) ctx.moveTo(xOffset, yOffset);
+            else ctx.lineTo(xOffset, yOffset);
+        }
+        ctx.closePath();
+
+        // Remplir l'hexagone si une couleur est fournie
+        if (fillColor) {
+            ctx.fillStyle = fillColor;
+            ctx.fill();
+        }
+
+        // Contour blanc
+        ctx.strokeStyle = 'white';
+        ctx.lineWidth = 2;
+        ctx.stroke();
+    };
+
+    /**
+     * Calculer la distance entre un point et le centre d'un hexagone
+     */
+    const isPointInHexagon = (pointX: number, pointY: number, hexX: number, hexY: number, radius: number): boolean => {
+        const dx = pointX - hexX;
+        const dy = pointY - hexY;
+        return Math.sqrt(dx * dx + dy * dy) < radius;
+    };
+
+    /**
+     * 🚀 GÉNERER UN HASH DE L'ÉTAT POUR ÉVITER LES REDRAWS INUTILES
+     */
+    const generateStateHash = (): string => {
+        const currentSession = props.session();
+        const playerTiles = currentSession ? props.plateauTiles()[currentSession.playerId] || [] : [];
+        const availablePos = props.availablePositions();
+        const isMyTurn = props.myTurn();
+
+        return JSON.stringify({
+            tiles: playerTiles,
+            available: availablePos.toSorted((a, b) => (a - b)),
+            myTurn: isMyTurn,
+            playerId: currentSession?.playerId
+        });
+    };
+    const getDisplayedPlateau = (): string[] => {
+        const currentSession = props.session();
+        const allPlateaus = props.plateauTiles();
+
+        if (currentSession && currentSession.playerId.includes('viewer')) {
+            // Mode viewer : afficher le plateau MCTS
+            const mctsPlateau = allPlateaus['mcts_ai'];
+            if (mctsPlateau) {
+                props.addDebugLog(`👁️ Affichage plateau MCTS (${mctsPlateau.length} positions)`);
+                return mctsPlateau;
+            }
+            // Fallback : afficher le premier plateau disponible
+            const firstPlayerId = Object.keys(allPlateaus)[0];
+            if (firstPlayerId) {
+                props.addDebugLog(`👁️ Fallback: affichage plateau ${firstPlayerId}`);
+                return allPlateaus[firstPlayerId];
+            }
+            return [];
+        } else {
+            // Mode normal : afficher le plateau du joueur actuel
+            const playerTiles = currentSession ? allPlateaus[currentSession.playerId] || [] : [];
+            props.addDebugLog(`🎮 Affichage plateau joueur (${playerTiles.length} positions)`);
+            return playerTiles;
+        }
+    };
+    /**
+     * 🚀 DESSINER LE PLATEAU (OPTIMISÉ)
+     */
+    const drawHexagonalGrid = async (ctx: CanvasRenderingContext2D, canvas: HTMLCanvasElement) => {
+        // Vérifier si on a besoin de redessiner
+        const newStateHash = generateStateHash();
+        if (newStateHash === lastDrawState()) {
+            return; // Pas de changement, pas de redraw
+        }
+
+        const startTime = performance.now();
+
+        // Effacer le canvas
+        ctx.clearRect(0, 0, canvas.width, canvas.height);
+
+        // Fond noir
+        ctx.fillStyle = '#1e1e1e';
+        ctx.fillRect(0, 0, canvas.width, canvas.height);
+
+        // Calculer l'origine du plateau
+        const gridOriginX = canvas.width / 2 - hexWidth;
+        const gridOriginY = canvas.height / 2 - 2 * offsetY;
+
+        // Obtenir les données actuelles
+        const currentSession = props.session();
+        const allPlateaus = props.plateauTiles();
+        const availablePos = props.availablePositions();
+        const isMyTurn = props.myTurn();
+        const isViewerMode = currentSession && currentSession.playerId.includes('viewer');
+
+        // 🔧 NOUVEAU: Logique claire pour le plateau à afficher
+        let playerTiles: string[] = [];
+        let displayMode = '';
+
+        if (isViewerMode) {
+            // Mode viewer : SEULEMENT le plateau MCTS
+            playerTiles = allPlateaus['mcts_ai'] || [];
+            displayMode = 'MCTS Viewer';
+            props.addDebugLog(`👁️ Rendu plateau MCTS: ${playerTiles.filter(t => t !== '').length} tuiles`);
+        } else {
+            // Mode normal : plateau du joueur actuel
+            playerTiles = currentSession ? allPlateaus[currentSession.playerId] || [] : [];
+            displayMode = 'Player';
+            props.addDebugLog(`🎮 Rendu plateau joueur: ${playerTiles.filter(t => t !== '').length} tuiles`);
+        }
+
+        // Dessiner les hexagones avec couleurs unifiées
+        hexPositions.forEach(([q, r], index) => {
+            const x = gridOriginX + q * hexWidth + r * (hexWidth / 6) + 50;
+            const y = gridOriginY + r * offsetY - 50;
+
+            // 🔧 COULEURS SIMPLIFIÉES ET COHÉRENTES
+            let fillColor: string | undefined;
+
+            if (playerTiles[index] && playerTiles[index] !== '') {
+                // ✅ TUILE PLACÉE - même couleur partout
+                fillColor = isViewerMode
+                    ? 'rgba(139, 92, 246, 0.3)'  // Violet pour MCTS viewer
+                    : 'rgba(34, 197, 94, 0.3)';  // Vert pour joueur normal
+            } else if (!isViewerMode && availablePos.includes(index) && isMyTurn) {
+                // ✅ POSITION DISPONIBLE - seulement pour le joueur actif
+                fillColor = 'rgba(0, 255, 255, 0.3)'; // Cyan
+            }
+            // Sinon pas de couleur de fond (case vide)
+
+            // Dessiner l'hexagone
+            drawHexagon(ctx, x, y, hexRadius, fillColor);
+
+            // 🔧 LABELS SIMPLIFIÉS
+            if (isViewerMode && playerTiles[index] && playerTiles[index] !== '') {
+                // Label pour tuiles MCTS placées
+                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
+                ctx.font = 'bold 12px Arial';
+                ctx.textAlign = 'center';
+                ctx.fillText('🤖', x, y + 4);
+            } else if (!isViewerMode && availablePos.includes(index) && isMyTurn) {
+                // Numéro pour positions disponibles
+                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
+                ctx.font = '10px Arial';
+                ctx.textAlign = 'center';
+                ctx.fillText(index.toString(), x, y + 3);
+            }
+        });
+
+        // 🚀 CHARGER ET DESSINER LES IMAGES EN PARALLÈLE
+        const imagePromises: Promise<void>[] = [];
+
+        hexPositions.forEach(([q, r], index) => {
+            if (playerTiles[index] && playerTiles[index] !== '') {
+                const x = gridOriginX + q * hexWidth + r * (hexWidth / 6) + 50;
+                const y = gridOriginY + r * offsetY - 50;
+
+                const imagePromise = loadImageCached(playerTiles[index])
+                    .then(img => {
+                        const scaledWidth = img.width / 3;
+                        const scaledHeight = img.height / 3;
+
+                        // Dessiner l'image
+                        ctx.drawImage(
+                            img,
+                            x - scaledWidth / 2,
+                            y - scaledHeight / 2,
+                            scaledWidth,
+                            scaledHeight
+                        );
+
+                        // Redessiner le contour par-dessus
+                        drawHexagon(ctx, x, y, hexRadius);
+                    })
+                    .catch(err => {
+                        console.warn(`Erreur chargement image ${playerTiles[index]}:`, err);
+                    });
+
+                imagePromises.push(imagePromise);
+            }
+        });
+
+        // Attendre que toutes les images soient chargées
+        await Promise.all(imagePromises);
+
+        // Sauvegarder le nouvel état
+        setLastDrawState(newStateHash);
+
+        const endTime = performance.now();
+        props.addDebugLog(`🎨 Plateau redessiné en ${(endTime - startTime).toFixed(1)}ms (${imagePromises.length} images)`);
+    };
+
+    /**
+     * 🚀 GESTION OPTIMISÉE DES CLICS (AVEC DEBOUNCE)
+     */
+    let clickTimeout: ReturnType<typeof setTimeout> | undefined;
+
+    const handleCanvasClick = (e: MouseEvent) => {
+        const currentSession = props.session();
+        const isViewerMode = currentSession && currentSession.playerId.includes('viewer');
+
+        if (isViewerMode) {
+            props.addDebugLog('👁️ Mode viewer : clics désactivés');
+            return;
+        }
+        // Debounce pour éviter les clics multiples
+        if (clickTimeout) {
+            clearTimeout(clickTimeout);
+        }
+
+        clickTimeout = setTimeout(() => {
+            if (!canvasRef || !props.myTurn()) {
+                props.addDebugLog(`❌ Clic ignoré: ${!canvasRef ? 'pas de canvas' : 'pas mon tour'}`);
+                return;
+            }
+
+            const currentSession = props.session();
+            if (!currentSession) {
+                props.addDebugLog(`❌ Clic ignoré: pas de session`);
+                return;
+            }
+
+            const rect = canvasRef.getBoundingClientRect();
+            const clickX = e.clientX - rect.left;
+            const clickY = e.clientY - rect.top;
+
+            const gridOriginX = canvasRef.width / 2 - hexWidth;
+            const gridOriginY = canvasRef.height / 2 - 2 * offsetY;
+
+            // Chercher quel hexagone a été cliqué
+            for (let index = 0; index < hexPositions.length; index++) {
+                const [q, r] = hexPositions[index];
+                const x = gridOriginX + q * hexWidth + r * (hexWidth / 6) + 50;
+                const y = gridOriginY + r * offsetY - 50;
+
+                if (isPointInHexagon(clickX, clickY, x, y, hexRadius)) {
+                    if (props.availablePositions().includes(index)) {
+                        props.addDebugLog(`✅ Clic position ${index}`);
+                        props.onTileClick(index);
+                    } else {
+                        props.addDebugLog(`❌ Position ${index} non disponible`);
+                    }
+                    return;
+                }
+            }
+
+            props.addDebugLog(`❌ Clic hors hexagones`);
+        }, 100); // Debounce de 100ms
+    };
+
+    // 🚀 EFFET OPTIMISÉ AVEC VÉRIFICATION DE CHANGEMENT
+    createEffect(() => {
+        if (canvasRef) {
+            const ctx = canvasRef.getContext('2d');
+            if (ctx) {
+                drawHexagonalGrid(ctx, canvasRef);
+            }
+        }
+    });
+
+    // Nettoyer le timeout à la destruction
+    onCleanup(() => {
+        if (clickTimeout) {
+            clearTimeout(clickTimeout);
+        }
+    });
+
+    return (
+        <div class="classic-board-area">
+            <canvas
+                ref={canvasRef!}
+                width="500"
+                height="500"
+                class="classic-game-canvas"
+                onClick={handleCanvasClick}
+                style={{
+                    border: '2px solid #333',
+                    'border-radius': '8px',
+                    cursor: props.myTurn() && !props.session()?.playerId.includes('viewer') ? 'pointer' : 'default'
+                }}
+            />
+
+            {/* Instructions adaptées */}
+            <div class="classic-instructions">
+                <Show when={props.session()?.playerId.includes('viewer')}>
+                    <p style={{ color: '#8b5cf6', 'font-weight': 'bold' }}>
+                        👁️ Mode Observateur - Plateau MCTS affiché
+                    </p>
+                    <p style={{ color: '#666', 'font-size': '0.8em' }}>
+                        Les tuiles violettes montrent les mouvements de l'IA
+                    </p>
+                </Show>
+
+                <Show when={!props.session()?.playerId.includes('viewer')}>
+                    {/* Instructions normales existantes */}
+                    <Show when={props.myTurn() && props.availablePositions().length > 0}>
+                        <p style={{ color: '#00ffff', 'font-weight': 'bold' }}>
+                            ✨ Cliquez sur un hexagone cyan pour placer votre tuile
+                        </p>
+                    </Show>
+                </Show>
+            </div>
+        </div>
+    );
+};
\ No newline at end of file
diff --git a/frontend/src/components/ui/MCTSInterface.tsx b/frontend/src/components/ui/MCTSInterface.tsx
index 7121edd..4c2a032 100644
--- a/frontend/src/components/ui/MCTSInterface.tsx
+++ b/frontend/src/components/ui/MCTSInterface.tsx
@@ -11,14 +11,25 @@ interface MCTSInterfaceProps {
  * Interface spécialisée pour l'affichage MCTS
  * Composant dédié pour une expérience utilisateur différenciée
  */
+// Dans MCTSInterface.tsx - AMÉLIORER avec info plateau MCTS
 export const MCTSInterface: Component<MCTSInterfaceProps> = (props) => {
     return (
         <div class="mcts-interface">
             <div class="mcts-header">
-                <h1>🤖 Interface MCTS IA</h1>
+                <h1>👁️ MCTS Observer</h1>
                 <div class="mcts-session-info">
                     <span>Session: <strong>{props.sessionCode()}</strong></span>
-                    <span>Mode: <strong>Observation IA</strong></span>
+                    <span>Mode: <strong>🤖 Plateau MCTS IA</strong></span>
+                </div>
+            </div>
+
+            <div class="viewer-info">
+                <div class="viewer-status">
+                    <span class="viewer-icon">🤖</span>
+                    <span>Vous observez les mouvements de l'IA MCTS</span>
+                </div>
+                <div class="viewer-note">
+                    <small>Les tuiles violettes montrent où MCTS a joué ses coups</small>
                 </div>
             </div>
 
@@ -36,12 +47,12 @@ export const MCTSInterface: Component<MCTSInterfaceProps> = (props) => {
                 </Show>
                 <Show when={!props.myTurn()}>
                     <div class="mcts-waiting">
-                        <span>⏳ En attente des joueurs humains...</span>
+                        <span>⏳ En attente du tour de MCTS...</span>
                     </div>
                 </Show>
             </div>
 
-            {/* Afficher le plateau normal */}
+            {/* Afficher le plateau avec focus MCTS */}
             {props.renderGameBoard()}
         </div>
     );
diff --git a/frontend/src/generated/common.ts b/frontend/src/generated/common.ts
index 42aab81..0b594c7 100644
--- a/frontend/src/generated/common.ts
+++ b/frontend/src/generated/common.ts
@@ -1,4 +1,4 @@
-// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated by protobuf-ts 2.11.0
 // @generated from protobuf file "common.proto" (package "takeiteasygame.v1", syntax proto3)
 // tslint:disable
 import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
diff --git a/frontend/src/generated/game_service.client.ts b/frontend/src/generated/game_service.client.ts
index 90fee40..e5c0c09 100644
--- a/frontend/src/generated/game_service.client.ts
+++ b/frontend/src/generated/game_service.client.ts
@@ -1,9 +1,13 @@
-// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated by protobuf-ts 2.11.0
 // @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
 // tslint:disable
 import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
 import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
 import { GameService } from "./game_service";
+import type { GetGameStateResponse } from "./game_service";
+import type { GetGameStateRequest } from "./game_service";
+import type { StartTurnResponse } from "./game_service";
+import type { StartTurnRequest } from "./game_service";
 import type { GetAvailableMovesResponse } from "./game_service";
 import type { GetAvailableMovesRequest } from "./game_service";
 import { stackIntercept } from "@protobuf-ts/runtime-rpc";
@@ -27,6 +31,16 @@ export interface IGameServiceClient {
      * @generated from protobuf rpc: GetAvailableMoves
      */
     getAvailableMoves(input: GetAvailableMovesRequest, options?: RpcOptions): UnaryCall<GetAvailableMovesRequest, GetAvailableMovesResponse>;
+    /**
+     * 🎲 NOUVELLES MÉTHODES GAMEPLAY
+     *
+     * @generated from protobuf rpc: StartTurn
+     */
+    startTurn(input: StartTurnRequest, options?: RpcOptions): UnaryCall<StartTurnRequest, StartTurnResponse>;
+    /**
+     * @generated from protobuf rpc: GetGameState
+     */
+    getGameState(input: GetGameStateRequest, options?: RpcOptions): UnaryCall<GetGameStateRequest, GetGameStateResponse>;
 }
 /**
  * @generated from protobuf service takeiteasygame.v1.GameService
@@ -55,4 +69,20 @@ export class GameServiceClient implements IGameServiceClient, ServiceInfo {
         const method = this.methods[1], opt = this._transport.mergeOptions(options);
         return stackIntercept<GetAvailableMovesRequest, GetAvailableMovesResponse>("unary", this._transport, method, opt, input);
     }
+    /**
+     * 🎲 NOUVELLES MÉTHODES GAMEPLAY
+     *
+     * @generated from protobuf rpc: StartTurn
+     */
+    startTurn(input: StartTurnRequest, options?: RpcOptions): UnaryCall<StartTurnRequest, StartTurnResponse> {
+        const method = this.methods[2], opt = this._transport.mergeOptions(options);
+        return stackIntercept<StartTurnRequest, StartTurnResponse>("unary", this._transport, method, opt, input);
+    }
+    /**
+     * @generated from protobuf rpc: GetGameState
+     */
+    getGameState(input: GetGameStateRequest, options?: RpcOptions): UnaryCall<GetGameStateRequest, GetGameStateResponse> {
+        const method = this.methods[3], opt = this._transport.mergeOptions(options);
+        return stackIntercept<GetGameStateRequest, GetGameStateResponse>("unary", this._transport, method, opt, input);
+    }
 }
diff --git a/frontend/src/generated/game_service.ts b/frontend/src/generated/game_service.ts
index 689de0f..6333060 100644
--- a/frontend/src/generated/game_service.ts
+++ b/frontend/src/generated/game_service.ts
@@ -1,4 +1,4 @@
-// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated by protobuf-ts 2.11.0
 // @generated from protobuf file "game_service.proto" (package "takeiteasygame.v1", syntax proto3)
 // tslint:disable
 import { ServiceType } from "@protobuf-ts/runtime-rpc";
@@ -104,6 +104,102 @@ export interface GetAvailableMovesResponse {
      */
     error?: Error;
 }
+/**
+ * Démarrer un nouveau tour
+ *
+ * @generated from protobuf message takeiteasygame.v1.StartTurnRequest
+ */
+export interface StartTurnRequest {
+    /**
+     * @generated from protobuf field: string session_id = 1
+     */
+    sessionId: string;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.StartTurnResponse
+ */
+export interface StartTurnResponse {
+    /**
+     * @generated from protobuf field: bool success = 1
+     */
+    success: boolean;
+    /**
+     * @generated from protobuf field: string announced_tile = 2
+     */
+    announcedTile: string; // "5-3-7"
+    /**
+     * @generated from protobuf field: string tile_image = 3
+     */
+    tileImage: string; // "537.png"
+    /**
+     * @generated from protobuf field: int32 turn_number = 4
+     */
+    turnNumber: number;
+    /**
+     * @generated from protobuf field: repeated string waiting_for_players = 5
+     */
+    waitingForPlayers: string[];
+    /**
+     * @generated from protobuf field: string game_state = 6
+     */
+    gameState: string; // JSON complet de l'état
+    /**
+     * @generated from protobuf field: takeiteasygame.v1.Error error = 7
+     */
+    error?: Error;
+}
+/**
+ * Obtenir l'état complet du jeu
+ *
+ * @generated from protobuf message takeiteasygame.v1.GetGameStateRequest
+ */
+export interface GetGameStateRequest {
+    /**
+     * @generated from protobuf field: string session_id = 1
+     */
+    sessionId: string;
+}
+/**
+ * @generated from protobuf message takeiteasygame.v1.GetGameStateResponse
+ */
+export interface GetGameStateResponse {
+    /**
+     * @generated from protobuf field: bool success = 1
+     */
+    success: boolean;
+    /**
+     * @generated from protobuf field: string game_state = 2
+     */
+    gameState: string; // JSON complet de l'état
+    /**
+     * @generated from protobuf field: string current_tile = 3
+     */
+    currentTile: string; // "5-3-7" ou vide
+    /**
+     * @generated from protobuf field: string current_tile_image = 4
+     */
+    currentTileImage: string; // ✅ NOUVEAU: "../image/537.png"
+    /**
+     * @generated from protobuf field: int32 current_turn = 5
+     */
+    currentTurn: number; // Numéro du tour (0-18) - RENUMÉROTÉ
+    /**
+     * @generated from protobuf field: repeated string waiting_for_players = 6
+     */
+    waitingForPlayers: string[]; // RENUMÉROTÉ
+    /**
+     * @generated from protobuf field: bool is_game_finished = 7
+     */
+    isGameFinished: boolean; // RENUMÉROTÉ
+    /**
+     * @generated from protobuf field: string final_scores = 8
+     */
+    finalScores: string; // JSON des scores finaux - RENUMÉROTÉ
+    /**
+     * @generated from protobuf field: takeiteasygame.v1.Error error = 9
+     */
+    error?: Error; // RENUMÉROTÉ
+}
 // @generated message type with reflection information, may provide speed optimized methods
 class MakeMoveRequest$Type extends MessageType<MakeMoveRequest> {
     constructor() {
@@ -414,10 +510,310 @@ class GetAvailableMovesResponse$Type extends MessageType<GetAvailableMovesRespon
  * @generated MessageType for protobuf message takeiteasygame.v1.GetAvailableMovesResponse
  */
 export const GetAvailableMovesResponse = new GetAvailableMovesResponse$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class StartTurnRequest$Type extends MessageType<StartTurnRequest> {
+    constructor() {
+        super("takeiteasygame.v1.StartTurnRequest", [
+            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
+        ]);
+    }
+    create(value?: PartialMessage<StartTurnRequest>): StartTurnRequest {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.sessionId = "";
+        if (value !== undefined)
+            reflectionMergePartial<StartTurnRequest>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartTurnRequest): StartTurnRequest {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string session_id */ 1:
+                    message.sessionId = reader.string();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: StartTurnRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string session_id = 1; */
+        if (message.sessionId !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.StartTurnRequest
+ */
+export const StartTurnRequest = new StartTurnRequest$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class StartTurnResponse$Type extends MessageType<StartTurnResponse> {
+    constructor() {
+        super("takeiteasygame.v1.StartTurnResponse", [
+            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
+            { no: 2, name: "announced_tile", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 3, name: "tile_image", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 4, name: "turn_number", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
+            { no: 5, name: "waiting_for_players", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
+            { no: 6, name: "game_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 7, name: "error", kind: "message", T: () => Error }
+        ]);
+    }
+    create(value?: PartialMessage<StartTurnResponse>): StartTurnResponse {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.success = false;
+        message.announcedTile = "";
+        message.tileImage = "";
+        message.turnNumber = 0;
+        message.waitingForPlayers = [];
+        message.gameState = "";
+        if (value !== undefined)
+            reflectionMergePartial<StartTurnResponse>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartTurnResponse): StartTurnResponse {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* bool success */ 1:
+                    message.success = reader.bool();
+                    break;
+                case /* string announced_tile */ 2:
+                    message.announcedTile = reader.string();
+                    break;
+                case /* string tile_image */ 3:
+                    message.tileImage = reader.string();
+                    break;
+                case /* int32 turn_number */ 4:
+                    message.turnNumber = reader.int32();
+                    break;
+                case /* repeated string waiting_for_players */ 5:
+                    message.waitingForPlayers.push(reader.string());
+                    break;
+                case /* string game_state */ 6:
+                    message.gameState = reader.string();
+                    break;
+                case /* takeiteasygame.v1.Error error */ 7:
+                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: StartTurnResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* bool success = 1; */
+        if (message.success !== false)
+            writer.tag(1, WireType.Varint).bool(message.success);
+        /* string announced_tile = 2; */
+        if (message.announcedTile !== "")
+            writer.tag(2, WireType.LengthDelimited).string(message.announcedTile);
+        /* string tile_image = 3; */
+        if (message.tileImage !== "")
+            writer.tag(3, WireType.LengthDelimited).string(message.tileImage);
+        /* int32 turn_number = 4; */
+        if (message.turnNumber !== 0)
+            writer.tag(4, WireType.Varint).int32(message.turnNumber);
+        /* repeated string waiting_for_players = 5; */
+        for (let i = 0; i < message.waitingForPlayers.length; i++)
+            writer.tag(5, WireType.LengthDelimited).string(message.waitingForPlayers[i]);
+        /* string game_state = 6; */
+        if (message.gameState !== "")
+            writer.tag(6, WireType.LengthDelimited).string(message.gameState);
+        /* takeiteasygame.v1.Error error = 7; */
+        if (message.error)
+            Error.internalBinaryWrite(message.error, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.StartTurnResponse
+ */
+export const StartTurnResponse = new StartTurnResponse$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class GetGameStateRequest$Type extends MessageType<GetGameStateRequest> {
+    constructor() {
+        super("takeiteasygame.v1.GetGameStateRequest", [
+            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
+        ]);
+    }
+    create(value?: PartialMessage<GetGameStateRequest>): GetGameStateRequest {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.sessionId = "";
+        if (value !== undefined)
+            reflectionMergePartial<GetGameStateRequest>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetGameStateRequest): GetGameStateRequest {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* string session_id */ 1:
+                    message.sessionId = reader.string();
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: GetGameStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* string session_id = 1; */
+        if (message.sessionId !== "")
+            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.GetGameStateRequest
+ */
+export const GetGameStateRequest = new GetGameStateRequest$Type();
+// @generated message type with reflection information, may provide speed optimized methods
+class GetGameStateResponse$Type extends MessageType<GetGameStateResponse> {
+    constructor() {
+        super("takeiteasygame.v1.GetGameStateResponse", [
+            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
+            { no: 2, name: "game_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 3, name: "current_tile", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 4, name: "current_tile_image", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 5, name: "current_turn", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
+            { no: 6, name: "waiting_for_players", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
+            { no: 7, name: "is_game_finished", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
+            { no: 8, name: "final_scores", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
+            { no: 9, name: "error", kind: "message", T: () => Error }
+        ]);
+    }
+    create(value?: PartialMessage<GetGameStateResponse>): GetGameStateResponse {
+        const message = globalThis.Object.create((this.messagePrototype!));
+        message.success = false;
+        message.gameState = "";
+        message.currentTile = "";
+        message.currentTileImage = "";
+        message.currentTurn = 0;
+        message.waitingForPlayers = [];
+        message.isGameFinished = false;
+        message.finalScores = "";
+        if (value !== undefined)
+            reflectionMergePartial<GetGameStateResponse>(this, message, value);
+        return message;
+    }
+    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetGameStateResponse): GetGameStateResponse {
+        let message = target ?? this.create(), end = reader.pos + length;
+        while (reader.pos < end) {
+            let [fieldNo, wireType] = reader.tag();
+            switch (fieldNo) {
+                case /* bool success */ 1:
+                    message.success = reader.bool();
+                    break;
+                case /* string game_state */ 2:
+                    message.gameState = reader.string();
+                    break;
+                case /* string current_tile */ 3:
+                    message.currentTile = reader.string();
+                    break;
+                case /* string current_tile_image */ 4:
+                    message.currentTileImage = reader.string();
+                    break;
+                case /* int32 current_turn */ 5:
+                    message.currentTurn = reader.int32();
+                    break;
+                case /* repeated string waiting_for_players */ 6:
+                    message.waitingForPlayers.push(reader.string());
+                    break;
+                case /* bool is_game_finished */ 7:
+                    message.isGameFinished = reader.bool();
+                    break;
+                case /* string final_scores */ 8:
+                    message.finalScores = reader.string();
+                    break;
+                case /* takeiteasygame.v1.Error error */ 9:
+                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
+                    break;
+                default:
+                    let u = options.readUnknownField;
+                    if (u === "throw")
+                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
+                    let d = reader.skip(wireType);
+                    if (u !== false)
+                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
+            }
+        }
+        return message;
+    }
+    internalBinaryWrite(message: GetGameStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
+        /* bool success = 1; */
+        if (message.success !== false)
+            writer.tag(1, WireType.Varint).bool(message.success);
+        /* string game_state = 2; */
+        if (message.gameState !== "")
+            writer.tag(2, WireType.LengthDelimited).string(message.gameState);
+        /* string current_tile = 3; */
+        if (message.currentTile !== "")
+            writer.tag(3, WireType.LengthDelimited).string(message.currentTile);
+        /* string current_tile_image = 4; */
+        if (message.currentTileImage !== "")
+            writer.tag(4, WireType.LengthDelimited).string(message.currentTileImage);
+        /* int32 current_turn = 5; */
+        if (message.currentTurn !== 0)
+            writer.tag(5, WireType.Varint).int32(message.currentTurn);
+        /* repeated string waiting_for_players = 6; */
+        for (let i = 0; i < message.waitingForPlayers.length; i++)
+            writer.tag(6, WireType.LengthDelimited).string(message.waitingForPlayers[i]);
+        /* bool is_game_finished = 7; */
+        if (message.isGameFinished !== false)
+            writer.tag(7, WireType.Varint).bool(message.isGameFinished);
+        /* string final_scores = 8; */
+        if (message.finalScores !== "")
+            writer.tag(8, WireType.LengthDelimited).string(message.finalScores);
+        /* takeiteasygame.v1.Error error = 9; */
+        if (message.error)
+            Error.internalBinaryWrite(message.error, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
+        let u = options.writeUnknownFields;
+        if (u !== false)
+            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
+        return writer;
+    }
+}
+/**
+ * @generated MessageType for protobuf message takeiteasygame.v1.GetGameStateResponse
+ */
+export const GetGameStateResponse = new GetGameStateResponse$Type();
 /**
  * @generated ServiceType for protobuf service takeiteasygame.v1.GameService
  */
 export const GameService = new ServiceType("takeiteasygame.v1.GameService", [
     { name: "MakeMove", options: {}, I: MakeMoveRequest, O: MakeMoveResponse },
-    { name: "GetAvailableMoves", options: {}, I: GetAvailableMovesRequest, O: GetAvailableMovesResponse }
+    { name: "GetAvailableMoves", options: {}, I: GetAvailableMovesRequest, O: GetAvailableMovesResponse },
+    { name: "StartTurn", options: {}, I: StartTurnRequest, O: StartTurnResponse },
+    { name: "GetGameState", options: {}, I: GetGameStateRequest, O: GetGameStateResponse }
 ]);
diff --git a/frontend/src/generated/session_service.client.ts b/frontend/src/generated/session_service.client.ts
index 5bfdab0..d250409 100644
--- a/frontend/src/generated/session_service.client.ts
+++ b/frontend/src/generated/session_service.client.ts
@@ -1,4 +1,4 @@
-// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated by protobuf-ts 2.11.0
 // @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
 // tslint:disable
 import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
diff --git a/frontend/src/generated/session_service.ts b/frontend/src/generated/session_service.ts
index 1a2eaff..64fc32d 100644
--- a/frontend/src/generated/session_service.ts
+++ b/frontend/src/generated/session_service.ts
@@ -1,4 +1,4 @@
-// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies
+// @generated by protobuf-ts 2.11.0
 // @generated from protobuf file "session_service.proto" (package "takeiteasygame.v1", syntax proto3)
 // tslint:disable
 import { ServiceType } from "@protobuf-ts/runtime-rpc";
diff --git a/frontend/src/hooks/useGameActions.ts b/frontend/src/hooks/useGameActions.ts
index 6347cb5..e5cb5e2 100644
--- a/frontend/src/hooks/useGameActions.ts
+++ b/frontend/src/hooks/useGameActions.ts
@@ -1,6 +1,7 @@
 // hooks/useGameActions.ts - Actions gameplay isolées
 import { gameClient } from '../services/GameClient';
 import type { GameState, Session } from './useGameState';
+import {batch} from "solid-js";
 
 /**
  * Hook pour les actions de gameplay (gRPC calls)
@@ -19,165 +20,137 @@ export const useGameActions = (
     setMctsLastMove: (move: string) => void,
     updatePlateauTiles: (gameState: any) => void,
     addDebugLog: (message: string) => void,
-    generateTileImagePath: (tileString: string) => string
 ) => {
 
     /**
      * Démarrer un nouveau tour (tire une tuile aléatoire)
      */
+        // ✅ SOLUTION 2: startGameTurn optimisé
     const startGameTurn = async () => {
-        const currentSession = session();
-        
-        if (!currentSession) {
-            setError('Aucune session active');
-            addDebugLog('❌ Pas de session active pour startGameTurn');
-            return;
-        }
+            const currentSession = session();
+            if (!currentSession) return;
 
-        // Validation renforcée
-        const sessionId = currentSession.sessionId;
-        addDebugLog(`🔍 VALIDATION sessionId: "${sessionId}" (type: ${typeof sessionId})`);
-        
-        if (!sessionId || typeof sessionId !== 'string' || sessionId.trim() === '') {
-            const error = `Session ID invalide: "${sessionId}"`;
-            setError(error);
-            addDebugLog(`❌ ${error}`);
-            return;
-        }
-
-        setLoading(true);
-        setError('');
-        addDebugLog(`🎲 Démarrage tour pour session ${sessionId}`);
+            // ✅ BATCH: État de chargement
+            batch(() => {
+                setLoading(true);
+                setError('');
+            });
 
-        try {
-            const result = await gameClient.startNewTurn(sessionId);
-
-            if (result.success) {
-                setCurrentTile(result.announcedTile || null);
-                setCurrentTileImage(result.tileImage || null);
-                setCurrentTurnNumber(result.turnNumber || 0);
-                setStatusMessage(`🎲 Tour ${result.turnNumber}: Tuile ${result.announcedTile} annoncée!`);
-                setIsGameStarted(true);
-
-                // Vérifier si c'est mon tour
-                setMyTurn(result.waitingForPlayers?.includes(currentSession.playerId) || false);
-
-                // Parser l'état du jeu pour obtenir les plateaux
-                if (result.gameState) {
-                    const parsedState = JSON.parse(result.gameState);
-                    updatePlateauTiles(parsedState);
+            try {
+                const result = await gameClient.startNewTurn(currentSession.sessionId);
+
+                if (result.success) {
+                    // ✅ BATCH: Mise à jour complète du tour
+                    batch(() => {
+                        setCurrentTile(result.announcedTile || null);
+                        setCurrentTileImage(result.tileImage || null);
+                        setCurrentTurnNumber(result.turnNumber || 0);
+                        setStatusMessage(`🎲 Tour ${result.turnNumber}: ${result.announcedTile}`);
+                        setIsGameStarted(true);
+                        setMyTurn(result.waitingForPlayers?.includes(currentSession.playerId) || false);
+                        setLoading(false);
+                    });
+
+                    // ✅ PLATEAU EN DIFFÉRÉ (non-bloquant)
+                    if (result.gameState) {
+                        queueMicrotask(() => {
+                            const parsedState = JSON.parse(result.gameState);
+                            updatePlateauTiles(parsedState);
+                        });
+                    }
+                } else {
+                    batch(() => {
+                        setError(result.error || 'Erreur tour');
+                        setLoading(false);
+                    });
                 }
-
-                addDebugLog(`✅ Tour ${result.turnNumber} démarré - Tuile: ${result.announcedTile}`);
-            } else {
-                setError(result.error || 'Erreur lors du démarrage du tour');
-                addDebugLog(`❌ Échec démarrage tour: ${result.error}`);
+            } catch (error) {
+                batch(() => {
+                    setError('Erreur connexion');
+                    setLoading(false);
+                });
             }
-        } catch (error) {
-            setError('Erreur de connexion gRPC');
-            addDebugLog(`💥 Exception démarrage tour: ${error}`);
-        } finally {
-            setLoading(false);
-        }
-    };
+        };
 
     /**
-     * Jouer un mouvement (position sur le plateau)
+     * Jouer un mouvement (position sur le plateau) - VERSION OPTIMISTE
      */
-    const playMove = async (position: number, myTurn: () => boolean) => {
+    const playMove = async (position: number, myTurn: () => boolean, markActionPerformed?: () => void) => {
         const currentSession = session();
         if (!currentSession || !myTurn()) {
             setStatusMessage("Ce n'est pas votre tour !");
             return;
         }
-
-        // Validation renforcée
-        const sessionId = currentSession.sessionId;
-        const playerId = currentSession.playerId;
-        addDebugLog(`🔍 VALIDATION playMove: sessionId="${sessionId}", playerId="${playerId}"`);
-        
-        if (!sessionId || typeof sessionId !== 'string' || sessionId.trim() === '') {
-            const error = `Session ID invalide: "${sessionId}"`;
-            setError(error);
-            addDebugLog(`❌ ${error}`);
-            return;
-        }
-        
-        if (!playerId || typeof playerId !== 'string' || playerId.trim() === '') {
-            const error = `Player ID invalide: "${playerId}"`;
-            setError(error);
-            addDebugLog(`❌ ${error}`);
-            return;
-        }
-
-        setLoading(true);
-        setError('');
-        addDebugLog(`🎯 Mouvement position ${position} par ${playerId}`);
-
+        batch(() => {
+            setStatusMessage(`🎯 Position ${position}...`);
+            setMyTurn(false); // Bloquer immédiatement les clics
+            setLoading(true);
+            setError('');
+        });
+        // Marquer pour éviter les conflits polling
+        markActionPerformed?.();
+
+        // ✅ LOGIQUE ASYNC NON-BLOQUANTE
         try {
             const result = await gameClient.makeMove(
-                sessionId,
-                playerId,
+                currentSession.sessionId,
+                currentSession.playerId,
                 position
             );
 
-            if (result.success) {
-                setStatusMessage(`✅ Mouvement joué position ${position}! Points gagnés: ${result.pointsEarned}`);
-                setMyTurn(false);
-
-                // Mettre à jour l'état du jeu
-                if (result.newGameState) {
-                    const parsedState = JSON.parse(result.newGameState);
-                    updatePlateauTiles(parsedState);
-                }
-
-                // Afficher la réponse MCTS si disponible
-                if (result.mctsResponse && result.mctsResponse !== "{}") {
-                    try {
-                        const mctsData = JSON.parse(result.mctsResponse);
-                        const mctsMessage = `🤖 MCTS a joué position ${mctsData.position} (score: ${mctsData.evaluation_score?.toFixed(1) || 'N/A'})`;
-                        setMctsLastMove(mctsMessage);
-                        addDebugLog(mctsMessage);
+            // ✅ BATCH 2: Mise à jour résultat (1 seul re-render)
+            batch(() => {
+                if (result.success) {
+                    setStatusMessage(`✅ Position ${position}! +${result.pointsEarned} pts`);
+                    setLoading(false);
+
+                    // État plateau mis à jour en arrière-plan (pas de re-render immédiat)
+                    if (result.newGameState) {
+                        queueMicrotask(() => {
+                            const parsedState = JSON.parse(result.newGameState);
+                            updatePlateauTiles(parsedState);
+                        });
+                    }
 
+                    // MCTS en différé pour ne pas bloquer l'UI
+                    if (result.mctsResponse && result.mctsResponse !== "{}") {
                         setTimeout(() => {
-                            setStatusMessage(mctsMessage);
-                        }, 1000);
-                    } catch (e) {
-                        setMctsLastMove('🤖 MCTS a joué');
-                        addDebugLog('🤖 MCTS a joué (réponse non-JSON)');
+                            try {
+                                const mctsData = JSON.parse(result.mctsResponse);
+                                const mctsMessage = `🤖 MCTS: position ${mctsData.position}`;
+                                batch(() => {
+                                    setMctsLastMove(mctsMessage);
+                                    setStatusMessage(mctsMessage);
+                                });
+                            } catch (e) {
+                                setMctsLastMove('🤖 MCTS a joué');
+                            }
+                        }, 500); // Délai pour voir la confirmation du joueur
                     }
-                }
 
-                // Si le jeu est terminé
-                if (result.isGameOver) {
-                    const gameStateResult = await gameClient.getGameplayState(currentSession.sessionId);
-                    if (gameStateResult.success && gameStateResult.finalScores && gameStateResult.finalScores !== "{}") {
-                        try {
-                            const scores = JSON.parse(gameStateResult.finalScores);
-                            setStatusMessage(`🏁 Jeu terminé ! Scores finaux: ${JSON.stringify(scores, null, 2)}`);
-                            addDebugLog('🏁 Jeu terminé');
-                        } catch (e) {
-                            setStatusMessage(`🏁 Jeu terminé !`);
-                        }
+                    // Tour suivant en différé
+                    if (!result.isGameOver) {
+                        setTimeout(() => {
+                            startGameTurn();
+                        }, 2000);
                     }
-                    setIsGameStarted(false);
                 } else {
-                    // Si le jeu continue, démarrer le tour suivant automatiquement
-                    setTimeout(() => {
-                        startGameTurn();
-                    }, 3000); // 3 secondes pour voir la réponse MCTS
+                    // ROLLBACK en cas d'échec
+                    setMyTurn(true);
+                    setLoading(false);
+                    setError(result.error || 'Mouvement refusé');
+                    setStatusMessage(`❌ ${result.error}`);
                 }
+            });
 
-                addDebugLog(`✅ Mouvement réussi - Points: ${result.pointsEarned}`);
-            } else {
-                setError(result.error || 'Erreur lors du mouvement');
-                addDebugLog(`❌ Échec mouvement: ${result.error}`);
-            }
         } catch (error) {
-            setError('Erreur de connexion gRPC');
-            addDebugLog(`💥 Exception mouvement: ${error}`);
-        } finally {
-            setLoading(false);
+            // ✅ BATCH 3: Gestion d'erreur (1 seul re-render)
+            batch(() => {
+                setMyTurn(true);
+                setLoading(false);
+                setError('Erreur réseau');
+                setStatusMessage('💥 Réessayez');
+            });
         }
     };
 
@@ -212,7 +185,7 @@ export const useGameActions = (
             }
 
             addDebugLog(`✅ Session créée avec succès: sessionId=${result.sessionId}, playerId=${result.playerId}`);
-            
+
             setSession({
                 playerId: result.playerId,
                 sessionCode: result.sessionCode,
@@ -279,7 +252,7 @@ export const useGameActions = (
             }
 
             addDebugLog(`✅ Session jointe avec succès: sessionId=${result.sessionId}, playerId=${result.playerId}`);
-            
+
             setSession({
                 playerId: result.playerId,
                 sessionCode: result.sessionCode,
diff --git a/frontend/src/hooks/usePolling.ts b/frontend/src/hooks/usePolling.ts
index d6aa8a0..c91f167 100644
--- a/frontend/src/hooks/usePolling.ts
+++ b/frontend/src/hooks/usePolling.ts
@@ -1,10 +1,10 @@
-// hooks/usePolling.ts - Logique de polling/synchronisation isolée
+// hooks/usePolling.ts - VERSION CORRIGÉE - Sans generateTileImagePath
 import { gameClient } from '../services/GameClient';
-import { onCleanup } from 'solid-js';
+import { onCleanup, batch } from 'solid-js';
 
 /**
  * Hook pour la gestion du polling de l'état du jeu
- * Centralise toute la logique de synchronisation avec le backend
+ * VERSION SIMPLIFIÉE qui fonctionne de manière fiable
  */
 export const usePolling = (
     session: () => { sessionId: string; playerId: string } | null,
@@ -17,142 +17,294 @@ export const usePolling = (
     setIsGameStarted: (started: boolean) => void,
     setStatusMessage: (message: string) => void,
     updatePlateauTiles: (gameState: any) => void,
-    generateTileImagePath: (tileString: string) => string,
     convertSessionState: (sessionState: any) => any,
     addDebugLog: (message: string) => void
 ) => {
+    // ============================================================================
+    // VARIABLES D'ÉTAT SIMPLIFIÉES
+    // ============================================================================
     let pollInterval: number | undefined;
+    let consecutiveErrors = 0;
+    let lastActionTime = 0;
+    let currentMyTurn = false;
+
+    // ============================================================================
+    // FONCTION UTILITAIRE LOCALE (temporaire)
+    // ============================================================================
+
+    // ✅ Fonction locale uniquement pour la tuile courante (en attendant backend complet)
+
+
+    // ============================================================================
+    // FONCTIONS UTILITAIRES SIMPLIFIÉES
+    // ============================================================================
+
+    const markActionPerformed = () => {
+        lastActionTime = Date.now();
+        addDebugLog(`⚡ Action marquée: ${lastActionTime}`);
+    };
+
+    // ✅ INTERVALLES MODÉRÉS (pas trop agressifs)
+    const getPollingInterval = (): number => {
+        if (!isGameStarted()) return 4000;           // 4s en attente
+
+        const timeSinceAction = Date.now() - lastActionTime;
+        if (timeSinceAction < 5000) return 800;      // 800ms après action
+        if (currentMyTurn) return 1500;              // 1.5s mon tour
+        return 3000;                                 // 3s normal
+    };
+
+    // ✅ BACKOFF MODÉRÉ
+    const getErrorAdjustedInterval = (baseInterval: number): number => {
+        if (consecutiveErrors === 0) return baseInterval;
+        return baseInterval * Math.min(Math.pow(1.5, consecutiveErrors), 8);
+    };
+
+    // ============================================================================
+    // POLLING GAMEPLAY - VERSION SIMPLIFIÉE ET FIABLE
+    // ============================================================================
 
-    /**
-     * Polling de l'état de gameplay avec gestion de désynchronisation
-     */
     const pollGameplayState = async (sessionId: string) => {
         if (!sessionId || typeof sessionId !== 'string' || sessionId.trim() === '') {
             return;
         }
 
         try {
-            const result = await gameClient.getGameplayState(sessionId);
+            const result = await gameClient.getGameState(sessionId);
 
             if (result.success) {
-                // Gestion de la tuile courante avec désynchronisation
-                if (result.currentTile && result.currentTile !== currentTile()) {
-                    const newImagePath = generateTileImagePath(result.currentTile);
-
-                    setCurrentTile(result.currentTile);
-                    setCurrentTileImage(newImagePath);
-                    addDebugLog(`📡 Nouvelle tuile synchronisée: ${result.currentTile}`);
-                } else if (!result.currentTile && currentTile()) {
-                    // Désynchronisation: backend sans tuile, frontend avec tuile
-                    addDebugLog(`⚠️ DÉSYNC: Backend sans tuile, frontend a ${currentTile()}`);
-                    addDebugLog(`⚠️ Tentative de garder la tuile locale temporairement`);
-                } else if (!result.currentTile && !currentTile()) {
-                    // Aucune tuile des deux côtés - normal en début de jeu
-                    addDebugLog(`📡 Pas de tuile courante (début de jeu)`);
+                consecutiveErrors = 0;
+
+                // ✅ GESTION TUILE SIMPLIFIÉE - Utilise fonction locale
+                const newTile = result.currentTile;
+                const newTileImage = result.currentTileImage; // ✅ BACKEND DIRECT!
+                const currentTileValue = currentTile();
+
+                if (newTile && newTile !== currentTileValue) {
+                    // Nouvelle tuile détectée
+                    setCurrentTile(newTile);
+                    setCurrentTileImage(newTileImage || null); // ✅ BACKEND IMAGE!
+                    markActionPerformed();
+                    addDebugLog(`📡 Nouvelle tuile: ${newTile} → ${newTileImage}`);
+
+                } else if (!newTile && currentTileValue) {
+                    // Pas de tuile courante
+                    const timeSinceAction = Date.now() - lastActionTime;
+                    if (timeSinceAction > 8000) {
+                        setCurrentTile(null);
+                        setCurrentTileImage(null);
+                        addDebugLog(`⚠️ Clear tuile après 8s`);
+                    }
                 }
 
-                // Mise à jour de l'état de jeu
-                if (result.gameState) {
-                    const parsedState = JSON.parse(result.gameState);
-                    updatePlateauTiles(parsedState);
+                // ✅ GESTION DU TOUR SIMPLIFIÉE
+                const currentSession = session();
+                if (currentSession) {
+                    const newMyTurn = result.waitingForPlayers?.includes(currentSession.playerId) || false;
 
-                    const currentSession = session();
-                    if (currentSession) {
-                        const newMyTurn = result.waitingForPlayers?.includes(currentSession.playerId) || false;
+                    if (newMyTurn !== currentMyTurn) {
+                        currentMyTurn = newMyTurn;
                         setMyTurn(newMyTurn);
-                        addDebugLog(`🔄 Tour changé: ${newMyTurn ? 'Mon tour' : 'En attente'}`);
+                        addDebugLog(`🔄 Tour: ${newMyTurn ? 'MON TOUR' : 'Attente'}`);
+
+                        if (newMyTurn) {
+                            markActionPerformed();
+                        }
+                    }
+                }
+
+                // ✅ PLATEAU - MISE À JOUR DIRECTE (utilise backend via updatePlateauTiles)
+                if (result.gameState) {
+                    const timeSinceAction = Date.now() - lastActionTime;
+
+                    // ✅ CONDITION SIMPLIFIÉE - toujours mettre à jour après 2s
+                    if (timeSinceAction > 2000) {
+                        try {
+                            const parsedState = JSON.parse(result.gameState);
+                            updatePlateauTiles(parsedState); // ✅ Cette fonction utilise les données backend
+                            addDebugLog(`🔄 Plateau mis à jour (${timeSinceAction}ms depuis action)`);
+                        } catch (e) {
+                            addDebugLog(`❌ Erreur parse plateau: ${e}`);
+                        }
+                    } else {
+                        addDebugLog(`⏳ Protection optimiste: ${timeSinceAction}ms`);
                     }
                 }
 
-                // Vérification de cohérence
+                // ✅ FIN DE PARTIE
                 if (result.isGameFinished && result.finalScores && result.finalScores !== "{}") {
                     try {
                         const scores = JSON.parse(result.finalScores);
-                        setStatusMessage(`🏁 Jeu terminé ! Scores finaux: ${JSON.stringify(scores, null, 2)}`);
+                        setStatusMessage(`🏁 Terminé ! Scores: ${JSON.stringify(scores, null, 2)}`);
                         setIsGameStarted(false);
-                        addDebugLog('🏁 Jeu terminé via polling');
+                        addDebugLog('🏁 Jeu terminé');
                     } catch (e) {
                         setStatusMessage(`🏁 Jeu terminé !`);
                         setIsGameStarted(false);
                     }
                 }
 
-                // Debug: État complet pour diagnostic
-                addDebugLog(`📊 Polling state: tile=${result.currentTile || 'none'}, waiting=${result.waitingForPlayers?.length || 0}, finished=${result.isGameFinished}`);
+                // ✅ DEBUG SIMPLE
+                addDebugLog(`📊 Poll OK - Tuile: ${newTile || 'none'}, Tour: ${currentMyTurn}, Attente: ${result.waitingForPlayers?.length || 0}`);
+
             } else {
-                // Gestion des erreurs de polling
-                addDebugLog(`❌ Polling error: ${result.error || 'Unknown error'}`);
+                consecutiveErrors++;
+                addDebugLog(`❌ Poll error #${consecutiveErrors}: ${result.error || 'Unknown'}`);
             }
         } catch (error) {
-            // Erreur silencieuse mais avec log en debug
-            addDebugLog(`💥 Polling exception: ${error}`);
+            consecutiveErrors++;
+            addDebugLog(`💥 Poll exception #${consecutiveErrors}: ${error}`);
         }
     };
 
-    /**
-     * Démarrer le polling avec validation du sessionId
-     */
+    // ============================================================================
+    // POLLING SESSION - VERSION SIMPLIFIÉE
+    // ============================================================================
+
+    const pollSessionState = async (sessionId: string) => {
+        try {
+            const sessionResult = await gameClient.getSessionState(sessionId);
+
+            if (sessionResult.success && sessionResult.sessionState) {
+                // ✅ MISE À JOUR DIRECTE
+                const convertedState = convertSessionState(sessionResult.sessionState);
+                setGameState(convertedState);
+                // Pas de log pour éviter le spam
+            }
+        } catch (error) {
+            addDebugLog(`❌ Session poll error: ${error}`);
+        }
+    };
+
+    // ============================================================================
+    // DÉMARRAGE POLLING - VERSION SIMPLIFIÉE
+    // ============================================================================
+
     const startPolling = (sessionId: string) => {
-        // Validation du sessionId avant de démarrer le polling
         if (!sessionId || typeof sessionId !== 'string' || sessionId.trim() === '') {
-            addDebugLog(`❌ startPolling: sessionId invalide "${sessionId}"`);
+            addDebugLog(`❌ sessionId invalide: "${sessionId}"`);
             return;
         }
-        
+
         stopPolling();
-        addDebugLog(`🔄 Démarrage polling pour session: ${sessionId}`);
+        addDebugLog(`🔄 Démarrage polling pour: ${sessionId.slice(0, 8)}...`);
 
         const poll = async () => {
             try {
-                // Polling de l'état de session
-                const sessionResult = await gameClient.getSessionState(sessionId);
-                if (sessionResult.success && sessionResult.sessionState) {
-                    setGameState(convertSessionState(sessionResult.sessionState));
-                }
+                // ✅ SESSION EN PREMIER (léger)
+                await pollSessionState(sessionId);
 
-                // Polling de l'état de gameplay si le jeu a commencé
+                // ✅ GAMEPLAY selon l'état
                 if (isGameStarted()) {
                     await pollGameplayState(sessionId);
                 } else {
-                    // Vérifier si une tuile a été tirée par un autre joueur
-                    const gameplayResult = await gameClient.getGameplayState(sessionId);
-                    if (gameplayResult.success && gameplayResult.currentTile && !currentTile()) {
-                        // Un autre joueur a tiré une tuile !
-                        setCurrentTile(gameplayResult.currentTile);
-                        setCurrentTileImage(generateTileImagePath(gameplayResult.currentTile));
-                        setIsGameStarted(true);
-                        addDebugLog(`📡 Tuile reçue via polling: ${gameplayResult.currentTile}`);
+                    // ✅ DÉTECTION NOUVELLE TUILE
+                    try {
+                        const gameplayResult = await gameClient.getGameplayState(sessionId);
+                        if (gameplayResult.success && gameplayResult.currentTile && !currentTile()) {
+                            // ✅ MISE À JOUR DIRECTE - Utilise fonction locale
+                            setCurrentTile(gameplayResult.currentTile);
+                            setCurrentTileImage(gameplayResult.currentTileImage || null);
+                            setIsGameStarted(true);
+                            markActionPerformed();
+                            addDebugLog(`📡 Tuile détectée: ${gameplayResult.currentTile}`);
+                        }
+                    } catch (e) {
+                        // Silencieux pour éviter spam
                     }
                 }
+
             } catch (error) {
-                // Erreur silencieuse pour le polling
-                addDebugLog(`💥 Polling general exception: ${error}`);
+                consecutiveErrors++;
+                addDebugLog(`💥 Poll général #${consecutiveErrors}: ${error}`);
+            }
+
+            // ✅ PROGRAMMATION SIMPLE du prochain poll
+            const baseInterval = getPollingInterval();
+            const finalInterval = getErrorAdjustedInterval(baseInterval);
+
+            pollInterval = window.setTimeout(poll, finalInterval);
+
+            // Debug seulement si erreurs
+            if (consecutiveErrors > 0) {
+                addDebugLog(`⏰ Prochain poll: ${finalInterval}ms (erreurs: ${consecutiveErrors})`);
             }
         };
 
+        // Démarrage immédiat
         poll();
-        pollInterval = window.setInterval(poll, 2000);
     };
 
-    /**
-     * Arrêter le polling
-     */
+    // ============================================================================
+    // ARRÊT ET UTILITAIRES
+    // ============================================================================
+
     const stopPolling = () => {
         if (pollInterval) {
-            clearInterval(pollInterval);
+            clearTimeout(pollInterval);
             pollInterval = undefined;
             addDebugLog('🛑 Polling arrêté');
         }
     };
 
-    // Nettoyage automatique au démontage du composant
+    const resetPollingState = () => {
+        consecutiveErrors = 0;
+        lastActionTime = 0;
+        currentMyTurn = false;
+        addDebugLog('🔄 État polling reset');
+    };
+
+    const forceRefresh = async () => {
+        const currentSession = session();
+        if (currentSession) {
+            markActionPerformed();
+            await pollGameplayState(currentSession.sessionId);
+            addDebugLog('🔄 Refresh forcé');
+        }
+    };
+
+    // ============================================================================
+    // NETTOYAGE
+    // ============================================================================
+
     onCleanup(() => {
         stopPolling();
+        addDebugLog('🧹 usePolling cleanup');
     });
 
+    // ============================================================================
+    // API PUBLIQUE SIMPLIFIÉE
+    // ============================================================================
+
     return {
         startPolling,
         stopPolling,
-        pollGameplayState
+        markActionPerformed,
+        pollGameplayState,
+        resetPollingState,
+        forceRefresh,
+        isPolling: () => pollInterval !== undefined,
+        getStats: () => ({
+            consecutiveErrors,
+            lastActionTime,
+            currentMyTurn
+        })
     };
-};
\ No newline at end of file
+};
+
+// ============================================================================
+// NOTE: FONCTION LOCALE TEMPORAIRE
+// ============================================================================
+
+/*
+🔧 FONCTION getTileImagePath() LOCALE
+
+Cette fonction est temporaire et seulement utilisée pour la "tuile courante"
+(la tuile annoncée qu'on voit en haut de l'écran).
+
+Les plateaux utilisent maintenant 100% les données du backend via
+GameStateManager.updatePlateauTiles() qui utilise plateau.tile_images.
+
+À terme, le backend devrait aussi retourner l'image de la tuile courante
+directement dans currentTileImage au lieu de currentTile.
+*/
\ No newline at end of file
diff --git a/frontend/src/index.tsx b/frontend/src/index.tsx
index 8384ea8..0497dfb 100644
--- a/frontend/src/index.tsx
+++ b/frontend/src/index.tsx
@@ -1,13 +1,13 @@
+// src/index.tsx
 import { render } from 'solid-js/web';
-
-import { TodoList } from './todo-list';
+import MultiplayerApp from "./components/MultiplayerApp";
 
 const root = document.getElementById('root');
 
 if (import.meta.env.DEV && !(root instanceof HTMLElement)) {
   throw new Error(
-    'Root element not found. Did you forget to add it to your index.html? Or maybe the id attribute got misspelled?',
+      'Root element not found. Did you forget to add it to your index.html? Or maybe the id attribute got misspelled?',
   );
 }
 
-render(() => <TodoList />, root!);
+render(() => <MultiplayerApp />, root!);
\ No newline at end of file
diff --git a/frontend/src/services/GameClient.ts b/frontend/src/services/GameClient.ts
index e69de29..ae6836a 100644
--- a/frontend/src/services/GameClient.ts
+++ b/frontend/src/services/GameClient.ts
@@ -0,0 +1,567 @@
+// src/services/GameClient.ts - Version complète avec corrections
+
+import { GrpcWebFetchTransport } from '@protobuf-ts/grpcweb-transport';
+import { SessionServiceClient } from '../generated/session_service.client';
+import { GameServiceClient } from '../generated/game_service.client';
+import {
+    CreateSessionRequest,
+    JoinSessionRequest,
+    SetReadyRequest,
+    GetSessionStateRequest
+} from '../generated/session_service';
+import {
+    MakeMoveRequest,
+    GetAvailableMovesRequest,
+    StartTurnRequest,
+    GetGameStateRequest
+} from '../generated/game_service';
+import type { GameState } from '../generated/common';
+
+export class GameClient {
+    private sessionClient: SessionServiceClient;
+    private gameClient: GameServiceClient;
+    private transport: GrpcWebFetchTransport;
+    private debugEnabled = true; // 🔧 AJOUT: Debug activé
+
+    constructor() {
+        this.transport = new GrpcWebFetchTransport({
+            baseUrl: 'http://localhost:50051',
+            fetchInit: {
+                mode: 'cors',
+                credentials: 'omit'
+            },
+            format: "binary",
+            compress: false,
+            timeout: 10000,
+            meta: {
+                'content-type': 'application/grpc-web+proto',
+                'accept': 'application/grpc-web+proto'
+            }
+        });
+
+        this.sessionClient = new SessionServiceClient(this.transport);
+        this.gameClient = new GameServiceClient(this.transport);
+
+        this.debugLog('🔌 GameClient initialisé (version complète)');
+    }
+
+    // 🔧 AJOUT: Helper de debug
+    private debugLog(message: string, data?: any) {
+        if (this.debugEnabled) {
+            console.log(`🔍 GameClient: ${message}`, data || '');
+        }
+    }
+
+    // ============================================================================
+    // MÉTHODES GESTION DE SESSION (avec debug amélioré)
+    // ============================================================================
+
+    async createSession(playerName: string) {
+        this.debugLog('📝 createSession DÉBUT', { playerName });
+
+        try {
+            const request: CreateSessionRequest = {
+                playerName: playerName,
+                maxPlayers: 4,
+                gameMode: "multiplayer"
+            };
+
+            this.debugLog('📤 Envoi createSession request', request);
+            const { response } = await this.sessionClient.createSession(request);
+            this.debugLog('📥 createSession response reçue', response);
+
+            if (response.result.oneofKind === "success") {
+                const success = response.result.success;
+                this.debugLog('✅ createSession SUCCESS', {
+                    sessionCode: success.sessionCode,
+                    sessionId: success.sessionId,
+                    playerId: success.playerId
+                });
+
+                return {
+                    success: true,
+                    sessionCode: success.sessionCode,
+                    sessionId: success.sessionId,
+                    playerId: success.playerId,
+                    sessionState: success.player ? {
+                        sessionId: success.sessionId,
+                        players: [success.player],
+                        currentPlayerId: success.playerId,
+                        state: 0,
+                        boardState: "{}",
+                        turnNumber: 0
+                    } as GameState : undefined
+                };
+            } else if (response.result.oneofKind === "error") {
+                this.debugLog('❌ createSession ERROR', response.result.error);
+                return {
+                    success: false,
+                    error: response.result.error.message
+                };
+            }
+
+            this.debugLog('❌ createSession INVALID RESPONSE');
+            return {
+                success: false,
+                error: "Réponse invalide du serveur"
+            };
+        } catch (error) {
+            this.debugLog('💥 createSession EXCEPTION', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    async joinSession(sessionCode: string, playerName: string) {
+        this.debugLog('🚪 joinSession DÉBUT', { sessionCode, playerName });
+
+        try {
+            const request: JoinSessionRequest = {
+                sessionCode: sessionCode.toUpperCase(),
+                playerName: playerName
+            };
+
+            this.debugLog('📤 Envoi joinSession request', request);
+            const { response } = await this.sessionClient.joinSession(request);
+            this.debugLog('📥 joinSession response reçue', response);
+
+            if (response.result.oneofKind === "success") {
+                const success = response.result.success;
+                this.debugLog('✅ joinSession SUCCESS', {
+                    sessionId: success.sessionId,
+                    playerId: success.playerId
+                });
+
+                return {
+                    success: true,
+                    sessionCode: sessionCode,
+                    sessionId: success.sessionId,
+                    playerId: success.playerId,
+                    sessionState: success.gameState
+                };
+            } else if (response.result.oneofKind === "error") {
+                this.debugLog('❌ joinSession ERROR', response.result.error);
+                return {
+                    success: false,
+                    error: response.result.error.message
+                };
+            }
+
+            this.debugLog('❌ joinSession INVALID RESPONSE');
+            return {
+                success: false,
+                error: "Réponse invalide du serveur"
+            };
+        } catch (error) {
+            this.debugLog('💥 joinSession EXCEPTION', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    // 🔧 CORRIGÉ: setPlayerReady avec validation renforcée
+    async setPlayerReady(sessionId: string, playerId: string) {
+        this.debugLog('⚡ setPlayerReady DÉBUT - VALIDATION');
+        this.debugLog('  📋 sessionId', sessionId);
+        this.debugLog('  📋 playerId', playerId);
+
+        // 🔍 Validation ultra-stricte (comme dans la version debug)
+        if (!sessionId) {
+            this.debugLog('❌ sessionId is falsy', sessionId);
+            return { success: false, error: 'sessionId is required' };
+        }
+        if (!playerId) {
+            this.debugLog('❌ playerId is falsy', playerId);
+            return { success: false, error: 'playerId is required' };
+        }
+        if (typeof sessionId !== 'string') {
+            this.debugLog('❌ sessionId is not string', typeof sessionId);
+            return { success: false, error: 'sessionId must be string' };
+        }
+        if (typeof playerId !== 'string') {
+            this.debugLog('❌ playerId is not string', typeof playerId);
+            return { success: false, error: 'playerId must be string' };
+        }
+
+        try {
+            const request: SetReadyRequest = {
+                sessionId: sessionId,
+                playerId: playerId,
+                ready: true
+            };
+
+            this.debugLog('📤 Envoi setReady request', request);
+            const { response } = await this.sessionClient.setReady(request);
+            this.debugLog('📥 setReady response reçue', response);
+
+            if (response.success) {
+                this.debugLog('✅ setReady SUCCESS', { gameStarted: response.gameStarted });
+                return {
+                    success: true,
+                    gameStarted: response.gameStarted
+                };
+            } else if (response.error) {
+                this.debugLog('❌ setReady SERVER ERROR', response.error);
+                return {
+                    success: false,
+                    error: response.error.message
+                };
+            }
+
+            this.debugLog('❌ setReady INVALID RESPONSE FORMAT');
+            return {
+                success: false,
+                error: "Échec de la requête"
+            };
+        } catch (error) {
+            this.debugLog('💥 setReady EXCEPTION', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    async getSessionState(sessionId: string) {
+        // Log léger pour éviter le spam pendant le polling
+        this.debugLog('📊 getSessionState', { sessionId: sessionId?.substring(0, 8) + '...' });
+
+        try {
+            const request: GetSessionStateRequest = {
+                sessionId: sessionId
+            };
+
+            const { response } = await this.sessionClient.getSessionState(request);
+
+            if (response.gameState) {
+                return {
+                    success: true,
+                    sessionState: response.gameState
+                };
+            } else if (response.error) {
+                this.debugLog('❌ getSessionState ERROR', response.error);
+                return {
+                    success: false,
+                    error: response.error.message
+                };
+            }
+
+            return {
+                success: false,
+                error: "Aucun état de session retourné"
+            };
+        } catch (error) {
+            this.debugLog('💥 getSessionState EXCEPTION', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    async leaveSession(sessionId: string, playerId: string) {
+        this.debugLog('🚪 leaveSession', { sessionId, playerId });
+        try {
+            return { success: true };
+        } catch (error) {
+            this.debugLog('💥 leaveSession EXCEPTION', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    // ============================================================================
+    // 🎲 NOUVELLES MÉTHODES GAMEPLAY - gRPC UNIQUEMENT (avec debug)
+    // ============================================================================
+
+    // 🎲 Démarrer un nouveau tour (tire une tuile aléatoire)
+    async startNewTurn(sessionId: string) {
+        this.debugLog('🎲 startNewTurn DÉBUT', { sessionId });
+
+        try {
+            const request: StartTurnRequest = {
+                sessionId: sessionId
+            };
+
+            this.debugLog('📤 Envoi startTurn request', request);
+            const { response } = await this.gameClient.startTurn(request);
+            this.debugLog('📥 startTurn response reçue', response);
+
+            if (response.success) {
+                this.debugLog('✅ startTurn SUCCESS', {
+                    announcedTile: response.announcedTile,
+                    turnNumber: response.turnNumber
+                });
+
+                return {
+                    success: true,
+                    announcedTile: response.announcedTile,
+                    tileImage: response.tileImage,
+                    turnNumber: response.turnNumber,
+                    waitingForPlayers: response.waitingForPlayers,
+                    gameState: response.gameState
+                };
+            } else if (response.error) {
+                this.debugLog('❌ startTurn ERROR', response.error);
+                return {
+                    success: false,
+                    error: response.error.message
+                };
+            }
+
+            return {
+                success: false,
+                error: "Échec du démarrage du tour"
+            };
+        } catch (error) {
+            this.debugLog('💥 startTurn EXCEPTION', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    // 🎯 Jouer un mouvement (position sur le plateau)
+    async makeMove(sessionId: string, playerId: string, position: number) {
+        this.debugLog('🎯 makeMove DÉBUT', { sessionId, playerId, position });
+
+        try {
+            const request: MakeMoveRequest = {
+                sessionId: sessionId,
+                playerId: playerId,
+                moveData: `{"position":${position}}`,
+                timestamp: BigInt(Date.now())
+            };
+
+            this.debugLog('📤 Envoi makeMove request', request);
+            const { response } = await this.gameClient.makeMove(request);
+            this.debugLog('📥 makeMove response reçue', response);
+
+            if (response.result.oneofKind === "success") {
+                const success = response.result.success;
+                this.debugLog('✅ makeMove SUCCESS', {
+                    pointsEarned: success.pointsEarned,
+                    isGameOver: success.isGameOver
+                });
+
+                return {
+                    success: true,
+                    pointsEarned: success.pointsEarned,
+                    mctsResponse: success.mctsResponse,
+                    turnCompleted: true,
+                    isGameOver: success.isGameOver,
+                    finalScores: "{}",
+                    newGameState: String(success.newGameState || '{}')
+                };
+            } else if (response.result.oneofKind === "error") {
+                this.debugLog('❌ makeMove ERROR', response.result.error);
+                return {
+                    success: false,
+                    error: response.result.error.message
+                };
+            }
+
+            return {
+                success: false,
+                error: "Échec du mouvement"
+            };
+        } catch (error) {
+            this.debugLog('💥 makeMove EXCEPTION', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+// Ajoutez cette méthode dans votre classe GameClient
+    private safeStringify(obj: any): string {
+        if (!obj) return '{}';
+
+        try {
+            return JSON.stringify(obj, (key, value) => {
+                // Convertir BigInt en string pour éviter l'erreur
+                if (typeof value === 'bigint') {
+                    return value.toString();
+                }
+                return value;
+            });
+        } catch (error) {
+            // Si ça plante encore, conversion simple en string
+            return String(obj);
+        }
+    }
+    // 📊 Obtenir l'état du gameplay
+    async getGameplayState(sessionId: string) {
+        this.debugLog('📊 getGameplayState', { sessionId });
+
+        try {
+            const request: GetGameStateRequest = {
+                sessionId: sessionId
+            };
+
+            const { response } = await this.gameClient.getGameState(request);
+
+            if (response.success) {
+                return {
+                    success: true,
+                    gameState: response.gameState,
+                    currentTile: response.currentTile,
+                    currentTileImage: response.currentTileImage, // ✅ NOUVEAU CHAMP!
+                    currentTurn: response.currentTurn,
+                    waitingForPlayers: response.waitingForPlayers,
+                    isGameFinished: response.isGameFinished,
+                    finalScores: response.finalScores
+                };
+            } else if (response.error) {
+                this.debugLog('❌ getGameplayState ERROR', response.error);
+                return {
+                    success: false,
+                    error: response.error.message
+                };
+            }
+
+            return {
+                success: false,
+                error: "Échec de récupération de l'état"
+            };
+        } catch (error) {
+            this.debugLog('💥 getGameplayState EXCEPTION', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+    async getGameState(sessionId: string) {
+        this.debugLog('🎮 getGameState DIRECT', { sessionId });
+
+        try {
+            const request: GetGameStateRequest = {
+                sessionId: sessionId
+            };
+
+            const { response } = await this.gameClient.getGameState(request);
+
+            if (response.success) {
+                this.debugLog('✅ getGameState SUCCESS', {
+                    currentTile: response.currentTile,
+                    currentTileImage: response.currentTileImage, // ✅ Log pour debug
+                    currentTurn: response.currentTurn,
+                    isGameFinished: response.isGameFinished
+                });
+
+                return {
+                    success: true,
+                    gameState: response.gameState,
+                    currentTile: response.currentTile,
+                    currentTileImage: response.currentTileImage, // ✅ EXPOSÉ!
+                    currentTurn: response.currentTurn,
+                    waitingForPlayers: response.waitingForPlayers,
+                    isGameFinished: response.isGameFinished,
+                    finalScores: response.finalScores
+                };
+            } else if (response.error) {
+                this.debugLog('❌ getGameState ERROR', response.error);
+                return {
+                    success: false,
+                    error: response.error.message
+                };
+            }
+
+            return {
+                success: false,
+                error: "Échec de récupération de l'état de jeu"
+            };
+        } catch (error) {
+            this.debugLog('💥 getGameState EXCEPTION', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+    // 🎯 Obtenir les mouvements disponibles
+    async getAvailableMoves(sessionId: string, playerId: string) {
+        this.debugLog('🎯 getAvailableMoves', { sessionId, playerId });
+
+        try {
+            const request: GetAvailableMovesRequest = {
+                sessionId: sessionId,
+                playerId: playerId
+            };
+
+            const { response } = await this.gameClient.getAvailableMoves(request);
+
+            if (!response.error) {
+                return {
+                    success: true,
+                    availableMoves: response.availableMoves
+                };
+            } else {
+                this.debugLog('❌ getAvailableMoves ERROR', response.error);
+                return {
+                    success: false,
+                    error: response.error.message
+                };
+            }
+        } catch (error) {
+            this.debugLog('💥 getAvailableMoves EXCEPTION', error);
+            return {
+                success: false,
+                error: this.extractErrorMessage(error)
+            };
+        }
+    }
+
+    // ============================================================================
+    // MÉTHODES UTILITAIRES (améliorées)
+    // ============================================================================
+
+    private extractErrorMessage(error: any): string {
+        this.debugLog('🔍 extractErrorMessage input', error);
+
+        if (error?.message) {
+            return error.message;
+        }
+        if (typeof error === 'string') {
+            return error;
+        }
+        return 'Erreur de connexion au serveur';
+    }
+
+    // 🔧 NOUVEAU: Contrôle du debug
+    setDebugEnabled(enabled: boolean) {
+        this.debugEnabled = enabled;
+        this.debugLog(`🔧 Debug ${enabled ? 'activé' : 'désactivé'}`);
+    }
+
+    // 🔧 NOUVEAU: Test de connectivité
+    async testConnection() {
+        this.debugLog('🔧 Test de connectivité');
+        try {
+            // Test simple avec une session inexistante
+            await this.getSessionState('test-connection-123');
+            return { success: true, note: 'Server reachable' };
+        } catch (error: any) {
+            // Si on reçoit "SESSION_NOT_FOUND", c'est que la connexion fonctionne
+            if (error.message && error.message.includes('SESSION_NOT_FOUND')) {
+                return { success: true, note: 'Server reachable (test session not found)' };
+            }
+            return { success: false, error: this.extractErrorMessage(error) };
+        }
+    }
+
+    dispose() {
+        this.debugLog('🔌 GameClient disposed');
+    }
+}
+
+// Instance singleton
+export const gameClient = new GameClient();
\ No newline at end of file
diff --git a/frontend/src/services/GameStateManager.ts b/frontend/src/services/GameStateManager.ts
index f7096ea..f4fcf79 100644
--- a/frontend/src/services/GameStateManager.ts
+++ b/frontend/src/services/GameStateManager.ts
@@ -1,13 +1,13 @@
 // services/GameStateManager.ts - Utilitaires et conversions d'état
-import type { Player as ProtoPlayer, GameState as ProtoGameState } from '../generated/common';
-import type { GameState, Player } from '../hooks/useGameState';
+import type {GameState as ProtoGameState, Player as ProtoPlayer} from '../generated/common';
+import type {GameState, Player} from '../hooks/useGameState';
 
 /**
  * Service pour la gestion et conversion des états de jeu
  * Centralise les utilitaires dispersés dans le composant principal
  */
 export class GameStateManager {
-    
+
     /**
      * Convertir l'état de session reçu du backend vers le format local
      */
@@ -30,42 +30,27 @@ export class GameStateManager {
         return gameState;
     }
 
-    /**
-     * Générer le chemin d'image pour une tuile à partir de sa représentation string
-     */
-    static generateTileImagePath(tileString: string): string {
-        const [val1, val2, val3] = tileString.split('-');
-        return `../image/${val1}${val2}${val3}.png`;
-    }
-
-    /**
-     * Générer le chemin d'image pour une tuile à partir d'un array [x, y, z]
-     */
-    static generateTileImagePathFromArray(tile: [number, number, number]): string {
-        return `../image/${tile[0]}${tile[1]}${tile[2]}.png`;
-    }
+    // ❌ FONCTIONS SUPPRIMÉES - Plus nécessaires car backend gère tout
+    // static generateTileImagePath() - SUPPRIMÉ
+    // static generateTileImagePathFromArray() - SUPPRIMÉ
 
     /**
      * Mettre à jour les plateaux de joueurs à partir de l'état de jeu
      */
     static updatePlateauTiles(
         gameState: any,
-        setPlateauTiles: (tiles: {[playerId: string]: string[]}) => void,
+        setPlateauTiles: (tiles: { [playerId: string]: string[] }) => void,
         setAvailablePositions: (positions: number[]) => void,
         session: () => { playerId: string } | null,
         addDebugLog: (message: string) => void
     ) {
         if (gameState.player_plateaus) {
-            const newPlateauTiles: {[playerId: string]: string[]} = {};
+            const newPlateauTiles: { [playerId: string]: string[] } = {};
 
             Object.entries(gameState.player_plateaus).forEach(([playerId, plateau]: [string, any]) => {
-                newPlateauTiles[playerId] = plateau.tiles.map((tile: any) => {
-                    if (tile[0] === 0 && tile[1] === 0 && tile[2] === 0) {
-                        return ''; // Position vide
-                    } else {
-                        return GameStateManager.generateTileImagePathFromArray([tile[0], tile[1], tile[2]]);
-                    }
-                });
+                // ✅ UTILISER les images du backend
+                newPlateauTiles[playerId] = plateau.tile_images || [];
+                addDebugLog(`🎨 ${playerId}: ${(plateau.tile_images || []).length} images backend`);
             });
 
             setPlateauTiles(newPlateauTiles);
@@ -76,14 +61,9 @@ export class GameStateManager {
         if (currentSession && gameState.waiting_for_players?.includes(currentSession.playerId)) {
             const myPlateau = gameState.player_plateaus?.[currentSession.playerId];
             if (myPlateau) {
-                const available: number[] = [];
-                myPlateau.tiles.forEach((tile: any, index: number) => {
-                    if (tile[0] === 0 && tile[1] === 0 && tile[2] === 0) {
-                        available.push(index);
-                    }
-                });
-                setAvailablePositions(available);
-                addDebugLog(`📍 Positions disponibles: ${available.length}`);
+                // ✅ UTILISER les positions du backend
+                setAvailablePositions(myPlateau.available_positions || []);
+                addDebugLog(`📍 Positions disponibles: ${(myPlateau.available_positions || []).length}`);
             }
         } else {
             setAvailablePositions([]);
@@ -97,11 +77,11 @@ export class GameStateManager {
         const currentSession = session();
         if (!currentSession) return;
 
-        // URL pour la session MCTS
+        // 🔧 NOUVEAU: Utiliser un nom différent pour le viewer
         const mctsUrl = `${window.location.origin}${window.location.pathname}?` +
             `sessionCode=${currentSession.sessionCode}&` +
-            `playerId=mcts_ai&` +
-            `playerName=${encodeURIComponent('🤖 MCTS IA')}&` +
+            `playerId=mcts_viewer&` +                                    // ✅ ID différent
+            `playerName=${encodeURIComponent('🔍 MCTS Viewer')}&` +       // ✅ Nom différent
             `mode=viewer`;
 
         window.open(mctsUrl, '_blank', 'width=1200,height=800');
@@ -165,16 +145,40 @@ export class GameStateManager {
         }
     }
 
-    /**
-     * Debugger l'état des joueurs pour MCTS
-     */
-    static debugPlayerState(players: Player[], addDebugLog: (message: string) => void) {
-        addDebugLog(`👥 Joueurs reçus: ${players.map(p => `${p.name}(${p.id})`).join(', ')}`);
-        const mctsPlayer = players.find(p => p.id === 'mcts_ai');
-        if (mctsPlayer) {
-            addDebugLog(`🤖 MCTS trouvé: ${mctsPlayer.name}, ready: ${mctsPlayer.isReady}`);
-        } else {
-            addDebugLog(`❌ MCTS non trouvé dans les joueurs !`);
+// Dans GameStateManager.ts - NOUVELLE fonction pour viewer MCTS
+    // Dans GameStateManager.ts - CORRIGER updatePlateauTilesForViewer
+    static updatePlateauTilesForViewer(
+        gameState: any,
+        setPlateauTiles: (tiles: {[playerId: string]: string[]}) => void,
+        setAvailablePositions: (positions: number[]) => void,
+        session: () => { playerId: string } | null,
+        addDebugLog: (message: string) => void
+    ) {
+        if (gameState.player_plateaus) {
+            // 🔧 NOUVEAU: Pour le viewer, afficher SEULEMENT le plateau MCTS
+            const currentSession = session();
+            if (currentSession && currentSession.playerId.includes('viewer')) {
+                const mctsPlateau = gameState.player_plateaus?.['mcts_ai'];
+                if (mctsPlateau) {
+                    // ✅ UTILISER les images du backend pour MCTS
+                    setPlateauTiles({ 'mcts_ai': mctsPlateau.tile_images || [] });
+
+                    // ✅ UTILISER les positions du backend pour MCTS
+                    setAvailablePositions(mctsPlateau.available_positions || []);
+                    addDebugLog(`👁️ VIEWER: Plateau MCTS uniquement - ${(mctsPlateau.tile_images || []).filter((t: string) => t !== '').length} tuiles placées`);
+                    return; // ✅ SORTIR ICI pour éviter la logique normale
+                }
+            }
+
+            // Logique normale pour les vrais joueurs
+            const newPlateauTiles: {[playerId: string]: string[]} = {};
+            Object.entries(gameState.player_plateaus).forEach(([playerId, plateau]: [string, any]) => {
+                // ✅ UTILISER les images du backend
+                newPlateauTiles[playerId] = plateau.tile_images || [];
+            });
+            setPlateauTiles(newPlateauTiles);
+
+            // Reste de la logique normale...
         }
     }
 }
\ No newline at end of file
diff --git a/frontend/src/styles/multiplayer.css b/frontend/src/styles/multiplayer.css
index bec0a46..b2c6b25 100644
--- a/frontend/src/styles/multiplayer.css
+++ b/frontend/src/styles/multiplayer.css
@@ -840,4 +840,124 @@ button:disabled {
   text-align: center;
   margin-top: 8px;
   border: 1px solid rgba(139, 92, 246, 0.3);
+}
+/* Ajoutez ce CSS à votre multiplayer.css ou styles.css */
+
+.classic-board-area {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  gap: 15px;
+  margin: 20px 0;
+}
+
+.classic-game-canvas {
+  border: 2px solid #333;
+  border-radius: 8px;
+  background-color: #1e1e1e;
+  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
+  transition: box-shadow 0.3s ease;
+}
+
+.classic-game-canvas:hover {
+  box-shadow: 0 6px 12px rgba(0, 255, 255, 0.2);
+}
+
+.classic-instructions {
+  text-align: center;
+  max-width: 500px;
+  padding: 10px;
+  background: rgba(0, 0, 0, 0.3);
+  border-radius: 8px;
+  border: 1px solid rgba(255, 255, 255, 0.1);
+}
+
+.classic-instructions p {
+  margin: 5px 0;
+  font-size: 0.95em;
+}
+
+.classic-game-container {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  gap: 20px;
+  width: 100%;
+}
+
+.classic-game-info {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  gap: 15px;
+  width: 100%;
+  max-width: 600px;
+}
+
+.turn-status {
+  padding: 15px;
+  border-radius: 8px;
+  text-align: center;
+  min-width: 300px;
+}
+
+.player-turn-indicator {
+  background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.1));
+  border: 2px solid #00ffff;
+  color: #00ffff;
+  padding: 10px;
+  border-radius: 8px;
+}
+
+.waiting-indicator {
+  background: rgba(255, 170, 0, 0.1);
+  border: 2px solid #ffaa00;
+  color: #ffaa00;
+  padding: 10px;
+  border-radius: 8px;
+}
+
+.turn-text, .waiting-text {
+  display: block;
+  font-size: 1.1em;
+  font-weight: bold;
+  margin-bottom: 5px;
+}
+
+.positions-count {
+  display: block;
+  font-size: 0.9em;
+  opacity: 0.8;
+}
+/* Ajouter à multiplayer.css */
+.viewer-info {
+  background: rgba(34, 197, 94, 0.2);
+  padding: 15px;
+  border-radius: 8px;
+  margin-bottom: 20px;
+  text-align: center;
+  border: 1px solid rgba(34, 197, 94, 0.3);
+}
+
+.viewer-status {
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  gap: 10px;
+  font-weight: bold;
+  color: #22c55e;
+  margin-bottom: 8px;
+}
+
+.viewer-icon {
+  font-size: 24px;
+}
+
+.viewer-note {
+  opacity: 0.8;
+  font-style: italic;
+}
+
+.viewer-note small {
+  color: rgba(255, 255, 255, 0.7);
 }
\ No newline at end of file
diff --git a/frontend/vite.config.ts b/frontend/vite.config.ts
index 56163ff..e122353 100644
--- a/frontend/vite.config.ts
+++ b/frontend/vite.config.ts
@@ -1,26 +1,38 @@
-/// <reference types="vitest" />
-/// <reference types="vite/client" />
-
 import { defineConfig } from 'vite';
-import solidPlugin from 'vite-plugin-solid';
+import solid from 'vite-plugin-solid';
 
 export default defineConfig({
-  plugins: [solidPlugin()],
+  plugins: [solid()],
   server: {
     port: 3000,
+    proxy: {
+      // Proxy pour gRPC-Web - redirige vers votre serveur Rust
+      '/takeiteasygame.v1.SessionService': {
+        target: 'http://localhost:50051',
+        changeOrigin: true,
+        headers: {
+          'Content-Type': 'application/grpc-web+proto'
+        }
+      },
+      '/takeiteasygame.v1.GameService': {
+        target: 'http://localhost:50051',
+        changeOrigin: true,
+        headers: {
+          'Content-Type': 'application/grpc-web+proto'
+        }
+      }
+    }
   },
-  test: {
-    environment: 'jsdom',
-    globals: false,
-    setupFiles: ['node_modules/@testing-library/jest-dom/vitest'],
-    // if you have few tests, try commenting this
-    // out to improve performance:
-    isolate: false,
-  },
-  build: {
-    target: 'esnext',
-  },
-  resolve: {
-    conditions: ['development', 'browser'],
+  define: {
+    // Variables d'environnement pour le développement
+    __GRPC_WEB_ENDPOINT__: JSON.stringify('http://localhost:50051'),
   },
-});
+  optimizeDeps: {
+    // Inclure les dépendances gRPC-Web dans l'optimisation
+    include: [
+      '@protobuf-ts/runtime',
+      '@protobuf-ts/runtime-rpc',
+      '@protobuf-ts/grpcweb-transport'
+    ]
+  }
+});
\ No newline at end of file
diff --git a/mistral-code.py b/mistral-code.py
index 9272195..fa8edcd 100644
--- a/mistral-code.py
+++ b/mistral-code.py
@@ -9,7 +9,7 @@ if not API_KEY:
     print("❌ MISTRAL_API_KEY manquant. Ajoutez-le à votre fichier shell.")
     sys.exit(1)
 
-MODEL = "mistral-small"
+MODEL = "mistral-small-2501"
 
 def call_mistral(prompt, context=""):
     headers = {
@@ -20,22 +20,33 @@ def call_mistral(prompt, context=""):
         {"role": "user", "content": f"{prompt}\n\n{context}"}
     ]
     data = {"model": MODEL, "messages": messages}
-    response = requests.post("https://api.mistral.ai/v1/chat/completions", headers=headers, json=data)
+
     try:
+        response = requests.post(
+            "https://api.mistral.ai/v1/chat/completions",
+            headers=headers,
+            json=data,
+            verify=False  # <-- Désactivation SSL pour environnements filtrés
+        )
         return response.json()["choices"][0]["message"]["content"].strip()
     except Exception as e:
-        return f"❌ Erreur API : {e}\n{response.text}"
+        return f"❌ Erreur API : {e}\n{response.text if 'response' in locals() else ''}"
 
 def read_code_files():
     code = ""
-    for fname in os.listdir():
-        if fname.endswith(('.py', '.rs', '.js', '.ts', '.java', '.cpp', '.c', '.go')):
-            try:
-                with open(fname) as f:
-                    code += f"\n\n# Fichier : {fname}\n" + f.read()
-            except:
-                continue
-    return code if code else "[Pas de fichiers code lisibles dans ce dossier]"
+    extensions = ('.py', '.rs', '.js', '.ts', '.java', '.cpp', '.c', '.go')
+    for root, dirs, files in os.walk("."):
+        for file in files:
+            if file.endswith(extensions):
+                filepath = os.path.join(root, file)
+                try:
+                    with open(filepath, encoding="utf-8", errors="ignore") as f:
+                        rel_path = os.path.relpath(filepath)
+                        code += f"\n\n# Fichier : {rel_path}\n" + f.read()
+                except Exception as e:
+                    code += f"\n\n# Fichier : {filepath} (non lisible : {e})\n"
+    return code or "[Aucun fichier code détecté dans ce projet]"
+
 
 def main():
     print("╭──────────────────────────────────────────────────────────────╮")
@@ -68,3 +79,6 @@ def main():
             print("⏳ Envoi à Mistral...")
             response = call_mistral(user_input, context)
             print("\n" + response + "\n")
+
+if __name__ == "__main__":
+    main()
diff --git a/protoc-gen-grpc-web-1.4.2-linux-x86_64 b/protoc-gen-grpc-web-1.4.2-linux-x86_64
deleted file mode 100644
index 5c4fa19..0000000
Binary files a/protoc-gen-grpc-web-1.4.2-linux-x86_64 and /dev/null differ
diff --git a/protos/common.protos b/protos/common.protos
deleted file mode 100644
index 0c5c218..0000000
--- a/protos/common.protos
+++ /dev/null
@@ -1,34 +0,0 @@
-syntax = "proto3";
-package takeiteasygame.v1;
-
-// Types communs partagés entre services
-message Player {
-  string id = 1;
-  string name = 2;
-  int32 score = 3;
-  bool is_ready = 4;
-  bool is_connected = 5;
-  int64 joined_at = 6;
-}
-
-message GameState {
-  string session_id = 1;
-  repeated Player players = 2;
-  string current_player_id = 3;
-  SessionState state = 4;
-  string board_state = 5; // JSON serialized board
-  int32 turn_number = 6;
-}
-
-enum SessionState {
-  WAITING = 0;
-  IN_PROGRESS = 1;
-  FINISHED = 2;
-  CANCELLED = 3;
-}
-
-message Error {
-  string code = 1;
-  string message = 2;
-  map<string, string> details = 3;
-}
\ No newline at end of file
diff --git a/protos/game_service.proto b/protos/game_service.proto
index 58b78e6..3ea4bfa 100644
--- a/protos/game_service.proto
+++ b/protos/game_service.proto
@@ -9,6 +9,10 @@ service GameService {
 
   // Obtenir les mouvements disponibles
   rpc GetAvailableMoves(GetAvailableMovesRequest) returns (GetAvailableMovesResponse);
+  // 🎲 NOUVELLES MÉTHODES GAMEPLAY
+  rpc StartTurn(StartTurnRequest) returns (StartTurnResponse);
+  rpc GetGameState(GetGameStateRequest) returns (GetGameStateResponse);
+
 }
 
 message MakeMoveRequest {
@@ -40,4 +44,35 @@ message GetAvailableMovesRequest {
 message GetAvailableMovesResponse {
   repeated string available_moves = 1; // JSON des mouvements possibles
   Error error = 2;
+}
+
+// Démarrer un nouveau tour
+message StartTurnRequest {
+  string session_id = 1;
+}
+
+message StartTurnResponse {
+  bool success = 1;
+  string announced_tile = 2;      // "5-3-7"
+  string tile_image = 3;          // "537.png"
+  int32 turn_number = 4;
+  repeated string waiting_for_players = 5;
+  string game_state = 6;          // JSON complet de l'état
+  Error error = 7;
+}
+
+// Obtenir l'état complet du jeu
+message GetGameStateRequest {
+  string session_id = 1;
+}
+message GetGameStateResponse {
+  bool success = 1;
+  string game_state = 2;          // JSON complet de l'état
+  string current_tile = 3;        // "5-3-7" ou vide
+  string current_tile_image = 4;  // ✅ NOUVEAU: "../image/537.png"
+  int32 current_turn = 5;         // Numéro du tour (0-18) - RENUMÉROTÉ
+  repeated string waiting_for_players = 6; // RENUMÉROTÉ
+  bool is_game_finished = 7;      // RENUMÉROTÉ
+  string final_scores = 8;        // JSON des scores finaux - RENUMÉROTÉ
+  Error error = 9;                // RENUMÉROTÉ
 }
\ No newline at end of file
diff --git a/protos/game_service.protos b/protos/game_service.protos
deleted file mode 100644
index 58b78e6..0000000
--- a/protos/game_service.protos
+++ /dev/null
@@ -1,43 +0,0 @@
-syntax = "proto3";
-package takeiteasygame.v1;
-
-import "common.proto";
-
-service GameService {
-  // Faire un mouvement
-  rpc MakeMove(MakeMoveRequest) returns (MakeMoveResponse);
-
-  // Obtenir les mouvements disponibles
-  rpc GetAvailableMoves(GetAvailableMovesRequest) returns (GetAvailableMovesResponse);
-}
-
-message MakeMoveRequest {
-  string session_id = 1;
-  string player_id = 2;
-  string move_data = 3; // JSON du mouvement
-  int64 timestamp = 4;
-}
-
-message MakeMoveResponse {
-  oneof result {
-    MakeMoveSuccess success = 1;
-    Error error = 2;
-  }
-}
-
-message MakeMoveSuccess {
-  GameState new_game_state = 1;
-  string mcts_response = 2; // Réponse de l'IA si applicable
-  int32 points_earned = 3;
-  bool is_game_over = 4;
-}
-
-message GetAvailableMovesRequest {
-  string session_id = 1;
-  string player_id = 2;
-}
-
-message GetAvailableMovesResponse {
-  repeated string available_moves = 1; // JSON des mouvements possibles
-  Error error = 2;
-}
\ No newline at end of file
diff --git a/protos/session_service.protos b/protos/session_service.protos
deleted file mode 100644
index 8575d9c..0000000
--- a/protos/session_service.protos
+++ /dev/null
@@ -1,75 +0,0 @@
-syntax = "proto3";
-
-package takeiteasygame.v1;
-
-import "common.proto";
-
-// ============================================================================
-// MESSAGES SESSION SERVICE
-// ============================================================================
-
-message CreateSessionRequest {
-  string player_name = 1;
-  int32 max_players = 2;
-  string game_mode = 3;
-}
-
-message CreateSessionSuccess {
-  string session_code = 1;
-  string session_id = 2;
-  string player_id = 3;
-  Player player = 4;
-}
-
-message CreateSessionResponse {
-  oneof result {
-    CreateSessionSuccess success = 1;
-    Error error = 2;
-  }
-}
-
-message JoinSessionRequest {
-  string session_code = 1;
-  string player_name = 2;
-}
-
-message JoinSessionSuccess {
-  string session_id = 1;
-  string player_id = 2;
-  GameState game_state = 3;
-}
-
-message JoinSessionResponse {
-  oneof result {
-    JoinSessionSuccess success = 1;
-    Error error = 2;
-  }
-}
-
-message SetReadyRequest {
-  string session_id = 1;
-  string player_id = 2;
-  bool ready = 3;
-}
-
-message SetReadyResponse {
-  bool success = 1;
-  Error error = 2;
-  bool game_started = 3;
-}
-
-message GetSessionStateRequest {
-  string session_id = 1;
-}
-
-message GetSessionStateResponse {
-  GameState game_state = 1;
-  Error error = 2;
-}
-
-service SessionService {
-  rpc CreateSession(CreateSessionRequest) returns (CreateSessionResponse);
-  rpc JoinSession(JoinSessionRequest) returns (JoinSessionResponse);
-  rpc SetReady(SetReadyRequest) returns (SetReadyResponse);
-  rpc GetSessionState(GetSessionStateRequest) returns (GetSessionStateResponse);
-}
\ No newline at end of file
diff --git a/src/build.rs b/src/build.rs
index 508db92..8b125f1 100644
--- a/src/build.rs
+++ b/src/build.rs
@@ -4,8 +4,8 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {
         .build_server(true)
         .build_client(true)
         .compile(
-            &["proto/session_manager.proto"],
-            &["proto/"],
+            &["protos/session_manager.protos"],
+            &["protos/"],
         )?;
 
     // Alternative si vous voulez plus de contrôle :
@@ -15,8 +15,8 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {
         .build_server(true)
         .build_client(true)
         .compile(
-            &["proto/session_manager.proto"],
-            &["proto/"],
+            &["protos/session_manager.protos"],
+            &["protos/"],
         )?;
     */
 
diff --git a/src/data/save_data.rs b/src/data/save_data.rs
index 7b2b24f..06abcae 100644
--- a/src/data/save_data.rs
+++ b/src/data/save_data.rs
@@ -39,15 +39,6 @@ pub fn save_game_data(file_path: &str, game_data: Vec<MCTSResult>) {
     };
 
     // 🔄 Sauvegarde des tensors concaténés
-    if let Err(e) = combined_states.save(format!("{}_states.pt", file_path)) {
-        log::info!("❌ Error saving states: {:?}", e);
-    }
-    if let Err(e) = combined_positions.save(format!("{}_positions.pt", file_path)) {
-        log::info!("❌ Error saving positions: {:?}", e);
-    }
-    if let Err(e) = combined_subscores.save(format!("{}_subscores.pt", file_path)) {
-        log::info!("❌ Error saving subscores: {:?}", e);
-    }
-
-    log::info!("✅ Save complete!");
-}
+    if let Err(e) = combined_states.save(format!("{}_states.pt", file_path)) {    }
+    if let Err(e) = combined_positions.save(format!("{}_positions.pt", file_path)) {    }
+    if let Err(e) = combined_subscores.save(format!("{}_subscores.pt", file_path)) {    }}
diff --git a/src/game/create_deck.rs b/src/game/create_deck.rs
index 58577bd..252b0d3 100644
--- a/src/game/create_deck.rs
+++ b/src/game/create_deck.rs
@@ -1,4 +1,4 @@
-use crate::game::deck::Deck;
+pub(crate) use crate::game::deck::Deck;
 use crate::game::tile::Tile;
 
 pub fn create_deck() -> Deck {
diff --git a/src/game/deck.rs b/src/game/deck.rs
index 2709b0d..9d66fff 100644
--- a/src/game/deck.rs
+++ b/src/game/deck.rs
@@ -1,6 +1,7 @@
+use serde::{Deserialize, Serialize};
 use crate::game::tile::Tile;
 
-#[derive(Debug, Clone, PartialEq)]
+#[derive(Debug, Clone, PartialEq,Serialize,Deserialize)]
 pub struct Deck{
     pub(crate) tiles: Vec<Tile>,
 }
\ No newline at end of file
diff --git a/src/game/plateau.rs b/src/game/plateau.rs
index 0502b7a..ee9ad19 100644
--- a/src/game/plateau.rs
+++ b/src/game/plateau.rs
@@ -1,6 +1,7 @@
+use serde::{Deserialize, Serialize};
 use crate::game::tile::Tile;
 
-#[derive(Debug, Clone, PartialEq)]
+#[derive(Debug, Clone, PartialEq,Serialize,Deserialize)]
 pub(crate) struct Plateau{
     pub(crate) tiles: Vec<Tile>,
 }
diff --git a/src/game/tile.rs b/src/game/tile.rs
index 23e4346..488d9fa 100644
--- a/src/game/tile.rs
+++ b/src/game/tile.rs
@@ -1,2 +1,4 @@
-#[derive(Debug, Clone, PartialEq, Copy,Hash,Eq)]
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Clone, PartialEq, Copy,Hash,Eq,Serialize,Deserialize)]
 pub(crate) struct Tile(pub i32, pub i32, pub i32);
\ No newline at end of file
diff --git a/src/generated/lib.rs b/src/generated/lib.rs
index e69de29..a9b8d32 100644
--- a/src/generated/lib.rs
+++ b/src/generated/lib.rs
@@ -0,0 +1,4 @@
+// src/generated/lib.rs - Point d'entrée pour les modules générés
+
+// Include the generated protobuf code
+include!("takeiteasygame.v1.rs");
\ No newline at end of file
diff --git a/src/generated/mod.rs b/src/generated/mod.rs
index e69de29..b5e4011 100644
--- a/src/generated/mod.rs
+++ b/src/generated/mod.rs
@@ -0,0 +1,8 @@
+// src/generated/mod.rs - Module racine pour le code généré
+
+pub mod takeiteasygame {
+    pub mod v1 {
+        // Include the tonic-generated code
+        include!("takeiteasygame.v1.rs");
+    }
+}
\ No newline at end of file
diff --git a/src/generated/mod_manual.rs b/src/generated/mod_manual.rs
index e69de29..5bd5336 100644
--- a/src/generated/mod_manual.rs
+++ b/src/generated/mod_manual.rs
@@ -0,0 +1,271 @@
+// src/generated/mod_manual.rs - Types temporaires avant génération complète
+
+pub mod takeiteasygame {
+    pub mod v1 {
+        use std::collections::HashMap;
+        use serde::{Deserialize, Serialize};
+        use tonic::{Request, Response, Status};
+
+        // ============================================================================
+        // TYPES DE BASE - COMPATIBLES AVEC VOTRE SYSTÈME
+        // ============================================================================
+
+        #[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
+        pub struct Player {
+            pub id: String,
+            pub name: String,
+            pub score: i32,
+            pub is_ready: bool,
+            pub is_connected: bool,
+            pub joined_at: i64,
+        }
+
+        #[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
+        pub struct GameState {
+            pub session_id: String,
+            pub players: Vec<Player>,
+            pub current_player_id: String,
+            pub state: i32, // 0=WAITING, 1=IN_PROGRESS, 2=FINISHED
+            pub board_state: String, // JSON de TakeItEasyGameState
+            pub turn_number: i32,
+        }
+
+        #[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
+        pub struct Error {
+            pub code: String,
+            pub message: String,
+            pub details: HashMap<String, String>,
+        }
+
+        // ============================================================================
+        // MESSAGES DE SESSION
+        // ============================================================================
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct CreateSessionRequest {
+            pub player_name: String,
+            pub max_players: i32,
+            pub game_mode: String,
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct CreateSessionSuccess {
+            pub session_code: String,
+            pub session_id: String,
+            pub player_id: String,
+            pub player: Option<Player>,
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct CreateSessionResponse {
+            pub result: Option<create_session_response::Result>,
+        }
+
+        pub mod create_session_response {
+            use super::*;
+
+            #[derive(Clone, PartialEq, Debug)]
+            pub enum Result {
+                Success(CreateSessionSuccess),
+                Error(Error),
+            }
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct JoinSessionRequest {
+            pub session_code: String,
+            pub player_name: String,
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct JoinSessionSuccess {
+            pub session_id: String,
+            pub player_id: String,
+            pub game_state: Option<GameState>,
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct JoinSessionResponse {
+            pub result: Option<join_session_response::Result>,
+        }
+
+        pub mod join_session_response {
+            use super::*;
+
+            #[derive(Clone, PartialEq, Debug)]
+            pub enum Result {
+                Success(JoinSessionSuccess),
+                Error(Error),
+            }
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct SetReadyRequest {
+            pub session_id: String,
+            pub player_id: String,
+            pub ready: bool,
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct SetReadyResponse {
+            pub success: bool,
+            pub error: Option<Error>,
+            pub game_started: bool,
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct GetSessionStateRequest {
+            pub session_id: String,
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct GetSessionStateResponse {
+            pub game_state: Option<GameState>,
+            pub error: Option<Error>,
+        }
+
+        // ============================================================================
+        // MESSAGES DE JEU
+        // ============================================================================
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct MakeMoveRequest {
+            pub session_id: String,
+            pub player_id: String,
+            pub move_data: String,
+            pub timestamp: i64,
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct MakeMoveSuccess {
+            pub new_game_state: Option<GameState>,
+            pub mcts_response: String,
+            pub points_earned: i32,
+            pub is_game_over: bool,
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct MakeMoveResponse {
+            pub result: Option<make_move_response::Result>,
+        }
+
+        pub mod make_move_response {
+            use super::*;
+
+            #[derive(Clone, PartialEq, Debug)]
+            pub enum Result {
+                Success(MakeMoveSuccess),
+                Error(Error),
+            }
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct GetAvailableMovesRequest {
+            pub session_id: String,
+            pub player_id: String,
+        }
+
+        #[derive(Clone, PartialEq, Debug)]
+        pub struct GetAvailableMovesResponse {
+            pub available_moves: Vec<String>,
+            pub error: Option<Error>,
+        }
+
+        // ============================================================================
+        // TRAITS DE SERVICE - DÉFINITIONS MINIMALES
+        // ============================================================================
+
+        #[tonic::async_trait]
+        pub trait SessionService: Send + Sync + 'static {
+            async fn create_session(
+                &self,
+                request: Request<CreateSessionRequest>,
+            ) -> Result<Response<CreateSessionResponse>, Status>;
+
+            async fn join_session(
+                &self,
+                request: Request<JoinSessionRequest>,
+            ) -> Result<Response<JoinSessionResponse>, Status>;
+
+            async fn set_ready(
+                &self,
+                request: Request<SetReadyRequest>,
+            ) -> Result<Response<SetReadyResponse>, Status>;
+
+            async fn get_session_state(
+                &self,
+                request: Request<GetSessionStateRequest>,
+            ) -> Result<Response<GetSessionStateResponse>, Status>;
+        }
+
+        #[tonic::async_trait]
+        pub trait GameService: Send + Sync + 'static {
+            async fn make_move(
+                &self,
+                request: Request<MakeMoveRequest>,
+            ) -> Result<Response<MakeMoveResponse>, Status>;
+
+            async fn get_available_moves(
+                &self,
+                request: Request<GetAvailableMovesRequest>,
+            ) -> Result<Response<GetAvailableMovesResponse>, Status>;
+        }
+
+        // ============================================================================
+        // SERVEURS GRPC - IMPLÉMENTATION TEMPORAIRE SIMPLIFIÉE
+        // ============================================================================
+
+        pub mod session_service_server {
+            use super::*;
+            use std::sync::Arc;
+
+            #[derive(Clone)]
+            pub struct SessionServiceServer<T> {
+                inner: Arc<T>,
+            }
+
+            impl<T> SessionServiceServer<T> {
+                pub fn new(inner: T) -> Self {
+                    Self {
+                        inner: Arc::new(inner),
+                    }
+                }
+            }
+
+            // Implémentation minimale pour permettre la compilation
+            // Sera remplacée par tonic-build
+            use tonic::server::{NamedService, UnaryService};
+            use tonic::codegen::*;
+
+            impl<T: SessionService> NamedService for SessionServiceServer<T> {
+                const NAME: &'static str = "takeiteasygame.v1.SessionService";
+            }
+
+            // Service trait sera implémenté automatiquement par tonic-build
+        }
+
+        pub mod game_service_server {
+            use super::*;
+            use std::sync::Arc;
+
+            #[derive(Clone)]
+            pub struct GameServiceServer<T> {
+                inner: Arc<T>,
+            }
+
+            impl<T> GameServiceServer<T> {
+                pub fn new(inner: T) -> Self {
+                    Self {
+                        inner: Arc::new(inner),
+                    }
+                }
+            }
+
+            use tonic::server::NamedService;
+
+            impl<T: GameService> NamedService for GameServiceServer<T> {
+                const NAME: &'static str = "takeiteasygame.v1.GameService";
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/generated/takeiteasygame.v1.rs b/src/generated/takeiteasygame.v1.rs
index b8e59f4..465b53a 100644
--- a/src/generated/takeiteasygame.v1.rs
+++ b/src/generated/takeiteasygame.v1.rs
@@ -85,12 +85,23 @@ pub struct CreateSessionRequest {
     pub player_name: ::prost::alloc::string::String,
     #[prost(int32, tag = "2")]
     pub max_players: i32,
-    /// "mcts_vs_players"
     #[prost(string, tag = "3")]
     pub game_mode: ::prost::alloc::string::String,
 }
 #[allow(clippy::derive_partial_eq_without_eq)]
 #[derive(Clone, PartialEq, ::prost::Message)]
+pub struct CreateSessionSuccess {
+    #[prost(string, tag = "1")]
+    pub session_code: ::prost::alloc::string::String,
+    #[prost(string, tag = "2")]
+    pub session_id: ::prost::alloc::string::String,
+    #[prost(string, tag = "3")]
+    pub player_id: ::prost::alloc::string::String,
+    #[prost(message, optional, tag = "4")]
+    pub player: ::core::option::Option<Player>,
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
 pub struct CreateSessionResponse {
     #[prost(oneof = "create_session_response::Result", tags = "1, 2")]
     pub result: ::core::option::Option<create_session_response::Result>,
@@ -108,23 +119,21 @@ pub mod create_session_response {
 }
 #[allow(clippy::derive_partial_eq_without_eq)]
 #[derive(Clone, PartialEq, ::prost::Message)]
-pub struct CreateSessionSuccess {
+pub struct JoinSessionRequest {
     #[prost(string, tag = "1")]
     pub session_code: ::prost::alloc::string::String,
     #[prost(string, tag = "2")]
-    pub session_id: ::prost::alloc::string::String,
-    #[prost(string, tag = "3")]
-    pub player_id: ::prost::alloc::string::String,
-    #[prost(message, optional, tag = "4")]
-    pub player: ::core::option::Option<Player>,
+    pub player_name: ::prost::alloc::string::String,
 }
 #[allow(clippy::derive_partial_eq_without_eq)]
 #[derive(Clone, PartialEq, ::prost::Message)]
-pub struct JoinSessionRequest {
+pub struct JoinSessionSuccess {
     #[prost(string, tag = "1")]
-    pub session_code: ::prost::alloc::string::String,
+    pub session_id: ::prost::alloc::string::String,
     #[prost(string, tag = "2")]
-    pub player_name: ::prost::alloc::string::String,
+    pub player_id: ::prost::alloc::string::String,
+    #[prost(message, optional, tag = "3")]
+    pub game_state: ::core::option::Option<GameState>,
 }
 #[allow(clippy::derive_partial_eq_without_eq)]
 #[derive(Clone, PartialEq, ::prost::Message)]
@@ -145,16 +154,6 @@ pub mod join_session_response {
 }
 #[allow(clippy::derive_partial_eq_without_eq)]
 #[derive(Clone, PartialEq, ::prost::Message)]
-pub struct JoinSessionSuccess {
-    #[prost(string, tag = "1")]
-    pub session_id: ::prost::alloc::string::String,
-    #[prost(string, tag = "2")]
-    pub player_id: ::prost::alloc::string::String,
-    #[prost(message, optional, tag = "3")]
-    pub game_state: ::core::option::Option<GameState>,
-}
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
 pub struct SetReadyRequest {
     #[prost(string, tag = "1")]
     pub session_id: ::prost::alloc::string::String,
@@ -178,25 +177,14 @@ pub struct SetReadyResponse {
 pub struct GetSessionStateRequest {
     #[prost(string, tag = "1")]
     pub session_id: ::prost::alloc::string::String,
-    #[prost(string, tag = "2")]
-    pub player_id: ::prost::alloc::string::String,
 }
 #[allow(clippy::derive_partial_eq_without_eq)]
 #[derive(Clone, PartialEq, ::prost::Message)]
 pub struct GetSessionStateResponse {
-    #[prost(oneof = "get_session_state_response::Result", tags = "1, 2")]
-    pub result: ::core::option::Option<get_session_state_response::Result>,
-}
-/// Nested message and enum types in `GetSessionStateResponse`.
-pub mod get_session_state_response {
-    #[allow(clippy::derive_partial_eq_without_eq)]
-    #[derive(Clone, PartialEq, ::prost::Oneof)]
-    pub enum Result {
-        #[prost(message, tag = "1")]
-        GameState(super::GameState),
-        #[prost(message, tag = "2")]
-        Error(super::Error),
-    }
+    #[prost(message, optional, tag = "1")]
+    pub game_state: ::core::option::Option<GameState>,
+    #[prost(message, optional, tag = "2")]
+    pub error: ::core::option::Option<Error>,
 }
 /// Generated client implementations.
 pub mod session_service_client {
@@ -283,7 +271,6 @@ pub mod session_service_client {
             self.inner = self.inner.max_encoding_message_size(limit);
             self
         }
-        /// Créer une nouvelle session
         pub async fn create_session(
             &mut self,
             request: impl tonic::IntoRequest<super::CreateSessionRequest>,
@@ -311,7 +298,6 @@ pub mod session_service_client {
                 );
             self.inner.unary(req, path, codec).await
         }
-        /// Rejoindre une session existante
         pub async fn join_session(
             &mut self,
             request: impl tonic::IntoRequest<super::JoinSessionRequest>,
@@ -339,7 +325,6 @@ pub mod session_service_client {
                 );
             self.inner.unary(req, path, codec).await
         }
-        /// Marquer comme prêt
         pub async fn set_ready(
             &mut self,
             request: impl tonic::IntoRequest<super::SetReadyRequest>,
@@ -365,7 +350,6 @@ pub mod session_service_client {
                 .insert(GrpcMethod::new("takeiteasygame.v1.SessionService", "SetReady"));
             self.inner.unary(req, path, codec).await
         }
-        /// Obtenir l'état d'une session
         pub async fn get_session_state(
             &mut self,
             request: impl tonic::IntoRequest<super::GetSessionStateRequest>,
@@ -405,7 +389,6 @@ pub mod session_service_server {
     /// Generated trait containing gRPC methods that should be implemented for use with SessionServiceServer.
     #[async_trait]
     pub trait SessionService: Send + Sync + 'static {
-        /// Créer une nouvelle session
         async fn create_session(
             &self,
             request: tonic::Request<super::CreateSessionRequest>,
@@ -413,7 +396,6 @@ pub mod session_service_server {
             tonic::Response<super::CreateSessionResponse>,
             tonic::Status,
         >;
-        /// Rejoindre une session existante
         async fn join_session(
             &self,
             request: tonic::Request<super::JoinSessionRequest>,
@@ -421,7 +403,6 @@ pub mod session_service_server {
             tonic::Response<super::JoinSessionResponse>,
             tonic::Status,
         >;
-        /// Marquer comme prêt
         async fn set_ready(
             &self,
             request: tonic::Request<super::SetReadyRequest>,
@@ -429,7 +410,6 @@ pub mod session_service_server {
             tonic::Response<super::SetReadyResponse>,
             tonic::Status,
         >;
-        /// Obtenir l'état d'une session
         async fn get_session_state(
             &self,
             request: tonic::Request<super::GetSessionStateRequest>,
@@ -803,6 +783,71 @@ pub struct GetAvailableMovesResponse {
     #[prost(message, optional, tag = "2")]
     pub error: ::core::option::Option<Error>,
 }
+/// Démarrer un nouveau tour
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct StartTurnRequest {
+    #[prost(string, tag = "1")]
+    pub session_id: ::prost::alloc::string::String,
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct StartTurnResponse {
+    #[prost(bool, tag = "1")]
+    pub success: bool,
+    /// "5-3-7"
+    #[prost(string, tag = "2")]
+    pub announced_tile: ::prost::alloc::string::String,
+    /// "537.png"
+    #[prost(string, tag = "3")]
+    pub tile_image: ::prost::alloc::string::String,
+    #[prost(int32, tag = "4")]
+    pub turn_number: i32,
+    #[prost(string, repeated, tag = "5")]
+    pub waiting_for_players: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
+    /// JSON complet de l'état
+    #[prost(string, tag = "6")]
+    pub game_state: ::prost::alloc::string::String,
+    #[prost(message, optional, tag = "7")]
+    pub error: ::core::option::Option<Error>,
+}
+/// Obtenir l'état complet du jeu
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct GetGameStateRequest {
+    #[prost(string, tag = "1")]
+    pub session_id: ::prost::alloc::string::String,
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct GetGameStateResponse {
+    #[prost(bool, tag = "1")]
+    pub success: bool,
+    /// JSON complet de l'état
+    #[prost(string, tag = "2")]
+    pub game_state: ::prost::alloc::string::String,
+    /// "5-3-7" ou vide
+    #[prost(string, tag = "3")]
+    pub current_tile: ::prost::alloc::string::String,
+    /// ✅ NOUVEAU: "../image/537.png"
+    #[prost(string, tag = "4")]
+    pub current_tile_image: ::prost::alloc::string::String,
+    /// Numéro du tour (0-18) - RENUMÉROTÉ
+    #[prost(int32, tag = "5")]
+    pub current_turn: i32,
+    /// RENUMÉROTÉ
+    #[prost(string, repeated, tag = "6")]
+    pub waiting_for_players: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
+    /// RENUMÉROTÉ
+    #[prost(bool, tag = "7")]
+    pub is_game_finished: bool,
+    /// JSON des scores finaux - RENUMÉROTÉ
+    #[prost(string, tag = "8")]
+    pub final_scores: ::prost::alloc::string::String,
+    /// RENUMÉROTÉ
+    #[prost(message, optional, tag = "9")]
+    pub error: ::core::option::Option<Error>,
+}
 /// Generated client implementations.
 pub mod game_service_client {
     #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
@@ -942,6 +987,59 @@ pub mod game_service_client {
                 );
             self.inner.unary(req, path, codec).await
         }
+        /// 🎲 NOUVELLES MÉTHODES GAMEPLAY
+        pub async fn start_turn(
+            &mut self,
+            request: impl tonic::IntoRequest<super::StartTurnRequest>,
+        ) -> std::result::Result<
+            tonic::Response<super::StartTurnResponse>,
+            tonic::Status,
+        > {
+            self.inner
+                .ready()
+                .await
+                .map_err(|e| {
+                    tonic::Status::new(
+                        tonic::Code::Unknown,
+                        format!("Service was not ready: {}", e.into()),
+                    )
+                })?;
+            let codec = tonic::codec::ProstCodec::default();
+            let path = http::uri::PathAndQuery::from_static(
+                "/takeiteasygame.v1.GameService/StartTurn",
+            );
+            let mut req = request.into_request();
+            req.extensions_mut()
+                .insert(GrpcMethod::new("takeiteasygame.v1.GameService", "StartTurn"));
+            self.inner.unary(req, path, codec).await
+        }
+        pub async fn get_game_state(
+            &mut self,
+            request: impl tonic::IntoRequest<super::GetGameStateRequest>,
+        ) -> std::result::Result<
+            tonic::Response<super::GetGameStateResponse>,
+            tonic::Status,
+        > {
+            self.inner
+                .ready()
+                .await
+                .map_err(|e| {
+                    tonic::Status::new(
+                        tonic::Code::Unknown,
+                        format!("Service was not ready: {}", e.into()),
+                    )
+                })?;
+            let codec = tonic::codec::ProstCodec::default();
+            let path = http::uri::PathAndQuery::from_static(
+                "/takeiteasygame.v1.GameService/GetGameState",
+            );
+            let mut req = request.into_request();
+            req.extensions_mut()
+                .insert(
+                    GrpcMethod::new("takeiteasygame.v1.GameService", "GetGameState"),
+                );
+            self.inner.unary(req, path, codec).await
+        }
     }
 }
 /// Generated server implementations.
@@ -967,6 +1065,21 @@ pub mod game_service_server {
             tonic::Response<super::GetAvailableMovesResponse>,
             tonic::Status,
         >;
+        /// 🎲 NOUVELLES MÉTHODES GAMEPLAY
+        async fn start_turn(
+            &self,
+            request: tonic::Request<super::StartTurnRequest>,
+        ) -> std::result::Result<
+            tonic::Response<super::StartTurnResponse>,
+            tonic::Status,
+        >;
+        async fn get_game_state(
+            &self,
+            request: tonic::Request<super::GetGameStateRequest>,
+        ) -> std::result::Result<
+            tonic::Response<super::GetGameStateResponse>,
+            tonic::Status,
+        >;
     }
     #[derive(Debug)]
     pub struct GameServiceServer<T: GameService> {
@@ -1140,6 +1253,98 @@ pub mod game_service_server {
                     };
                     Box::pin(fut)
                 }
+                "/takeiteasygame.v1.GameService/StartTurn" => {
+                    #[allow(non_camel_case_types)]
+                    struct StartTurnSvc<T: GameService>(pub Arc<T>);
+                    impl<
+                        T: GameService,
+                    > tonic::server::UnaryService<super::StartTurnRequest>
+                    for StartTurnSvc<T> {
+                        type Response = super::StartTurnResponse;
+                        type Future = BoxFuture<
+                            tonic::Response<Self::Response>,
+                            tonic::Status,
+                        >;
+                        fn call(
+                            &mut self,
+                            request: tonic::Request<super::StartTurnRequest>,
+                        ) -> Self::Future {
+                            let inner = Arc::clone(&self.0);
+                            let fut = async move {
+                                <T as GameService>::start_turn(&inner, request).await
+                            };
+                            Box::pin(fut)
+                        }
+                    }
+                    let accept_compression_encodings = self.accept_compression_encodings;
+                    let send_compression_encodings = self.send_compression_encodings;
+                    let max_decoding_message_size = self.max_decoding_message_size;
+                    let max_encoding_message_size = self.max_encoding_message_size;
+                    let inner = self.inner.clone();
+                    let fut = async move {
+                        let inner = inner.0;
+                        let method = StartTurnSvc(inner);
+                        let codec = tonic::codec::ProstCodec::default();
+                        let mut grpc = tonic::server::Grpc::new(codec)
+                            .apply_compression_config(
+                                accept_compression_encodings,
+                                send_compression_encodings,
+                            )
+                            .apply_max_message_size_config(
+                                max_decoding_message_size,
+                                max_encoding_message_size,
+                            );
+                        let res = grpc.unary(method, req).await;
+                        Ok(res)
+                    };
+                    Box::pin(fut)
+                }
+                "/takeiteasygame.v1.GameService/GetGameState" => {
+                    #[allow(non_camel_case_types)]
+                    struct GetGameStateSvc<T: GameService>(pub Arc<T>);
+                    impl<
+                        T: GameService,
+                    > tonic::server::UnaryService<super::GetGameStateRequest>
+                    for GetGameStateSvc<T> {
+                        type Response = super::GetGameStateResponse;
+                        type Future = BoxFuture<
+                            tonic::Response<Self::Response>,
+                            tonic::Status,
+                        >;
+                        fn call(
+                            &mut self,
+                            request: tonic::Request<super::GetGameStateRequest>,
+                        ) -> Self::Future {
+                            let inner = Arc::clone(&self.0);
+                            let fut = async move {
+                                <T as GameService>::get_game_state(&inner, request).await
+                            };
+                            Box::pin(fut)
+                        }
+                    }
+                    let accept_compression_encodings = self.accept_compression_encodings;
+                    let send_compression_encodings = self.send_compression_encodings;
+                    let max_decoding_message_size = self.max_decoding_message_size;
+                    let max_encoding_message_size = self.max_encoding_message_size;
+                    let inner = self.inner.clone();
+                    let fut = async move {
+                        let inner = inner.0;
+                        let method = GetGameStateSvc(inner);
+                        let codec = tonic::codec::ProstCodec::default();
+                        let mut grpc = tonic::server::Grpc::new(codec)
+                            .apply_compression_config(
+                                accept_compression_encodings,
+                                send_compression_encodings,
+                            )
+                            .apply_max_message_size_config(
+                                max_decoding_message_size,
+                                max_encoding_message_size,
+                            );
+                        let res = grpc.unary(method, req).await;
+                        Ok(res)
+                    };
+                    Box::pin(fut)
+                }
                 _ => {
                     Box::pin(async move {
                         Ok(
diff --git a/src/main.rs b/src/main.rs
index 7176e02..0766653 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,19 +1,48 @@
+// main.rs - Version corrigée avec les bonnes compatibilités
 use clap::Parser;
 use futures_util::StreamExt;
+use std::net::SocketAddr;
 use std::path::Path;
+use std::sync::{Arc, Mutex};
 use tch::nn::{self, OptimizerConfig};
 use tch::Device;
+use tokio::fs;
 use tokio::net::TcpListener;
 use tokio_tungstenite::accept_async;
+use tonic::transport::Server;
+use tonic_web::GrpcWebLayer;
+use http::{header, Method, StatusCode};
+use tonic::body::BoxBody;
+use tonic::transport::Body;
+use tower::{Layer, Service};
+use std::task::{Context, Poll};
+use std::pin::Pin;
+use std::future::Future;
+
+// Imports Axum pour le serveur web
+use axum::{
+    response::Html,
+    routing::get,
+    Router,
+};
+use tower_http::cors::{Any, CorsLayer};
+use tower_http::services::ServeDir;
 
 use crate::logging::setup_logging;
 use crate::mcts_vs_human::play_mcts_vs_human;
 use neural::policy_value_net::{PolicyNet, ValueNet};
 use crate::training::session::train_and_evaluate;
 
+// Services gRPC
+use crate::services::session_service::SessionServiceImpl;
+use crate::services::game_service::GameServiceImpl;
+use crate::generated::takeiteasygame::v1::session_service_server::SessionServiceServer;
+use crate::generated::takeiteasygame::v1::game_service_server::GameServiceServer;
+
 #[cfg(test)]
 mod test;
 
+// Modules existants (inchangés)
 mod game;
 mod logging;
 mod mcts;
@@ -25,6 +54,10 @@ mod scoring;
 mod data;
 mod training;
 
+// Nouveaux modules avec paradigme fonctionnel
+mod generated;
+mod services;
+
 #[derive(Parser, Debug)]
 #[command(name = "take_it_easy")]
 struct Config {
@@ -39,6 +72,10 @@ struct Config {
     /// Mode de jeu
     #[arg(long, value_enum, default_value = "mcts-vs-human")]
     mode: GameMode,
+
+    /// Port pour le serveur gRPC Multiplayer
+    #[arg(short = 'p', long, default_value_t = 50051)]
+    port: u16,
 }
 
 #[derive(clap::ValueEnum, Clone, Debug)]
@@ -51,14 +88,155 @@ enum GameMode {
     Multiplayer,
 }
 
+// ============================================================================
+// SERVEUR WEB POUR LES FICHIERS STATIQUES
+// ============================================================================
+
+async fn start_web_server(port: u16) -> Result<(), Box<dyn std::error::Error>> {
+    let app = Router::new()
+        .route("/", get(|| async {
+            Html(fs::read_to_string("web/index.html").await.unwrap_or_else(|_|
+                r#"<!DOCTYPE html>
+<html><head><title>Take It Easy</title></head>
+<body>
+<h1>🎮 Take It Easy - Multiplayer</h1>
+<p>Place your frontend files in ./web/ directory</p>
+<p>gRPC server is running on port 50051</p>
+</body></html>"#.to_string()
+            ))
+        }))
+        .nest_service("/static", ServeDir::new("web"))
+        .fallback_service(ServeDir::new("web"))
+        .layer(
+            CorsLayer::new()
+                .allow_origin(Any)
+                .allow_methods(Any)
+                .allow_headers(Any)
+        );
+
+    let addr: SocketAddr = format!("0.0.0.0:{}", port + 1000).parse()?;
+    let listener = tokio::net::TcpListener::bind(addr).await?;
+    axum::serve(listener, app).await?;
+    Ok(())
+}
+#[derive(Clone)]
+pub struct SimpleCors<S> {
+    inner: S,
+}
+
+impl<S> SimpleCors<S> {
+    pub fn new(inner: S) -> Self {
+        Self { inner }
+    }
+}
+
+impl<S> Service<http::Request<Body>> for SimpleCors<S>
+where
+    S: Service<http::Request<Body>, Response = http::Response<BoxBody>> + Clone + Send + 'static,
+    S::Future: Send + 'static,
+{
+    type Response = S::Response;
+    type Error = S::Error;
+    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;
+
+    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
+        self.inner.poll_ready(cx)
+    }
+
+    fn call(&mut self, req: http::Request<Body>) -> Self::Future {
+        let mut inner = self.inner.clone();
+
+        Box::pin(async move {
+            // Handle preflight OPTIONS requests
+            if req.method() == Method::OPTIONS {
+                let response = http::Response::builder()
+                    .status(StatusCode::OK)
+                    .header(header::ACCESS_CONTROL_ALLOW_ORIGIN, "*")
+                    .header(header::ACCESS_CONTROL_ALLOW_METHODS, "GET, POST, OPTIONS")
+                    .header(header::ACCESS_CONTROL_ALLOW_HEADERS, "content-type, x-grpc-web, x-user-agent, grpc-timeout, grpc-accept-encoding")
+                    .header(header::ACCESS_CONTROL_MAX_AGE, "86400")
+                    .body(BoxBody::default())
+                    .unwrap();
+
+                return Ok(response);
+            }
+
+            // Process normal request and add CORS headers to response
+            let mut response = inner.call(req).await?;
+
+            let headers = response.headers_mut();
+            headers.insert(header::ACCESS_CONTROL_ALLOW_ORIGIN, header::HeaderValue::from_static("*"));
+            headers.insert(header::ACCESS_CONTROL_ALLOW_METHODS, header::HeaderValue::from_static("GET, POST, OPTIONS"));
+            headers.insert(header::ACCESS_CONTROL_ALLOW_HEADERS, header::HeaderValue::from_static("content-type, x-grpc-web, x-user-agent, grpc-timeout, grpc-accept-encoding"));
+            headers.insert(header::ACCESS_CONTROL_EXPOSE_HEADERS, header::HeaderValue::from_static("grpc-status, grpc-message"));
+
+            Ok(response)
+        })
+    }
+}
+
+// Layer pour le middleware
+#[derive(Clone)]
+pub struct SimpleCorsLayer;
+
+impl<S> Layer<S> for SimpleCorsLayer {
+    type Service = SimpleCors<S>;
+
+    fn layer(&self, inner: S) -> Self::Service {
+        SimpleCors::new(inner)
+    }
+}
+// ============================================================================
+// SERVEUR GRPC AVEC GRPC-WEB
+// ============================================================================
+
+async fn start_multiplayer_server(
+    policy_net: PolicyNet,
+    value_net: ValueNet,
+    num_simulations: usize,
+    port: u16,
+) -> Result<(), Box<dyn std::error::Error>> {
+    let addr: SocketAddr = format!("0.0.0.0:{}", port).parse()?;
+
+    // Créer le session manager partagé
+    let session_manager = Arc::new(crate::services::session_manager::new_session_manager());
+
+    // Wrapper les réseaux de neurones pour le partage
+    let policy_net_arc = Arc::new(Mutex::new(policy_net));
+    let value_net_arc = Arc::new(Mutex::new(value_net));
+
+    // Créer les services gRPC (avec les nouvelles méthodes gameplay)
+    let session_service = SessionServiceImpl::new_with_manager(session_manager.clone()); // ← Modifié
+    let game_service = GameServiceImpl::new(
+        session_manager.clone(),
+        policy_net_arc.clone(),
+        value_net_arc.clone(),
+        num_simulations
+    );
+
+    // Serveur gRPC UNIQUEMENT - plus de REST
+    Server::builder()
+        .accept_http1(true)
+        .layer(SimpleCorsLayer)
+        .layer(GrpcWebLayer::new())
+        .add_service(SessionServiceServer::new(session_service))
+        .add_service(GameServiceServer::new(game_service)) // ← Maintenant avec StartTurn et GetGameState
+        .serve(addr)
+        .await?;
+
+    Ok(())
+}
+
+// ============================================================================
+// FONCTION PRINCIPALE
+// ============================================================================
 
 #[tokio::main]
-async fn main() {
+async fn main() -> Result<(), Box<dyn std::error::Error>> {
     let config = Config::parse();
     let model_path = "model_weights";
     setup_logging();
-
-    // Initialize VarStore
+    // Initialize VarStore (votre système existant)
     let mut vs_policy = nn::VarStore::new(Device::Cpu);
     let mut vs_value = nn::VarStore::new(Device::Cpu);
     let input_dim = (5, 47, 1);
@@ -67,39 +245,27 @@ async fn main() {
 
     // Load weights if the model directory exists
     if Path::new(model_path).exists() {
-        log::info!("🔄 Loading model weights from {}", model_path);
-
         if let Err(e) = policy_net.load_model(&mut vs_policy, "model_weights/policy/policy.params")
         {
-            log::error!("⚠️ Error loading PolicyNet: {:?}", e);
-            log::info!("➡️  Initializing PolicyNet with random weights.");
-        }
+            log::error!("⚠️ Error loading PolicyNet: {:?}", e);        }
 
         if let Err(e) = value_net.load_model(&mut vs_value, "model_weights/value/value.params") {
-            log::error!("⚠️ Error loading ValueNet: {:?}", e);
-            log::info!("➡️  Initializing ValueNet with random weights.");
-        }
-    } else {
-        log::info!("📭 No pre-trained model found. Initializing new models.");
-    }
+            log::error!("⚠️ Error loading ValueNet: {:?}", e);        }
+    } else {    }
+
     let mut optimizer_policy = nn::Adam::default().build(&vs_policy, 1e-3).unwrap();
-    // Change your optimizer (around line 100):
     let mut optimizer_value = nn::Adam {
-        wd: 1e-6, // Was 1e-5
+        wd: 1e-6,
         ..Default::default()
     }
-    .build(&vs_value, 2e-4)
-    .unwrap(); // Was 1e-3
+        .build(&vs_value, 2e-4)
+        .unwrap();
 
-    // ➕ Duel Mode: MCTS vs Human
+    // Match sur les modes
     match config.mode {
-        GameMode::Training => {
-            log::info!("🧠 Starting training mode...");
-            let listener = TcpListener::bind("127.0.0.1:9000")
+        GameMode::Training => {            let listener = TcpListener::bind("127.0.0.1:9000")
                 .await
                 .expect("Unable to bind WebSocket on port 9000 for training");
-            log::info!("🧠 Training WebSocket server started at ws://127.0.0.1:9000");
-
             train_and_evaluate(
                 &vs_policy,
                 &vs_value,
@@ -115,9 +281,7 @@ async fn main() {
                 .await;
         }
 
-        GameMode::MctsVsHuman => {
-            log::info!("🧍‍♂️🤖 Starting MCTS vs Human mode...");
-            let listener = TcpListener::bind("127.0.0.1:9001")
+        GameMode::MctsVsHuman => {            let listener = TcpListener::bind("127.0.0.1:9001")
                 .await
                 .expect("Unable to bind WebSocket on port 9001 for MCTS vs Human");
 
@@ -137,27 +301,25 @@ async fn main() {
         }
 
         GameMode::Multiplayer => {
-            log::info!("🎮👥 Starting Multiplayer mode (MCTS vs Multiple Humans)...");
-            log::info!("🔗 Players can connect and create/join sessions");
-            log::info!("📋 Session codes will be generated for easy joining");
-
-            // start_multiplayer_server(
-            //     policy_net,
-            //     value_net,
-            //     config.num_simulations,
-            // )
-            //     .await;
-        }
-    }
-}
-
-
-
-
-
-
-
-
-
+            // Lancer le serveur web en arrière-plan
+            let web_port = config.port;
+            tokio::spawn(async move {
+                if let Err(e) = start_web_server(web_port).await {
+                    log::error!("❌ Web server error: {}", e);
+                }
+            });
 
+            // Donner un peu de temps au serveur web pour démarrer
+            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
 
+            // Lancer le serveur gRPC (bloquant)
+            start_multiplayer_server(
+                policy_net,
+                value_net,
+                config.num_simulations,
+                config.port,
+            )
+                .await?;
+        }
+    }    Ok(())
+}
\ No newline at end of file
diff --git a/src/mcts/algorithm.rs b/src/mcts/algorithm.rs
index 144d95c..6c2eb72 100644
--- a/src/mcts/algorithm.rs
+++ b/src/mcts/algorithm.rs
@@ -244,9 +244,6 @@ pub fn mcts_find_best_position_for_tile_with_nn(
     }
 
     let final_score = result(&final_plateau); // Get actual game score
-
-    log::info!("🤖 Pos:{} Score:{}", best_position, final_score as i32);
-
     MCTSResult {
         best_position,
         board_tensor,
diff --git a/src/neural/policy_value_net.rs b/src/neural/policy_value_net.rs
index 2d9ee6a..0e34f93 100644
--- a/src/neural/policy_value_net.rs
+++ b/src/neural/policy_value_net.rs
@@ -125,10 +125,7 @@ pub fn initialize_weights(vs: &nn::VarStore) {
         // Validation after initialization
         if param.isnan().any().double_value(&[]) > 0.0 {
             log::error!("🚨 NaN detected in {} after initialization!", name);
-        }
-
-        log::debug!("🔧 Initialized {} with shape {:?}", name, size);
-    }
+        }    }
 }
 
 
diff --git a/src/neural/training/gradient_clipping.rs b/src/neural/training/gradient_clipping.rs
index 2ff6d58..08026fa 100644
--- a/src/neural/training/gradient_clipping.rs
+++ b/src/neural/training/gradient_clipping.rs
@@ -65,12 +65,8 @@ fn clip_policy_network_gradients(vs_policy: &nn::VarStore) -> f64 {
 
 /// Log les normes de gradients si elles sont élevées
 fn log_gradient_norms(max_grad_value: f64, max_grad_policy: f64) {
-    if max_grad_value > 1.0 {
-        log::warn!("🔥 Value grad norm: {:.3}", max_grad_value);
-    }
-    if max_grad_policy > 2.0 {
-        log::warn!("🔥 Policy grad norm: {:.3}", max_grad_policy);
-    }
+    if max_grad_value > 1.0 {    }
+    if max_grad_policy > 2.0 {    }
 }
 
 /// Version simple du clipping des gradients
diff --git a/src/neural/training/trainer.rs b/src/neural/training/trainer.rs
index 9b30739..6163941 100644
--- a/src/neural/training/trainer.rs
+++ b/src/neural/training/trainer.rs
@@ -103,11 +103,6 @@ pub fn train_network_with_game_data(
         + (entropy_weight * total_entropy_loss.shallow_clone());
 
     // Log the loss before backpropagation
-    log::info!(
-        "💡 Total Loss before backward: {:.4}",
-        total_loss.double_value(&[])
-    );
-
     // ✅ Enhanced NaN and Inf check before backpropagation
     if total_loss.isnan().any().double_value(&[]) > 0.0 {
         log::error!("⚠️ NaN detected in total loss! Skipping backpropagation.");
@@ -135,12 +130,4 @@ pub fn train_network_with_game_data(
     optimizer_policy.step();
     optimizer_policy.zero_grad();
     optimizer_value.step();
-    optimizer_value.zero_grad();
-
-    log::info!(
-        "🎯 Update Complete | Policy Loss: {:.4}, Value Loss: {:.4}, Entropy Loss: {:.4}",
-        total_policy_loss.double_value(&[]),
-        total_value_loss.double_value(&[]),
-        total_entropy_loss.double_value(&[])
-    );
-}
\ No newline at end of file
+    optimizer_value.zero_grad();}
\ No newline at end of file
diff --git a/src/services/game_manager.rs b/src/services/game_manager.rs
index e69de29..0e0f8e1 100644
--- a/src/services/game_manager.rs
+++ b/src/services/game_manager.rs
@@ -0,0 +1,443 @@
+// src/services/game_manager.rs - Intégration avec votre système existant
+
+use std::collections::HashMap;
+use std::sync::Mutex;
+use serde::{Serialize, Deserialize};
+use crate::generated::takeiteasygame::v1::*;
+
+// Import de vos modules existants
+use crate::game::create_deck::{create_deck, Deck};
+use crate::game::plateau::{create_plateau_empty, Plateau};
+use crate::game::tile::Tile;
+use crate::game::plateau_is_full::is_plateau_full;
+use crate::game::remove_tile_from_deck::replace_tile_in_deck;
+use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
+use crate::scoring::scoring::result;
+use rand::Rng;
+use crate::game::get_legal_moves::get_legal_moves;
+// ============================================================================
+// ADAPTATION DE VOS TYPES EXISTANTS VERS LE SYSTÈME FONCTIONNEL
+// ============================================================================
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct TakeItEasyGameState {
+    pub session_id: String,
+    pub deck: Deck,
+    pub player_plateaus: HashMap<String, Plateau>, // player_id -> plateau
+    pub current_tile: Option<Tile>,
+    pub current_turn: usize,
+    pub total_turns: usize,
+    pub game_status: GameStatus,
+    pub scores: HashMap<String, i32>,
+    pub waiting_for_players: Vec<String>, // Qui doit encore jouer ce tour
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct PlayerMove {
+    pub player_id: String,
+    pub position: usize, // Position sur le plateau (0-46)
+    pub tile: Tile,
+    pub timestamp: i64,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct MctsMove {
+    pub position: usize,
+    pub tile: Tile,
+    pub evaluation_score: f32,
+    pub search_depth: usize,
+    pub variations_considered: usize,
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct MoveResult {
+    pub new_game_state: TakeItEasyGameState,
+    pub points_earned: i32,
+    pub mcts_response: Option<MctsMove>,
+    pub is_game_over: bool,
+    pub turn_completed: bool, // Si tous les joueurs ont joué ce tour
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub enum GameStatus {
+    WaitingForPlayers,
+    InProgress,
+    Finished,
+}
+
+// ============================================================================
+// FONCTIONS PURES - ADAPTATION DE VOTRE LOGIQUE EXISTANTE
+// ============================================================================
+
+pub fn create_take_it_easy_game(
+    session_id: String,
+    player_ids: Vec<String>
+) -> TakeItEasyGameState {
+    let deck = create_deck();
+    let mut player_plateaus = HashMap::new();
+
+    // Créer un plateau vide pour chaque joueur (y compris MCTS)
+    for player_id in &player_ids {
+        player_plateaus.insert(player_id.clone(), create_plateau_empty());
+    }
+
+    // Ajouter MCTS comme joueur automatique si pas déjà présent
+    if !player_ids.contains(&"mcts_ai".to_string()) {
+        player_plateaus.insert("mcts_ai".to_string(), create_plateau_empty());
+    }
+
+    TakeItEasyGameState {
+        session_id,
+        deck,
+        player_plateaus,
+        current_tile: None,
+        current_turn: 0,
+        total_turns: 19, // Comme dans votre implémentation
+        game_status: GameStatus::InProgress,
+        scores: player_ids.iter().map(|id| (id.clone(), 0)).collect(),
+        waiting_for_players: vec![],
+    }
+}
+
+// game_manager.rs - dans start_new_turn
+// Dans game_manager.rs - CORRIGER start_new_turn
+pub fn start_new_turn(
+    mut game_state: TakeItEasyGameState
+) -> Result<TakeItEasyGameState, String> {
+    if game_state.current_turn >= game_state.total_turns {
+        return Err("GAME_ALREADY_FINISHED".to_string());
+    }
+
+    // 🔧 UTILISER VOS FONCTIONS : Filtrer les tuiles valides comme dans simulate_game
+    let valid_tiles: Vec<Tile> = game_state.deck
+        .tiles
+        .iter()
+        .cloned()
+        .filter(|tile| *tile != Tile(0, 0, 0))  // ✅ Même logique que simulate_game.rs
+        .collect();
+
+    if valid_tiles.is_empty() {
+        return Err("NO_TILES_REMAINING".to_string());
+    }
+
+    // 🎲 Piocher une tuile aléatoire SEULEMENT parmi les tuiles valides
+    let tile_index = rand::rng().random_range(0..valid_tiles.len());
+    let chosen_tile = valid_tiles[tile_index];
+
+
+    // 🔧 UTILISER VOTRE FONCTION : Remplacer la tuile dans le deck
+    game_state.deck = replace_tile_in_deck(&game_state.deck, &chosen_tile);
+    game_state.current_tile = Some(chosen_tile);
+
+    // 🔧 TOUS LES JOUEURS (humains + MCTS) doivent jouer
+    game_state.waiting_for_players = game_state.player_plateaus.keys().cloned().collect();
+
+
+
+    Ok(game_state)
+}
+// Dans game_manager.rs - NOUVELLE fonction utilisant vos concepts
+pub fn get_available_tiles_from_deck(deck: &Deck) -> Vec<Tile> {
+    // 🔧 UTILISE LA MÊME LOGIQUE que simulate_game.rs
+    deck.tiles
+        .iter()
+        .cloned()
+        .filter(|tile| *tile != Tile(0, 0, 0))
+        .collect()
+}
+
+pub fn count_remaining_tiles(deck: &Deck) -> usize {
+    // 🔧 UTILISE VOS FONCTIONS pour compter les tuiles restantes
+    get_available_tiles_from_deck(deck).len()
+}
+
+pub fn is_deck_empty(deck: &Deck) -> bool {
+    // 🔧 UTILISE VOS FONCTIONS pour vérifier si le deck est vide
+    get_available_tiles_from_deck(deck).is_empty()
+}
+
+
+// Dans game_manager.rs - AMÉLIORER ensure_current_tile
+pub fn ensure_current_tile(mut game_state: TakeItEasyGameState) -> Result<TakeItEasyGameState, String> {
+    if game_state.current_tile.is_some() {
+        // ✅ Une tuile existe déjà, pas besoin de modification
+        return Ok(game_state);
+    }
+
+    // 🎲 Aucune tuile courante, en tirer une NOUVELLE
+    game_state = start_new_turn(game_state)?;
+
+    Ok(game_state)
+}
+// game_manager.rs - dans apply_player_move
+// Dans game_manager.rs - AMÉLIORER apply_player_move
+pub fn apply_player_move(
+    mut game_state: TakeItEasyGameState,
+    player_move: PlayerMove
+) -> Result<TakeItEasyGameState, String> {
+
+    // Vérifications utilisant vos fonctions
+    if game_state.current_tile.is_none() {
+        return Err("NO_CURRENT_TILE".to_string());
+    }
+
+    let current_tile = game_state.current_tile.unwrap();
+
+    if player_move.tile != current_tile {
+        return Err("WRONG_TILE".to_string());
+    }
+
+    // 🔧 UTILISER VOS FONCTIONS : Vérifier les mouvements légaux
+    let player_plateau = game_state.player_plateaus.get(&player_move.player_id)
+        .ok_or_else(|| {
+            "PLAYER_NOT_FOUND".to_string()
+        })?;
+
+    let legal_moves = get_legal_moves(player_plateau.clone());
+    if !legal_moves.contains(&player_move.position) {
+        return Err("ILLEGAL_MOVE".to_string());
+    }
+
+    // Récupérer le plateau du joueur pour modification
+    let player_plateau = game_state.player_plateaus.get_mut(&player_move.player_id)
+        .ok_or_else(|| "PLAYER_NOT_FOUND".to_string())?;
+
+    // Placer la tuile
+    player_plateau.tiles[player_move.position] = player_move.tile;
+
+    // Retirer le joueur de la liste d'attente
+    game_state.waiting_for_players.retain(|id| id != &player_move.player_id);
+
+
+    Ok(game_state)
+}
+
+// Dans game_manager.rs - AMÉLIORER process_mcts_turn avec vos fonctions
+pub fn process_mcts_turn(
+    mut game_state: TakeItEasyGameState,
+    policy_net: &Mutex<PolicyNet>,
+    value_net: &Mutex<ValueNet>,
+    num_simulations: usize
+) -> Result<(TakeItEasyGameState, MctsMove), String> {
+    let current_tile = game_state.current_tile.ok_or("NO_CURRENT_TILE")?;
+
+    // ✅ VÉRIFICATION: MCTS ne peut jouer que s'il est en attente
+    if !game_state.waiting_for_players.contains(&"mcts_ai".to_string()) {
+        return Err("MCTS_NOT_WAITING".to_string());
+    }
+
+    // Récupérer le plateau MCTS
+    let mcts_plateau = game_state.player_plateaus.get_mut("mcts_ai")
+        .ok_or("MCTS_PLAYER_NOT_FOUND")?;
+
+    // ✅ VÉRIFICATION: Mouvements légaux
+    let legal_moves = get_legal_moves(mcts_plateau.clone());
+    if legal_moves.is_empty() {
+        return Err("NO_LEGAL_MOVES_FOR_MCTS".to_string());
+    }
+    let mut deck_clone = game_state.deck.clone();
+
+    // Utiliser MCTS pour choisir la position
+    let policy_locked = policy_net.lock().map_err(|_| "Failed to lock policy net")?;
+    let value_locked = value_net.lock().map_err(|_| "Failed to lock value net")?;
+
+    let mcts_result = mcts_find_best_position_for_tile_with_nn(
+        mcts_plateau,
+        &mut deck_clone,
+        current_tile,
+        &*policy_locked,
+        &*value_locked,
+        num_simulations,
+        game_state.current_turn,
+        game_state.total_turns,
+    );
+
+    // ✅ VALIDATION: Position légale
+    if !legal_moves.contains(&mcts_result.best_position) {
+        log::error!("❌ MCTS a choisi un mouvement illégal: {} (légaux: {:?})",
+            mcts_result.best_position, legal_moves);
+        return Err("MCTS_ILLEGAL_MOVE".to_string());
+    }
+
+    // ✅ PLACEMENT UNIQUE DE LA TUILE
+    mcts_plateau.tiles[mcts_result.best_position] = current_tile;
+
+    // ✅ RETIRER MCTS DE LA LISTE D'ATTENTE (important !)
+    game_state.waiting_for_players.retain(|id| id != "mcts_ai");
+
+    let mcts_move = MctsMove {
+        position: mcts_result.best_position,
+        tile: current_tile,
+        evaluation_score: mcts_result.subscore as f32,
+        search_depth: num_simulations,
+        variations_considered: num_simulations,
+    };
+    Ok((game_state, mcts_move))
+}
+
+// Dans game_manager.rs - NOUVELLE fonction de debug complète
+pub fn debug_game_state(game_state: &TakeItEasyGameState) {
+    // 🔧 UTILISER VOS FONCTIONS pour le debug
+    let remaining_tiles = count_remaining_tiles(&game_state.deck);
+    let available_tiles = get_available_tiles_from_deck(&game_state.deck);
+    // Debug plateaux
+    for (player_id, plateau) in &game_state.player_plateaus {
+        let legal_moves = get_legal_moves(plateau.clone());
+        let filled_positions = plateau.tiles.iter()
+            .enumerate()
+            .filter(|(_, tile)| **tile != Tile(0, 0, 0))
+            .count();    }}
+// game_manager.rs - check_turn_completion démarre automatiquement le tour suivant
+pub fn check_turn_completion(
+    mut game_state: TakeItEasyGameState
+) -> Result<TakeItEasyGameState, String> {
+    // Si tous les joueurs (humains + MCTS) ont joué
+    if game_state.waiting_for_players.is_empty() {
+        let completed_turn = game_state.current_turn;
+        game_state.current_turn += 1;
+        game_state.current_tile = None;
+        // Vérifier si le jeu est terminé
+        if game_state.current_turn >= game_state.total_turns {
+            game_state.game_status = GameStatus::Finished;
+            game_state.scores = calculate_final_scores(&game_state);        } else {
+            // 🎲 DÉMARRAGE AUTOMATIQUE DU TOUR SUIVANT 
+                      game_state = start_new_turn(game_state)?;        }
+    } else {    }
+
+    Ok(game_state)
+}
+
+pub fn calculate_final_scores(game_state: &TakeItEasyGameState) -> HashMap<String, i32> {
+    let mut scores = HashMap::new();
+
+    // Utiliser votre fonction de scoring existante
+    for (player_id, plateau) in &game_state.player_plateaus {
+        let score = result(plateau);
+        scores.insert(player_id.clone(), score);
+    }
+
+    scores
+}
+
+pub fn is_game_finished(game_state: &TakeItEasyGameState) -> bool {
+    matches!(game_state.game_status, GameStatus::Finished) ||
+        game_state.current_turn >= game_state.total_turns ||
+        game_state.player_plateaus.values().all(|plateau| is_plateau_full(plateau))
+}
+
+pub fn get_available_positions(game_state: &TakeItEasyGameState, player_id: &str) -> Vec<usize> {
+    if let Some(plateau) = game_state.player_plateaus.get(player_id) {
+        plateau.tiles.iter()
+            .enumerate()
+            .filter(|(_, tile)| **tile == Tile(0, 0, 0))
+            .map(|(index, _)| index)
+            .collect()
+    } else {
+        vec![]
+    }
+}
+
+// ============================================================================
+// FONCTIONS DE COMPOSITION - LOGIQUE MÉTIER COMPLÈTE
+// ============================================================================
+
+// game_manager.rs - votre fonction reste la même, mais on change la logique
+pub fn process_player_move_with_mcts(
+    game_state: TakeItEasyGameState,
+    player_move: PlayerMove,
+    policy_net: &Mutex<PolicyNet>,
+    value_net: &Mutex<ValueNet>,
+    num_simulations: usize
+) -> Result<MoveResult, String> {
+    // 1. Appliquer le mouvement du joueur
+    let mut new_state = apply_player_move(game_state, player_move.clone())?;
+
+    // 2. ✅ GESTION UNIQUE DE MCTS ICI
+    let mcts_response = if player_move.player_id != "mcts_ai"
+        && new_state.waiting_for_players.contains(&"mcts_ai".to_string()) {
+        // MCTS joue automatiquement UNE SEULE FOIS
+        match process_mcts_turn(new_state.clone(), policy_net, value_net, num_simulations) {
+            Ok((updated_state, mcts_move)) => {
+                new_state = updated_state;                Some(mcts_move)
+            },
+            Err(_e) => {
+                new_state.waiting_for_players.retain(|id| id != "mcts_ai");
+                None
+            }
+        }
+    } else {
+        None
+    };
+
+    // 3. Vérifier la fin du tour (démarre automatiquement le tour suivant)
+    new_state = check_turn_completion(new_state)?;
+
+    // 4. Calculer les points
+    let initial_score = new_state.scores.get(&player_move.player_id).unwrap_or(&0).clone();
+    let points_earned = if let Some(plateau) = new_state.player_plateaus.get(&player_move.player_id) {
+        result(plateau) - initial_score
+    } else {
+        0
+    };
+
+    Ok(MoveResult {
+        new_game_state: new_state.clone(),
+        points_earned,
+        mcts_response,
+        is_game_over: is_game_finished(&new_state),
+        turn_completed: new_state.waiting_for_players.is_empty(),
+    })
+}
+// ============================================================================
+// CONVERSION VERS PROTOBUF (COMPATIBLE AVEC VOS TYPES)
+// ============================================================================
+
+pub fn take_it_easy_state_to_protobuf(state: &TakeItEasyGameState) -> GameState {
+    let players: Vec<crate::generated::takeiteasygame::v1::Player> = state.scores.iter().map(|(player_id, score)| {
+        crate::generated::takeiteasygame::v1::Player {
+            id: player_id.clone(),
+            name: player_id.clone(),
+            score: *score,
+            is_ready: true,
+            is_connected: true,
+            joined_at: chrono::Utc::now().timestamp(),
+        }
+    }).collect();
+
+    GameState {
+        session_id: state.session_id.clone(),
+        players,
+        current_player_id: state.waiting_for_players.first().cloned().unwrap_or_default(),
+        state: match state.game_status {
+            GameStatus::WaitingForPlayers => 0,
+            GameStatus::InProgress => 1,
+            GameStatus::Finished => 2,
+        },
+        board_state: serde_json::to_string(state).unwrap_or_default(),
+        turn_number: state.current_turn as i32,
+    }
+}
+
+pub fn player_move_from_json(move_data: &str, player_id: &str) -> Result<PlayerMove, String> {
+    #[derive(Deserialize)]
+    struct MoveData {
+        position: usize,
+        tile: Option<(i32, i32, i32)>, // Optionnel car défini par le serveur
+    }
+
+    let data: MoveData = serde_json::from_str(move_data)
+        .map_err(|e| format!("Invalid move format: {}", e))?;
+
+    Ok(PlayerMove {
+        player_id: player_id.to_string(),
+        position: data.position,
+        tile: Tile(0, 0, 0), // Sera remplacé par la tuile courante
+        timestamp: chrono::Utc::now().timestamp(),
+    })
+}
+
+pub fn mcts_move_to_json(mcts_move: &MctsMove) -> Result<String, String> {
+    serde_json::to_string(mcts_move)
+        .map_err(|e| format!("Failed to serialize MCTS move: {}", e))
+}
\ No newline at end of file
diff --git a/src/services/game_service.rs b/src/services/game_service.rs
index e69de29..af0e0f5 100644
--- a/src/services/game_service.rs
+++ b/src/services/game_service.rs
@@ -0,0 +1,1104 @@
+// src/services/game_service.rs - GameService étendu avec gameplay MCTS - VERSION CORRIGÉE
+
+use tonic::{Request, Response, Status};
+use std::sync::{Arc, Mutex};
+use tokio::sync::RwLock;
+// Import des types générés par tonic
+use crate::generated::takeiteasygame::v1::*;
+use crate::generated::takeiteasygame::v1::game_service_server::GameService;
+use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
+use crate::services::game_manager::{TakeItEasyGameState, MoveResult, create_take_it_easy_game, start_new_turn, process_player_move_with_mcts, get_available_positions, take_it_easy_state_to_protobuf, player_move_from_json, mcts_move_to_json, is_game_finished, ensure_current_tile, apply_player_move, MctsMove, PlayerMove, check_turn_completion};
+use crate::services::session_manager::{get_store_from_manager, SessionManager, get_session_by_id_from_store, update_session_in_store, SessionStoreState, GameSession, get_session_by_code_from_store};
+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
+use crate::utils::image::generate_tile_image_names;
+use crate::game::get_legal_moves::get_legal_moves;
+use crate::game::tile::Tile;
+// ============================================================================
+// GAMESERVICE AVEC INTÉGRATION MCTS + NOUVELLES MÉTHODES GAMEPLAY
+// ============================================================================
+
+#[derive(Clone)]
+pub struct GameServiceImpl {
+    session_manager: Arc<SessionManager>,
+    policy_net: Arc<Mutex<PolicyNet>>,
+    value_net: Arc<Mutex<ValueNet>>,
+    num_simulations: usize,
+}
+
+impl GameServiceImpl {
+    pub fn new(
+        session_manager: Arc<SessionManager>,
+        policy_net: Arc<Mutex<PolicyNet>>,
+        value_net: Arc<Mutex<ValueNet>>,
+        num_simulations: usize
+    ) -> Self {
+        GameServiceImpl {
+            session_manager,
+            policy_net,
+            value_net,
+            num_simulations,
+        }
+    }
+}
+
+// ============================================================================
+// FONCTIONS PURES - CRÉATION DE RÉPONSES (existantes + nouvelles)
+// ============================================================================
+
+fn make_move_success_response(move_result: MoveResult) -> MakeMoveResponse {
+    let mcts_response_json = move_result.mcts_response
+        .as_ref()
+        .and_then(|mcts| mcts_move_to_json(mcts).ok())
+        .unwrap_or_default();
+
+    MakeMoveResponse {
+        result: Some(make_move_response::Result::Success(
+            MakeMoveSuccess {
+                new_game_state: Some(take_it_easy_state_to_protobuf(&move_result.new_game_state)),
+                mcts_response: mcts_response_json,
+                points_earned: move_result.points_earned,
+                is_game_over: move_result.is_game_over,
+            }
+        )),
+    }
+}
+
+fn make_move_error_response(code: String, message: String) -> MakeMoveResponse {
+    MakeMoveResponse {
+        result: Some(make_move_response::Result::Error(Error {
+            code,
+            message,
+            details: std::collections::HashMap::new(),
+        })),
+    }
+}
+
+fn available_moves_success_response(positions: Vec<usize>, current_tile: Option<crate::game::tile::Tile>) -> GetAvailableMovesResponse {
+    let moves_json: Vec<String> = positions
+        .iter()
+        .map(|pos| {
+            serde_json::json!({
+                "position": pos,
+                "tile": current_tile.map(|t| (t.0, t.1, t.2))
+            }).to_string()
+        })
+        .collect();
+
+    GetAvailableMovesResponse {
+        available_moves: moves_json,
+        error: None,
+    }
+}
+
+fn available_moves_error_response(code: String, message: String) -> GetAvailableMovesResponse {
+    GetAvailableMovesResponse {
+        available_moves: vec![],
+        error: Some(Error {
+            code,
+            message,
+            details: std::collections::HashMap::new(),
+        }),
+    }
+}
+
+fn start_turn_success_response(
+    announced_tile: String,
+    tile_image: String,
+    turn_number: i32,
+    waiting_for_players: Vec<String>,
+    game_state_json: String
+) -> StartTurnResponse {
+    StartTurnResponse {
+        success: true,
+        announced_tile,
+        tile_image,
+        turn_number,
+        waiting_for_players,
+        game_state: game_state_json,
+        error: None,
+    }
+}
+
+fn start_turn_error_response(message: String) -> StartTurnResponse {
+    StartTurnResponse {
+        success: false,
+        announced_tile: String::new(),
+        tile_image: String::new(),
+        turn_number: 0,
+        waiting_for_players: vec![],
+        game_state: String::new(),
+        error: Some(Error {
+            code: "START_TURN_FAILED".to_string(),
+            message,
+            details: std::collections::HashMap::new(),
+        }),
+    }
+}
+
+fn game_state_success_response(
+    game_state_json: String,
+    current_tile: String,
+    current_tile_image: String, // ✅ NOUVEAU PARAMÈTRE
+    current_turn: i32,
+    waiting_for_players: Vec<String>,
+    is_game_finished: bool,
+    final_scores_json: String
+) -> GetGameStateResponse {
+    GetGameStateResponse {
+        success: true,
+        game_state: game_state_json,
+        current_tile,
+        current_tile_image, // ✅ NOUVEAU CHAMP
+        current_turn,
+        waiting_for_players,
+        is_game_finished,
+        final_scores: final_scores_json,
+        error: None,
+    }
+}
+
+fn game_state_error_response(message: String) -> GetGameStateResponse {
+    GetGameStateResponse {
+        success: false,
+        game_state: String::new(),
+        current_tile: String::new(),
+        current_tile_image: String::new(), // ✅ Chaîne vide (pas d'image)
+        current_turn: 0,
+        waiting_for_players: vec![],
+        is_game_finished: false,
+        final_scores: String::new(),
+        error: Some(Error {
+            code: "GET_GAME_STATE_FAILED".to_string(),
+            message,
+            details: std::collections::HashMap::new(),
+        }),
+    }
+}
+
+// ============================================================================
+// FONCTION AUXILIAIRE : process_mcts_move_only
+// ============================================================================
+
+pub fn process_mcts_move_only(
+    game_state: TakeItEasyGameState,
+    policy_net: &Mutex<PolicyNet>,
+    value_net: &Mutex<ValueNet>,
+    num_simulations: usize
+) -> Result<(TakeItEasyGameState, MctsMove), String> {
+
+    // ✅ VÉRIFICATION: MCTS doit être en attente
+    if !game_state.waiting_for_players.contains(&"mcts_ai".to_string()) {
+        return Err("MCTS_NOT_WAITING".to_string());
+    }
+
+    let current_tile = game_state.current_tile.ok_or("NO_CURRENT_TILE")?;
+
+    // Récupérer le plateau MCTS
+    let mcts_plateau = game_state.player_plateaus.get("mcts_ai")
+        .ok_or("MCTS_PLAYER_NOT_FOUND")?
+        .clone();
+
+    // ✅ VÉRIFICATION: Mouvements légaux
+    let legal_moves = get_legal_moves(mcts_plateau.clone());
+    if legal_moves.is_empty() {
+        return Err("NO_LEGAL_MOVES_FOR_MCTS".to_string());
+    }
+
+
+    let mut deck_clone = game_state.deck.clone();
+
+    // Verrouiller les réseaux
+    let policy_locked = policy_net.lock().map_err(|_| "Failed to lock policy net")?;
+    let value_locked = value_net.lock().map_err(|_| "Failed to lock value net")?;
+
+    // ✅ EXÉCUTION MCTS
+    let mut mcts_plateau_mut = mcts_plateau.clone();
+    let mcts_result = mcts_find_best_position_for_tile_with_nn(
+        &mut mcts_plateau_mut,
+        &mut deck_clone,
+        current_tile,
+        &*policy_locked,
+        &*value_locked,
+        num_simulations,
+        game_state.current_turn,
+        game_state.total_turns,
+    );
+
+    // ✅ VALIDATION: Position choisie doit être légale
+    if !legal_moves.contains(&mcts_result.best_position) {
+        return Err("MCTS_ILLEGAL_MOVE".to_string());
+    }
+
+    // Créer le mouvement MCTS
+    let mcts_player_move = PlayerMove {
+        player_id: "mcts_ai".to_string(),
+        position: mcts_result.best_position,
+        tile: current_tile,
+        timestamp: chrono::Utc::now().timestamp(),
+    };
+
+
+    // Appliquer le mouvement MCTS
+    let updated_state = apply_player_move(game_state, mcts_player_move)?;
+
+    let mcts_move = MctsMove {
+        position: mcts_result.best_position,
+        tile: current_tile,
+        evaluation_score: mcts_result.subscore as f32,
+        search_depth: num_simulations,
+        variations_considered: num_simulations,
+    };
+
+
+    Ok((updated_state, mcts_move))
+}
+
+// ============================================================================
+// FONCTION POUR GÉRER session par code OU ID
+// ============================================================================
+
+pub async fn get_session_by_code_or_id_from_store(
+    store: &Arc<RwLock<SessionStoreState>>,
+    identifier: &str
+) -> Option<GameSession> {
+    // Essayer d'abord par ID (UUID)
+    if let Some(session) = get_session_by_id_from_store(store, identifier).await {
+        return Some(session);
+    }
+
+    // Ensuite essayer par code (ex: "GTHG7Q")
+    get_session_by_code_from_store(store, identifier).await
+}
+
+// ============================================================================
+// FONCTIONS COMPOSABLES - LOGIQUE MÉTIER (existantes + nouvelles)
+// ============================================================================
+
+async fn make_move_logic(
+    service: &GameServiceImpl,
+    session_id: String,
+    player_id: String,
+    move_data: String,
+    timestamp: i64
+) -> Result<Response<MakeMoveResponse>, Status> {
+    let store = get_store_from_manager(&service.session_manager);
+
+    let session = match get_session_by_code_or_id_from_store(store, &session_id).await {
+        Some(session) => session,
+        None => {
+            let response = make_move_error_response(
+                "SESSION_NOT_FOUND".to_string(),
+                "Session not found".to_string()
+            );
+            return Ok(Response::new(response));
+        }
+    };
+
+    // Récupérer l'état de jeu
+    let game_state: TakeItEasyGameState = if session.board_state.is_empty() || session.board_state == "{}" {
+        let response = make_move_error_response(
+            "GAME_NOT_STARTED".to_string(),
+            "No game state found. Please start a turn first.".to_string()
+        );
+        return Ok(Response::new(response));
+    } else {
+        serde_json::from_str(&session.board_state)
+            .map_err(|e| Status::internal(format!("Failed to parse game state: {}", e)))?
+    };
+
+    // Vérification: S'assurer qu'une tuile courante existe
+    let game_state = match ensure_current_tile(game_state) {
+        Ok(state) => {            state
+        },
+        Err(e) => {
+            log::error!("❌ Échec garantie tuile: {}", e);
+            return Ok(Response::new(make_move_error_response(
+                "NO_CURRENT_TILE".to_string(),
+                format!("No current tile available: {}", e)
+            )));
+        }
+    };
+    // Parser le mouvement du joueur
+    let player_move = match player_move_from_json(&move_data, &player_id) {
+        Ok(mv) => {
+            let mut mv = mv;
+            mv.timestamp = timestamp;
+            if let Some(current_tile) = game_state.current_tile {
+                mv.tile = current_tile;
+            }
+            mv
+        },
+        Err(e) => {
+            let response = make_move_error_response(
+                "INVALID_MOVE_FORMAT".to_string(),
+                format!("Failed to parse move: {}", e)
+            );
+            return Ok(Response::new(response));
+        }
+    };
+
+    // Traitement du mouvement avec MCTS
+    match process_player_move_with_mcts(
+        game_state,
+        player_move,
+        &*service.policy_net,
+        &*service.value_net,
+        service.num_simulations
+    ) {
+        Ok(move_result) => {
+            let final_state = move_result.new_game_state.clone();
+
+            // Sauvegarder l'état final
+            let mut updated_session = session;
+            updated_session.board_state = serde_json::to_string(&final_state).unwrap_or_default();
+
+            // Mettre à jour les scores
+            for (player_id, score) in &final_state.scores {
+                if let Some(player) = updated_session.players.get_mut(player_id) {
+                    player.score = *score;
+                }
+            }
+
+            update_session_in_store(store, updated_session).await
+                .map_err(|e| Status::internal(e))?;
+
+            let response = make_move_success_response(move_result);
+            Ok(Response::new(response))
+        },
+        Err(error_code) => {
+            let response = make_move_error_response(
+                error_code,
+                "Failed to process move".to_string()
+            );
+            Ok(Response::new(response))
+        }
+    }
+}
+
+async fn get_available_moves_logic(
+    service: &GameServiceImpl,
+    session_id: String,
+    player_id: String
+) -> Result<Response<GetAvailableMovesResponse>, Status> {
+    let store = get_store_from_manager(&service.session_manager);
+
+    // Récupérer la session
+    let session = match get_session_by_id_from_store(store, &session_id).await {
+        Some(session) => session,
+        None => {
+            let response = available_moves_error_response(
+                "SESSION_NOT_FOUND".to_string(),
+                "Session not found".to_string()
+            );
+            return Ok(Response::new(response));
+        }
+    };
+
+    // Récupérer l'état de jeu
+    let game_state: TakeItEasyGameState = if session.board_state.is_empty() || session.board_state == "{}" {
+        let response = available_moves_error_response(
+            "GAME_NOT_STARTED".to_string(),
+            "Game has not started yet".to_string()
+        );
+        return Ok(Response::new(response));
+    } else {
+        serde_json::from_str(&session.board_state)
+            .map_err(|e| Status::internal(format!("Failed to parse game state: {}", e)))?
+    };
+
+    // Vérifier si le jeu est terminé
+    if is_game_finished(&game_state) {
+        let response = available_moves_error_response(
+            "GAME_FINISHED".to_string(),
+            "Game is already finished".to_string()
+        );
+        return Ok(Response::new(response));
+    }
+
+    // Obtenir les positions disponibles
+    let available_positions = get_available_positions(&game_state, &player_id);
+    let current_tile = game_state.current_tile;
+
+    let response = available_moves_success_response(available_positions, current_tile);
+    Ok(Response::new(response))
+}
+
+async fn start_turn_logic(
+    service: &GameServiceImpl,
+    session_id: String
+) -> Result<Response<StartTurnResponse>, Status> {
+    let store = get_store_from_manager(&service.session_manager);
+    let session = match get_session_by_code_or_id_from_store(store, &session_id).await {
+        Some(session) => {            session
+        },
+        None => {
+            return Ok(Response::new(start_turn_error_response("Session not found".to_string())));
+        }
+    };
+
+    // Récupérer ou créer l'état de jeu
+    let mut game_state: TakeItEasyGameState = if session.board_state.is_empty() || session.board_state == "{}" {
+        // Première fois - créer le jeu
+        let player_ids: Vec<String> = session.players.keys().cloned().collect();
+        create_take_it_easy_game(session_id.clone(), player_ids)
+    } else {
+        // Désérialiser l'état existant
+        match serde_json::from_str::<TakeItEasyGameState>(&session.board_state) {
+            Ok(mut state) => {
+                state.session_id = session_id.clone();
+                state
+            },
+            Err(e) => {                let player_ids: Vec<String> = session.players.keys().cloned().collect();
+                create_take_it_easy_game(session_id.clone(), player_ids)
+            }
+        }
+    };
+
+    // Vérifier si une tuile existe déjà pour ce tour
+    let new_state = if game_state.current_tile.is_some() {
+        // ✅ Une tuile existe déjà, utiliser l'état actuel
+        game_state
+    } else {
+        match start_new_turn(game_state) {
+            Ok(new_state) => {
+                new_state
+            },
+            Err(e) => {
+                return Ok(Response::new(start_turn_error_response(format!("Failed to start turn: {}", e))));
+            }
+        }
+    };
+
+    // ✅ NOUVEAU: FAIRE JOUER MCTS AUTOMATIQUEMENT DÈS QU'UNE TUILE EST DISPONIBLE
+    let final_state = if new_state.waiting_for_players.contains(&"mcts_ai".to_string()) {
+
+        // Utiliser la fonction process_mcts_move_only
+        match process_mcts_move_only(
+            new_state.clone(),
+            &*service.policy_net,
+            &*service.value_net,
+            service.num_simulations
+        ) {
+            Ok((updated_state, _mcts_move)) => {
+                let update_state_clone = updated_state.clone();
+                // Vérifier si le tour est terminé après que MCTS ait joué
+                match check_turn_completion(update_state_clone) {
+                    Ok(completed_state) => {
+                        completed_state
+                    },
+                    Err(_e) => {
+                        updated_state.clone()
+                    }
+                }
+            },
+            Err(_e) => {
+                // Retirer MCTS de la liste pour ne pas bloquer le jeu
+                let mut fallback_state = new_state.clone();
+                fallback_state.waiting_for_players.retain(|id| id != "mcts_ai");
+                fallback_state
+            }
+        }
+    } else {
+        new_state
+    };
+
+    // Extraire les informations de la tuile
+    let announced_tile = final_state.current_tile.unwrap();
+    let announced_tile_str = format!("{}-{}-{}", announced_tile.0, announced_tile.1, announced_tile.2);
+    let tile_image = generate_tile_image_names(&[announced_tile])[0].clone();
+
+    let turn_number = final_state.current_turn as i32;
+    let waiting_for_players = final_state.waiting_for_players.clone();
+    let game_state_json = serde_json::to_string(&final_state).unwrap_or_default();
+
+    // Sauvegarder l'état mis à jour (avec le mouvement MCTS si applicable)
+    let mut updated_session = session;
+    updated_session.board_state = game_state_json.clone();
+
+    if let Err(e) = update_session_in_store(store, updated_session).await {
+        return Ok(Response::new(start_turn_error_response(format!("Failed to update session: {}", e))));
+    }
+
+
+    let response = start_turn_success_response(
+        announced_tile_str,
+        tile_image,
+        turn_number,
+        waiting_for_players,
+        game_state_json
+    );
+    Ok(Response::new(response))
+}
+fn enhance_game_state_with_images(board_state: &str) -> String {
+    // Parser le JSON existant
+    let mut game_data = serde_json::from_str::<serde_json::Value>(board_state).unwrap_or_else(|_| {
+        // Si parsing échoue, créer structure minimale
+        log::warn!("Parsing board_state échoué, création structure par défaut");
+        serde_json::json!({
+                "player_plateaus": {}
+            })
+    });
+
+    // 🛡️ GARANTIR que player_plateaus existe
+    if !game_data.get("player_plateaus").is_some() {
+        game_data["player_plateaus"] = serde_json::json!({});
+    }
+
+    // 🛡️ GARANTIR que chaque plateau a tile_images et available_positions
+    if let Some(player_plateaus) = game_data.get_mut("player_plateaus") {
+        if let Some(plateaus_obj) = player_plateaus.as_object_mut() {
+
+            for (player_id, plateau_data) in plateaus_obj.iter_mut() {
+
+                // 🛡️ GARANTIR que tiles existe, sinon créer plateau vide
+                let tiles_array = match plateau_data.get("tiles") {
+                    Some(tiles) => tiles.clone(),
+                    None => {
+                        log::warn!("Plateau manquant pour {}, création plateau vide", player_id);
+                        serde_json::json!(vec![[0, 0, 0]; 19]) // 19 positions vides
+                    }
+                };
+
+                if let Some(tiles) = tiles_array.as_array() {
+                    // Convertir JSON tiles vers Rust Tiles
+                    let rust_tiles: Vec<Tile> = tiles
+                        .iter()
+                        .map(|tile_json| {
+                            if let Some(tile_array) = tile_json.as_array() {
+                                if tile_array.len() == 3 {
+                                    Tile(
+                                        tile_array[0].as_i64().unwrap_or(0) as i32,
+                                        tile_array[1].as_i64().unwrap_or(0) as i32,
+                                        tile_array[2].as_i64().unwrap_or(0) as i32,
+                                    )
+                                } else {
+                                    log::warn!("Tuile malformée pour {}, utilisation (0,0,0)", player_id);
+                                    Tile(0, 0, 0)
+                                }
+                            } else {
+                                log::warn!("Format tuile invalide pour {}, utilisation (0,0,0)", player_id);
+                                Tile(0, 0, 0)
+                            }
+                        })
+                        .collect();
+
+                    // 🚀 TOUJOURS GÉNÉRER tile_images (garantie 100%)
+                    let tile_images = generate_tile_image_names(&rust_tiles);
+
+                    // 🚀 TOUJOURS CALCULER available_positions (garantie 100%)
+                    let available_positions: Vec<i32> = rust_tiles
+                        .iter()
+                        .enumerate()
+                        .filter_map(|(index, tile)| {
+                            if *tile == Tile(0, 0, 0) {
+                                Some(index as i32)
+                            } else {
+                                None
+                            }
+                        })
+                        .collect();
+
+                    // 🛡️ GARANTIR l'ajout au JSON (même si plateau_data est malformé)
+                    if let Some(plateau_obj) = plateau_data.as_object_mut() {
+                        // Mettre à jour les données existantes
+                        plateau_obj.insert("tiles".to_string(), tiles_array);
+                        plateau_obj.insert(
+                            "tile_images".to_string(),
+                            serde_json::Value::Array(
+                                tile_images.into_iter()
+                                    .map(serde_json::Value::String)
+                                    .collect()
+                            )
+                        );
+                        plateau_obj.insert(
+                            "available_positions".to_string(),
+                            serde_json::Value::Array(
+                                available_positions.into_iter()
+                                    .map(|pos| serde_json::Value::Number(pos.into()))
+                                    .collect()
+                            )
+                        );
+                    } else {
+                        // Si plateau_data n'est pas un objet, le recréer
+                        *plateau_data = serde_json::json!({
+                            "tiles": tiles_array,
+                            "tile_images": tile_images,
+                            "available_positions": available_positions
+                        });
+                    }
+                } else {
+                    // Si tiles n'est pas un array, créer plateau vide par défaut
+                    log::warn!("tiles n'est pas un array pour {}, création plateau vide", player_id);
+                    let empty_tiles = vec![Tile(0, 0, 0); 19];
+                    let empty_images = generate_tile_image_names(&empty_tiles);
+                    let all_positions: Vec<i32> = (0..19).collect();
+
+                    *plateau_data = serde_json::json!({
+                        "tiles": vec![[0, 0, 0]; 19],
+                        "tile_images": empty_images,
+                        "available_positions": all_positions
+                    });
+                }
+            }
+        }
+    }
+
+    // Retourner le JSON enrichi (garantie que tile_images existe)
+    game_data.to_string()
+}
+// Dans game_service.rs - Ajouter ces lignes dans get_game_state_logic
+
+async fn get_game_state_logic(
+    service: &GameServiceImpl,
+    session_id: String
+) -> Result<Response<GetGameStateResponse>, Status> {
+    let store = get_store_from_manager(&service.session_manager);
+
+    // Récupérer la session
+    let session = match get_session_by_id_from_store(store, &session_id).await {
+        Some(session) => session,
+        None => {
+            return Ok(Response::new(game_state_error_response("Session not found".to_string())));
+        }
+    };
+
+    if session.board_state.is_empty() || session.board_state == "{}" {
+        return Ok(Response::new(game_state_error_response("Game not started yet".to_string())));
+    }
+
+    let game_state: TakeItEasyGameState = match serde_json::from_str(&session.board_state) {
+        Ok(state) => state,
+        Err(e) => return Ok(Response::new(game_state_error_response(format!("Failed to parse game state: {}", e)))),
+    };
+
+    let current_tile_str = game_state.current_tile
+        .map(|t| format!("{}-{}-{}", t.0, t.1, t.2))
+        .unwrap_or_default();
+
+    // ✅ CORRECTION: Gérer tuile vide (0,0,0)
+    let current_tile_image = game_state.current_tile
+        .filter(|tile| *tile != Tile(0, 0, 0)) // ✅ Filtrer les tuiles vides
+        .map(|tile| {
+            let tile_images = generate_tile_image_names(&[tile]);
+            tile_images[0].clone()
+        })
+        .unwrap_or_else(|| String::new()); // ✅ Chaîne vide au lieu de "000.png"
+
+    let final_scores_json = if is_game_finished(&game_state) {
+        serde_json::to_string(&game_state.scores).unwrap_or_default()
+    } else {
+        "{}".to_string()
+    };
+
+    let current_turn = game_state.current_turn as i32;
+    let waiting_for_players = game_state.waiting_for_players.clone();
+    let is_finished = is_game_finished(&game_state);
+    let game_state_json = serde_json::to_string(&game_state).unwrap_or_default();
+
+    // ✅ Enrichir avec les images
+    let enhanced_game_state_json = enhance_game_state_with_images(&game_state_json);
+
+    let response = game_state_success_response(
+        enhanced_game_state_json,
+        current_tile_str,
+        current_tile_image, // ✅ Sera vide si pas de tuile
+        current_turn,
+        waiting_for_players,
+        is_finished,
+        final_scores_json
+    );
+
+    Ok(Response::new(response))
+}
+
+// ============================================================================
+// IMPLÉMENTATION GRPC - TRAIT GÉNÉRÉ PAR TONIC
+// ============================================================================
+
+#[tonic::async_trait]
+impl GameService for GameServiceImpl {
+    async fn make_move(
+        &self,
+        request: Request<MakeMoveRequest>,
+    ) -> Result<Response<MakeMoveResponse>, Status> {
+        let req = request.into_inner();
+        make_move_logic(
+            self,
+            req.session_id,
+            req.player_id,
+            req.move_data,
+            req.timestamp
+        ).await
+    }
+
+    async fn get_available_moves(
+        &self,
+        request: Request<GetAvailableMovesRequest>,
+    ) -> Result<Response<GetAvailableMovesResponse>, Status> {
+        let req = request.into_inner();
+        get_available_moves_logic(
+            self,
+            req.session_id,
+            req.player_id
+        ).await
+    }
+
+    async fn start_turn(
+        &self,
+        request: Request<StartTurnRequest>,
+    ) -> Result<Response<StartTurnResponse>, Status> {
+        let req = request.into_inner();
+        start_turn_logic(self, req.session_id).await
+    }
+
+    async fn get_game_state(
+        &self,
+        request: Request<GetGameStateRequest>,
+    ) -> Result<Response<GetGameStateResponse>, Status> {
+        let req = request.into_inner();
+        get_game_state_logic(self, req.session_id).await
+    }
+
+}
+// src/services/game_service.rs - TESTS TDD POUR enhance_game_state_with_images
+
+// ... votre code existant de GameService ...
+
+// À la fin du fichier, ajouter ces tests TDD :
+
+#[cfg(test)]
+mod image_enhancement_tests {
+    use super::*;
+    use crate::game::create_deck::create_deck;
+    use crate::game::tile::Tile;
+
+    // ========================================================================
+    // TESTS TDD POUR enhance_game_state_with_images (fonction core)
+    // ========================================================================
+
+    #[test]
+    fn test_enhance_game_state_basic_plateau() {
+        // Arrange - Créer un JSON de base avec vraies tuiles du deck
+        let deck = create_deck();
+        let input_json = format!(r#"{{
+            "player_plateaus": {{
+                "player1": {{
+                    "tiles": [[{},{},{}], [0,0,0], [{},{},{}]]
+                }}
+            }}
+        }}"#,
+                                 deck.tiles[0].0, deck.tiles[0].1, deck.tiles[0].2,
+                                 deck.tiles[1].0, deck.tiles[1].1, deck.tiles[1].2
+        );
+
+        // Act
+        let result = enhance_game_state_with_images(&input_json);
+
+        // Assert
+        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
+        let plateau = &parsed["player_plateaus"]["player1"];
+
+        // Vérifier que tile_images a été ajouté
+        assert!(plateau.get("tile_images").is_some());
+        let images = plateau["tile_images"].as_array().unwrap();
+        assert_eq!(images.len(), 3);
+
+        // Vérifier le format des images
+        assert!(images[0].as_str().unwrap().starts_with("../image/"));
+        assert!(images[0].as_str().unwrap().ends_with(".png"));
+        assert_eq!(images[1], "../image/000.png"); // Position vide
+
+        // Vérifier que available_positions a été ajouté
+        assert!(plateau.get("available_positions").is_some());
+        let positions = plateau["available_positions"].as_array().unwrap();
+        assert_eq!(positions.len(), 1); // Une seule position vide (index 1)
+        assert_eq!(positions[0], 1);
+    }
+
+    #[test]
+    fn test_enhance_game_state_empty_plateau() {
+        // Test avec plateau entièrement vide (cas réaliste début de partie)
+        let input_json = r#"{
+            "player_plateaus": {
+                "player1": {
+                    "tiles": [[0,0,0], [0,0,0], [0,0,0], [0,0,0], [0,0,0]]
+                }
+            }
+        }"#;
+
+        let result = enhance_game_state_with_images(input_json);
+        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
+
+        let plateau = &parsed["player_plateaus"]["player1"];
+        let images = plateau["tile_images"].as_array().unwrap();
+        let positions = plateau["available_positions"].as_array().unwrap();
+
+        // Toutes les images devraient être vides
+        assert_eq!(images.len(), 5);
+        for image in images {
+            assert_eq!(image, "../image/000.png");
+        }
+
+        // Toutes les positions devraient être disponibles
+        assert_eq!(positions.len(), 5);
+        for (i, pos) in positions.iter().enumerate() {
+            assert_eq!(pos, i);
+        }
+    }
+
+    #[test]
+    fn test_enhance_game_state_full_plateau() {
+        // Test avec plateau entièrement rempli (cas réaliste fin de partie)
+        let deck = create_deck();
+        let input_json = format!(r#"{{
+            "player_plateaus": {{
+                "player1": {{
+                    "tiles": [
+                        [{},{},{}],
+                        [{},{},{}],
+                        [{},{},{}]
+                    ]
+                }}
+            }}
+        }}"#,
+                                 deck.tiles[0].0, deck.tiles[0].1, deck.tiles[0].2,
+                                 deck.tiles[1].0, deck.tiles[1].1, deck.tiles[1].2,
+                                 deck.tiles[2].0, deck.tiles[2].1, deck.tiles[2].2
+        );
+
+        let result = enhance_game_state_with_images(&input_json);
+        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
+
+        let plateau = &parsed["player_plateaus"]["player1"];
+        let images = plateau["tile_images"].as_array().unwrap();
+        let positions = plateau["available_positions"].as_array().unwrap();
+
+        // Toutes les images devraient être non-vides
+        assert_eq!(images.len(), 3);
+        for image in images {
+            let img_str = image.as_str().unwrap();
+            assert!(img_str.starts_with("../image/"));
+            assert!(img_str.ends_with(".png"));
+            assert_ne!(img_str, "../image/000.png"); // Aucune image vide
+        }
+
+        // Aucune position disponible
+        assert_eq!(positions.len(), 0);
+    }
+
+    #[test]
+    fn test_enhance_game_state_multiple_players() {
+        // Test avec plusieurs joueurs (cas réaliste multijoueur)
+        let deck = create_deck();
+        let input_json = format!(r#"{{
+            "player_plateaus": {{
+                "player1": {{
+                    "tiles": [[{},{},{}], [0,0,0]]
+                }},
+                "player2": {{
+                    "tiles": [[0,0,0], [{},{},{}]]
+                }},
+                "mcts_ai": {{
+                    "tiles": [[{},{},{}], [{},{},{}]]
+                }}
+            }}
+        }}"#,
+                                 deck.tiles[0].0, deck.tiles[0].1, deck.tiles[0].2,
+                                 deck.tiles[1].0, deck.tiles[1].1, deck.tiles[1].2,
+                                 deck.tiles[2].0, deck.tiles[2].1, deck.tiles[2].2,
+                                 deck.tiles[3].0, deck.tiles[3].1, deck.tiles[3].2
+        );
+
+        let result = enhance_game_state_with_images(&input_json);
+        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
+
+        // Vérifier chaque joueur
+        for player_id in ["player1", "player2", "mcts_ai"] {
+            let plateau = &parsed["player_plateaus"][player_id];
+
+            assert!(plateau.get("tile_images").is_some());
+            assert!(plateau.get("available_positions").is_some());
+
+            let images = plateau["tile_images"].as_array().unwrap();
+            let positions = plateau["available_positions"].as_array().unwrap();
+
+            assert_eq!(images.len(), 2); // Chaque joueur a 2 positions
+
+            // Vérifier cohérence images/positions
+            for (index, image) in images.iter().enumerate() {
+                let is_empty_image = image == "../image/000.png";
+                let is_available_position = positions.contains(&serde_json::Value::Number((index as i32).into()));
+
+                // Si image vide, position devrait être disponible
+                assert_eq!(is_empty_image, is_available_position);
+            }
+        }
+    }
+
+    #[test]
+    fn test_enhance_game_state_realistic_19_positions() {
+        // Test avec 19 positions (taille réelle du plateau Take It Easy)
+        let deck = create_deck();
+        let mut tiles_array = vec![String::from("[0,0,0]"); 19]; // 19 positions vides
+
+        // Placer quelques tuiles réalistes
+        tiles_array[0] = format!("[{},{},{}]", deck.tiles[0].0, deck.tiles[0].1, deck.tiles[0].2);
+        tiles_array[8] = format!("[{},{},{}]", deck.tiles[1].0, deck.tiles[1].1, deck.tiles[1].2); // Centre
+        tiles_array[18] = format!("[{},{},{}]", deck.tiles[2].0, deck.tiles[2].1, deck.tiles[2].2); // Coin
+
+        let input_json = format!(r#"{{
+            "player_plateaus": {{
+            
+                "player1": {{
+                    "tiles": [{}]
+                }}
+            }}
+        }}"#, tiles_array.join(", "));
+
+        let result = enhance_game_state_with_images(&input_json);
+        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
+
+        let plateau = &parsed["player_plateaus"]["player1"];
+        let images = plateau["tile_images"].as_array().unwrap();
+        let positions = plateau["available_positions"].as_array().unwrap();
+
+        // Vérifier la taille réelle du plateau
+        assert_eq!(images.len(), 19);
+
+        // 3 tuiles placées, donc 16 positions disponibles
+        assert_eq!(positions.len(), 16);
+
+        // Vérifier les positions occupées
+        assert_ne!(images[0], "../image/000.png");  // Position 0 occupée
+        assert_ne!(images[8], "../image/000.png");  // Position 8 occupée (centre)
+        assert_ne!(images[18], "../image/000.png"); // Position 18 occupée
+
+        // Vérifier que les positions occupées ne sont pas dans available_positions
+        assert!(!positions.contains(&serde_json::Value::Number(0.into())));
+        assert!(!positions.contains(&serde_json::Value::Number(8.into())));
+        assert!(!positions.contains(&serde_json::Value::Number(18.into())));
+    }
+
+    // ========================================================================
+    // TESTS D'ERREUR ET CAS LIMITES (TDD robustesse)
+    // ========================================================================
+
+    #[test]
+    fn test_enhance_game_state_invalid_json() {
+        // Test avec JSON invalide
+        let result = enhance_game_state_with_images("invalid json");
+        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
+
+        // Devrait créer structure par défaut
+        assert!(parsed.get("player_plateaus").is_some());
+    }
+
+    #[test]
+    fn test_enhance_game_state_missing_player_plateaus() {
+        // Test sans player_plateaus
+        let input_json = r#"{"some_other_field": "value"}"#;
+
+        let result = enhance_game_state_with_images(input_json);
+        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
+
+        // Devrait ajouter player_plateaus
+        assert!(parsed.get("player_plateaus").is_some());
+    }
+
+    #[test]
+    fn test_enhance_game_state_malformed_tiles() {
+        // Test avec tuiles malformées
+        let input_json = r#"{
+            "player_plateaus": {
+                "player1": {
+                    "tiles": ["invalid", [1,2], [1,2,3,4]]
+                }
+            }
+        }"#;
+
+        let result = enhance_game_state_with_images(input_json);
+        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
+
+        let plateau = &parsed["player_plateaus"]["player1"];
+        let images = plateau["tile_images"].as_array().unwrap();
+
+        // Devrait gérer les tuiles malformées en les remplaçant par (0,0,0)
+        assert_eq!(images.len(), 3);
+        for image in images {
+            assert_eq!(image, "../image/000.png"); // Tuiles malformées → vides
+        }
+    }
+
+    // ========================================================================
+    // TESTS DE PERFORMANCE (TDD performance)
+    // ========================================================================
+
+    #[test]
+    fn test_enhance_game_state_performance_large_game() {
+        // Test avec plusieurs joueurs et plateaux complets
+        let deck = create_deck();
+        let mut large_input = String::from(r#"{"player_plateaus": {"#);
+
+        // Créer 4 joueurs avec plateaux de 19 positions chacun
+        for player_num in 1..=4 {
+            if player_num > 1 { large_input.push_str(", "); }
+            large_input.push_str(&format!(r#""player{}": {{"tiles": ["#, player_num));
+
+            for pos in 0..19 {
+                if pos > 0 { large_input.push_str(", "); }
+                let tile = &deck.tiles[pos % deck.tiles.len()];
+                large_input.push_str(&format!("[{},{},{}]", tile.0, tile.1, tile.2));
+            }
+
+            large_input.push_str("]}");
+        }
+        large_input.push_str("}}");
+
+        // Mesurer le temps
+        let start = std::time::Instant::now();
+        let result = enhance_game_state_with_images(&large_input);
+        let duration = start.elapsed();
+
+        // Performance : ne devrait pas prendre plus de 10ms pour 4 joueurs × 19 positions
+        assert!(duration.as_millis() < 10, "Performance trop lente: {:?}", duration);
+
+        // Vérifier que le résultat est correct
+        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
+        for player_num in 1..=4 {
+            let plateau = &parsed["player_plateaus"][&format!("player{}", player_num)];
+            let images = plateau["tile_images"].as_array().unwrap();
+            assert_eq!(images.len(), 19);
+        }
+    }
+
+    // ========================================================================
+    // TESTS D'INTÉGRATION AVEC generate_tile_image_names
+    // ========================================================================
+
+    #[test]
+    fn test_enhance_uses_generate_tile_image_names_correctly() {
+        // Test que enhance_game_state_with_images utilise bien generate_tile_image_names
+        let deck = create_deck();
+        let test_tile = &deck.tiles[0];
+
+        // Générer l'image attendue avec la fonction directe
+        let expected_image =generate_tile_image_names(&[*test_tile])[0].clone();
+
+        // Tester via enhance_game_state_with_images
+        let input_json = format!(r#"{{
+            "player_plateaus": {{
+                "player1": {{
+                    "tiles": [[{},{},{}]]
+                }}
+            }}
+        }}"#, test_tile.0, test_tile.1, test_tile.2);
+
+        let result = enhance_game_state_with_images(&input_json);
+        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
+
+        let actual_image = parsed["player_plateaus"]["player1"]["tile_images"][0].as_str().unwrap();
+
+        // Les deux méthodes devraient donner le même résultat
+        assert_eq!(actual_image, expected_image);
+    }
+}
\ No newline at end of file
diff --git a/src/services/mod.rs b/src/services/mod.rs
index e69de29..53e07e8 100644
--- a/src/services/mod.rs
+++ b/src/services/mod.rs
@@ -0,0 +1,5 @@
+pub mod session_service;
+pub mod session_manager;
+pub mod game_manager;
+pub mod game_service;
+mod session_manager_integration_test;
diff --git a/src/services/session_manager.rs b/src/services/session_manager.rs
index e69de29..b49a181 100644
--- a/src/services/session_manager.rs
+++ b/src/services/session_manager.rs
@@ -0,0 +1,447 @@
+// src/services/session_manager.rs - 100% fonctionnel - TOUTES les fonctions extraites
+
+use std::collections::HashMap;
+use std::sync::Arc;
+use tokio::sync::RwLock;
+use uuid::Uuid;
+use crate::generated::takeiteasygame::v1::*;
+
+// ============================================================================
+// TYPES DE DONNÉES IMMUTABLES PURS
+// ============================================================================
+
+#[derive(Debug, Clone)]
+pub struct GameSession {
+    pub id: String,
+    pub code: String,
+    pub players: HashMap<String, Player>,
+    pub current_player_id: Option<String>,
+    pub state: i32,
+    pub max_players: i32,
+    pub game_mode: String,
+    pub created_at: std::time::Instant,
+    pub board_state: String,
+    pub turn_number: i32,
+}
+
+#[derive(Debug, Clone)]
+pub enum SessionAction {
+    CreateSession { session: GameSession },
+    UpdateSession { session: GameSession },
+    RemoveSession { session_id: String },
+}
+
+#[derive(Debug, Clone)]
+pub struct SessionStoreState {
+    pub sessions: HashMap<String, GameSession>,
+    pub sessions_by_code: HashMap<String, String>,
+}
+
+impl SessionStoreState {
+    pub fn new() -> Self {
+        Self {
+            sessions: HashMap::new(),
+            sessions_by_code: HashMap::new(),
+        }
+    }
+}
+
+// SessionManager - Structure de données pure (pas de logique)
+#[derive(Clone)]
+pub struct SessionManager {
+    store: Arc<RwLock<SessionStoreState>>,
+}
+
+// ============================================================================
+// FONCTIONS DE CONSTRUCTION (FACTORY FUNCTIONS)
+// ============================================================================
+
+pub fn new_session_manager() -> SessionManager {
+    SessionManager {
+        store: Arc::new(RwLock::new(SessionStoreState::new())),
+    }
+}
+
+pub fn get_store_from_manager(manager: &SessionManager) -> &Arc<RwLock<SessionStoreState>> {
+    &manager.store
+}
+
+// ============================================================================
+// FONCTIONS PURES - MANIPULATION D'ÉTAT
+// ============================================================================
+
+pub fn apply_session_action(state: SessionStoreState, action: SessionAction) -> SessionStoreState {
+    match action {
+        SessionAction::CreateSession { session } => {
+            let mut new_state = state;
+            new_state.sessions.insert(session.id.clone(), session.clone());
+            new_state.sessions_by_code.insert(session.code.clone(), session.id.clone());
+            new_state
+        },
+        SessionAction::UpdateSession { session } => {
+            let mut new_state = state;
+            new_state.sessions.insert(session.id.clone(), session.clone());
+            new_state.sessions_by_code.insert(session.code.clone(), session.id.clone());
+            new_state
+        },
+        SessionAction::RemoveSession { session_id } => {
+            let mut new_state = state;
+            if let Some(session) = new_state.sessions.remove(&session_id) {
+                new_state.sessions_by_code.remove(&session.code);
+            }
+            new_state
+        }
+    }
+}
+
+// ============================================================================
+// FONCTIONS PURES - REQUÊTES
+// ============================================================================
+
+pub fn find_session_by_code<'a>(state: &'a SessionStoreState, code: &str) -> Option<&'a GameSession> {
+    state.sessions_by_code.get(code)
+        .and_then(|session_id| state.sessions.get(session_id))
+}
+
+pub fn find_session_by_id<'a>(state: &'a SessionStoreState, session_id: &str) -> Option<&'a GameSession> {
+    state.sessions.get(session_id)
+}
+
+pub fn count_sessions(state: &SessionStoreState) -> usize {
+    state.sessions.len()
+}
+
+pub fn get_all_session_codes(state: &SessionStoreState) -> Vec<String> {
+    state.sessions_by_code.keys().cloned().collect()
+}
+
+// ============================================================================
+// FONCTIONS PURES - CRÉATION D'OBJETS
+// ============================================================================
+
+pub fn create_game_session(max_players: i32, game_mode: String) -> GameSession {
+    GameSession {
+        id: Uuid::new_v4().to_string(),
+        code: generate_session_code(),
+        players: HashMap::new(),
+        current_player_id: None,
+        state: 0, // WAITING
+        max_players,
+        game_mode,
+        created_at: std::time::Instant::now(),
+        board_state: "{}".to_string(),
+        turn_number: 0,
+    }
+}
+
+pub fn create_session_action(max_players: i32, game_mode: String) -> (SessionAction, String) {
+    let session = create_game_session(max_players, game_mode);
+    let session_code = session.code.clone();
+    (SessionAction::CreateSession { session }, session_code)
+}
+
+// ============================================================================
+// FONCTIONS PURES - TRANSFORMATIONS DE SESSIONS
+// ============================================================================
+
+// src/services/session_manager.rs
+// src/services/session_manager.rs
+pub fn add_player_to_session(
+    session: GameSession,
+    player_name: String
+) -> Result<(GameSession, String), String> {
+    if session.players.len() >= session.max_players as usize {
+        return Err("SESSION_FULL".to_string());
+    }
+
+    if session.state != 0 {
+        return Err("GAME_IN_PROGRESS".to_string());
+    }
+
+    let player_id = Uuid::new_v4().to_string();
+
+    // ✅ Le créateur (premier joueur) est automatiquement prêt
+    let is_first_player = session.players.is_empty();
+
+    let player = Player {
+        id: player_id.clone(),
+        name: player_name,
+        score: 0,
+        is_ready: is_first_player, // ← Automatiquement prêt si c'est le créateur
+        is_connected: true,
+        joined_at: chrono::Utc::now().timestamp(),
+    };
+
+    let mut new_session = session;
+    new_session.players.insert(player_id.clone(), player);
+
+    Ok((new_session, player_id))
+}
+
+pub fn set_player_ready_in_session(
+    session: GameSession,
+    player_id: &str,
+    ready: bool
+) -> Result<(GameSession, bool), String> {
+    let mut new_session = session;
+
+    match new_session.players.get_mut(player_id) {
+        Some(player) => {
+            player.is_ready = ready;
+
+            let game_started = if all_players_ready(&new_session) && new_session.players.len() >= 2 {
+                new_session = start_game(new_session);
+                true
+            } else {
+                false
+            };
+
+            Ok((new_session, game_started))
+        },
+        None => Err("PLAYER_NOT_FOUND".to_string())
+    }
+}
+
+pub fn remove_player_from_session(
+    session: GameSession,
+    player_id: &str
+) -> (GameSession, bool) {
+    let mut new_session = session;
+    let was_removed = new_session.players.remove(player_id).is_some();
+
+    // If it was the current player's turn, advance to next player
+    if new_session.current_player_id.as_ref() == Some(&player_id.to_string()) {
+        new_session = advance_turn(new_session);
+    }
+
+    (new_session, was_removed)
+}
+
+pub fn advance_turn(session: GameSession) -> GameSession {
+    let mut new_session = session;
+
+    if let Some(current_id) = &new_session.current_player_id {
+        let player_ids: Vec<String> = new_session.players.keys().cloned().collect();
+
+        if let Some(current_index) = player_ids.iter().position(|id| id == current_id) {
+            let next_index = (current_index + 1) % player_ids.len();
+            new_session.current_player_id = Some(player_ids[next_index].clone());
+            new_session.turn_number += 1;
+        }
+    }
+
+    new_session
+}
+
+// ============================================================================
+// FONCTIONS PURES - UTILITAIRES
+// ============================================================================
+
+fn all_players_ready(session: &GameSession) -> bool {
+    !session.players.is_empty() &&
+        session.players.values().all(|p| p.is_ready && p.is_connected)
+}
+
+fn start_game(session: GameSession) -> GameSession {
+    let mut new_session = session;
+    new_session.state = 1; // IN_PROGRESS
+
+    // Set first player
+    if let Some(first_player_id) = new_session.players.keys().next() {
+        new_session.current_player_id = Some(first_player_id.clone());
+    }
+
+    new_session.turn_number = 1;
+    new_session.board_state = r#"{"tiles": [], "available_positions": []}"#.to_string();
+
+    new_session
+}
+
+pub fn session_to_game_state(session: &GameSession) -> GameState {
+    GameState {
+        session_id: session.id.clone(),
+        players: session.players.values().cloned().collect(),
+        current_player_id: session.current_player_id.clone().unwrap_or_default(),
+        state: session.state,
+        board_state: session.board_state.clone(),
+        turn_number: session.turn_number,
+    }
+}
+
+fn generate_session_code() -> String {
+    use rand::Rng;
+    let mut rng = rand::rng();
+    let chars: Vec<char> = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".chars().collect();
+
+    (0..6)
+        .map(|_| chars[rng.random_range(0..chars.len())])
+        .collect()
+}
+
+// ============================================================================
+// FONCTIONS DE STORE - OPÉRATIONS ASYNCHRONES COMPOSABLES
+// ============================================================================
+
+pub async fn create_session_in_store<F, T>(
+    store: &Arc<RwLock<SessionStoreState>>,
+    max_players: i32,
+    game_mode: String,
+    continuation: F
+) -> Result<T, String>
+where
+    F: FnOnce(String) -> Result<T, String>,
+{
+    let (action, session_code) = create_session_action(max_players, game_mode);
+
+    {
+        let mut state = store.write().await;
+        *state = apply_session_action(state.clone(), action);
+    }
+
+    continuation(session_code)
+}
+
+pub async fn get_session_by_code_from_store(
+    store: &Arc<RwLock<SessionStoreState>>,
+    code: &str
+) -> Option<GameSession> {
+    let state = store.read().await;
+    find_session_by_code(&*state, code).cloned()
+}
+
+pub async fn get_session_by_id_from_store(
+    store: &Arc<RwLock<SessionStoreState>>,
+    session_id: &str
+) -> Option<GameSession> {
+    let state = store.read().await;
+    find_session_by_id(&*state, session_id).cloned()
+}
+
+pub async fn update_session_in_store(
+    store: &Arc<RwLock<SessionStoreState>>,
+    session: GameSession
+) -> Result<(), String> {
+    let action = SessionAction::UpdateSession { session };
+
+    {
+        let mut state = store.write().await;
+        *state = apply_session_action(state.clone(), action);
+    }
+
+    Ok(())
+}
+
+pub async fn transform_session_in_store<F, T>(
+    store: &Arc<RwLock<SessionStoreState>>,
+    session_id: &str,
+    transformation: F
+) -> Result<Option<T>, String>
+where
+    F: FnOnce(GameSession) -> Result<(GameSession, T), String>,
+{
+    let current_session = get_session_by_id_from_store(store, session_id).await;
+
+    match current_session {
+        Some(session) => {
+            match transformation(session) {
+                Ok((updated_session, result)) => {
+                    update_session_in_store(store, updated_session).await?;
+                    Ok(Some(result))
+                },
+                Err(e) => Err(e)
+            }
+        },
+        None => Ok(None)
+    }
+}
+
+pub async fn query_store<F, T>(
+    store: &Arc<RwLock<SessionStoreState>>,
+    query: F
+) -> T
+where
+    F: FnOnce(&SessionStoreState) -> T,
+{
+    let state = store.read().await;
+    query(&*state)
+}
+
+// ============================================================================
+// FONCTIONS DE NIVEAU SUPÉRIEUR - COMPOSITION AVEC SESSIONMANAGER
+// ============================================================================
+
+pub async fn create_session_with_manager(
+    manager: &SessionManager,
+    max_players: i32,
+    game_mode: String
+) -> String {
+    create_session_in_store(get_store_from_manager(manager), max_players, game_mode, |code| Ok(code)).await
+        .unwrap_or_else(|_| "ERROR".to_string())
+}
+
+pub async fn get_session_by_code_with_manager(
+    manager: &SessionManager,
+    code: &str
+) -> Option<GameSession> {
+    get_session_by_code_from_store(get_store_from_manager(manager), code).await
+}
+
+pub async fn get_session_by_id_with_manager(
+    manager: &SessionManager,
+    session_id: &str
+) -> Option<GameSession> {
+    get_session_by_id_from_store(get_store_from_manager(manager), session_id).await
+}
+
+pub async fn update_session_with_manager(
+    manager: &SessionManager,
+    session: GameSession
+) -> Result<(), String> {
+    update_session_in_store(get_store_from_manager(manager), session).await
+}
+
+pub async fn create_session_functional_with_manager(
+    manager: &SessionManager,
+    max_players: i32,
+    game_mode: String
+) -> Result<String, String> {
+    create_session_in_store(get_store_from_manager(manager), max_players, game_mode, |code| Ok(code)).await
+}
+
+pub async fn transform_session_with_manager<F>(
+    manager: &SessionManager,
+    session_id: &str,
+    f: F
+) -> Result<Option<GameSession>, String>
+where
+    F: FnOnce(GameSession) -> Result<GameSession, String>,
+{
+    transform_session_in_store(get_store_from_manager(manager), session_id, |session| {
+        f(session).map(|updated_session| (updated_session.clone(), updated_session))
+    }).await
+}
+
+pub async fn with_session_state_from_manager<F, T>(
+    manager: &SessionManager,
+    f: F
+) -> T
+where
+    F: FnOnce(&SessionStoreState) -> T,
+{
+    query_store(get_store_from_manager(manager), f).await
+}
+
+// ============================================================================
+// IMPLÉMENTATION VIDE - SESSIONMANAGER DEVIENT JUSTE UNE STRUCTURE
+// ============================================================================
+
+impl SessionManager {
+    // Seule fonction dans l'impl - construction
+    pub fn new() -> Self {
+        new_session_manager()
+    }
+
+    // Toutes les autres fonctions sont maintenant externes !
+    // Utilisez les fonctions *_with_manager() à la place
+}
+
diff --git a/src/services/session_manager_integration_test.rs b/src/services/session_manager_integration_test.rs
index e69de29..2e054c4 100644
--- a/src/services/session_manager_integration_test.rs
+++ b/src/services/session_manager_integration_test.rs
@@ -0,0 +1,240 @@
+// tests/session_manager_integration_test.rs
+// Premier test d'intégration pour session_manager
+
+use std::sync::Arc;
+use crate::services::session_manager::*;
+use crate::generated::takeiteasygame::v1::Player;
+
+#[cfg(test)]
+mod session_manager_basic_integration {
+    use super::*;
+
+    #[tokio::test]
+    async fn test_complete_session_workflow() {
+        // 🏗️ ÉTAPE 1: Créer le manager
+        let manager = new_session_manager();
+
+        // 🏗️ ÉTAPE 2: Créer une session
+        let session_code = create_session_with_manager(&manager, 4, "classic".to_string()).await;
+
+        // ✅ Vérifier que la session existe
+        assert!(!session_code.is_empty());
+        assert_ne!(session_code, "ERROR");
+
+        // 🏗️ ÉTAPE 3: Récupérer la session créée
+        let session = get_session_by_code_with_manager(&manager, &session_code).await;
+        assert!(session.is_some());
+
+        let mut session = session.unwrap();
+        let session_id = session.id.clone();
+
+        // ✅ Vérifier les propriétés initiales
+        assert_eq!(session.code, session_code);
+        assert_eq!(session.max_players, 4);
+        assert_eq!(session.game_mode, "classic");
+        assert_eq!(session.players.len(), 0);
+        assert_eq!(session.state, 0); // WAITING
+
+        // 🏗️ ÉTAPE 4: Ajouter le premier joueur (Alice)
+        let result = add_player_to_session(session.clone(), "Alice".to_string());
+        assert!(result.is_ok());
+
+        let (session_with_alice, alice_id) = result.unwrap();
+
+        // ✅ Vérifier Alice
+        assert_eq!(session_with_alice.players.len(), 1);
+        assert!(session_with_alice.players.contains_key(&alice_id));
+
+        let alice = &session_with_alice.players[&alice_id];
+        assert_eq!(alice.name, "Alice");
+        assert!(alice.is_ready); // Premier joueur auto-ready
+        assert!(alice.is_connected);
+
+        // 🏗️ ÉTAPE 5: Sauvegarder la session mise à jour
+        let update_result = update_session_with_manager(&manager, session_with_alice.clone()).await;
+        assert!(update_result.is_ok());
+
+        // 🏗️ ÉTAPE 6: Ajouter un second joueur (Bob)
+        let transform_result = transform_session_with_manager(&manager, &session_id, |session| {
+            add_player_to_session(session, "Bob".to_string())
+                .map(|(updated_session, _player_id)| updated_session)
+        }).await;
+
+        assert!(transform_result.is_ok());
+        assert!(transform_result.unwrap().is_some());
+
+        // 🏗️ ÉTAPE 7: Récupérer l'état final et vérifier
+        let final_session = get_session_by_id_with_manager(&manager, &session_id).await;
+        assert!(final_session.is_some());
+
+        let final_session = final_session.unwrap();
+        assert_eq!(final_session.players.len(), 2);
+
+        // ✅ Vérifier que les deux joueurs sont présents
+        let alice_exists = final_session.players.values().any(|p| p.name == "Alice" && p.is_ready);
+        let bob_exists = final_session.players.values().any(|p| p.name == "Bob" && !p.is_ready);
+
+        assert!(alice_exists, "Alice should exist and be ready");
+        assert!(bob_exists, "Bob should exist and not be ready initially");
+
+        println!("✅ Session workflow test completed successfully!");
+    }
+
+    #[tokio::test]
+    async fn test_player_ready_triggers_game_start() {
+        // 🏗️ Setup: Créer session avec 2 joueurs
+        let manager = new_session_manager();
+        let session_code = create_session_with_manager(&manager, 4, "classic".to_string()).await;
+        let session = get_session_by_code_with_manager(&manager, &session_code).await.unwrap();
+        let session_id = session.id.clone();
+
+        // Ajouter Alice (auto-ready)
+        let (session_with_alice, alice_id) = add_player_to_session(session, "Alice".to_string()).unwrap();
+        update_session_with_manager(&manager, session_with_alice).await.unwrap();
+
+        // Ajouter Bob
+        let _transform_result = transform_session_with_manager(&manager, &session_id, |session| {
+            add_player_to_session(session, "Bob".to_string())
+                .map(|(updated_session, _player_id)| updated_session)
+        }).await.unwrap().unwrap();
+
+        // Récupérer l'ID de Bob depuis la session mise à jour
+        let session_with_bob = get_session_by_id_with_manager(&manager, &session_id).await.unwrap();
+        let bob_id = session_with_bob.players.values()
+            .find(|p| p.name == "Bob")
+            .unwrap()
+            .id.clone();
+
+        // 🏗️ ÉTAPE CRITIQUE: Bob se met ready
+        let store = get_store_from_manager(&manager);
+        let ready_result = transform_session_in_store(store, &session_id, |session| {
+            set_player_ready_in_session(session, &bob_id, true)
+        }).await;
+
+        assert!(ready_result.is_ok());
+        let session_result = ready_result.unwrap();
+        assert!(session_result.is_some());
+        let game_started = session_result.unwrap();
+
+        // ✅ VÉRIFICATION: Le jeu doit avoir démarré
+        assert!(game_started, "Game should start when both players are ready");
+
+        // Vérifier l'état final de la session
+        let final_session = get_session_by_id_with_manager(&manager, &session_id).await.unwrap();
+        assert_eq!(final_session.state, 1); // IN_PROGRESS
+        assert!(final_session.current_player_id.is_some());
+        assert_eq!(final_session.turn_number, 1);
+
+        println!("✅ Game start trigger test completed successfully!");
+    }
+
+    #[tokio::test]
+    async fn test_session_not_found_scenarios() {
+        let manager = new_session_manager();
+
+        // Test avec un ID inexistant
+        let result = get_session_by_id_with_manager(&manager, "inexistant_id").await;
+        assert!(result.is_none());
+
+        // Test avec un code inexistant
+        let result = get_session_by_code_with_manager(&manager, "NOCODE").await;
+        assert!(result.is_none());
+
+        // Test de transformation sur session inexistante
+        let transform_result = transform_session_with_manager(&manager, "fake_id", |session| {
+            Ok(session) // Cette fonction ne devrait jamais être appelée
+        }).await;
+
+        assert!(transform_result.is_ok());
+        assert!(transform_result.unwrap().is_none()); // None car session n'existe pas
+
+        println!("✅ Session not found scenarios test completed!");
+    }
+
+    #[tokio::test]
+    async fn test_session_full_error() {
+        let manager = new_session_manager();
+
+        // Créer une session avec limite de 2 joueurs
+        let session_code = create_session_with_manager(&manager, 2, "classic".to_string()).await;
+        let session = get_session_by_code_with_manager(&manager, &session_code).await.unwrap();
+
+        // Ajouter 2 joueurs (limite atteinte)
+        let (session1, _) = add_player_to_session(session, "Alice".to_string()).unwrap();
+        let (session2, _) = add_player_to_session(session1, "Bob".to_string()).unwrap();
+
+        // Essayer d'ajouter un 3ème joueur
+        let result = add_player_to_session(session2, "Charlie".to_string());
+
+        // ✅ Doit échouer avec SESSION_FULL
+        assert!(result.is_err());
+        assert_eq!(result.unwrap_err(), "SESSION_FULL");
+
+        println!("✅ Session full error test completed!");
+    }
+
+    #[tokio::test]
+    async fn test_concurrent_operations() {
+        let manager = Arc::new(new_session_manager());
+        let session_code = create_session_with_manager(&manager, 10, "test".to_string()).await;
+        let session = get_session_by_code_with_manager(&manager, &session_code).await.unwrap();
+        let session_id = session.id.clone();
+
+        // Lancer 5 opérations concurrentes d'ajout de joueurs
+        let mut handles = vec![];
+
+        for i in 0..5 {
+            let manager_clone = manager.clone();
+            let session_id_clone = session_id.clone();
+
+            let handle = tokio::spawn(async move {
+                transform_session_with_manager(&manager_clone, &session_id_clone, |session| {
+                    add_player_to_session(session, format!("Player{}", i))
+                        .map(|(updated_session, _)| updated_session)
+                }).await
+            });
+
+            handles.push(handle);
+        }
+
+        // Attendre que toutes les opérations se terminent
+        let results = futures::future::join_all(handles).await;
+
+        // Vérifier que toutes ont réussi
+        for (i, result) in results.iter().enumerate() {
+            assert!(result.is_ok(), "Task {} failed", i);
+            assert!(result.as_ref().unwrap().is_ok(), "Transform {} failed", i);
+        }
+
+        // Vérifier l'état final
+        let final_session = get_session_by_id_with_manager(&manager, &session_id).await.unwrap();
+        assert_eq!(final_session.players.len(), 5);
+
+        println!("✅ Concurrent operations test completed! Added {} players", final_session.players.len());
+    }
+}
+
+// ============================================================================
+// HELPER POUR LANCER CE TEST
+// ============================================================================
+
+#[cfg(test)]
+mod test_runner {
+    use super::*;
+
+    #[tokio::test]
+    async fn run_session_manager_integration_tests() {
+        println!("🚀 Running Session Manager Integration Tests");
+        println!("===========================================");
+
+        // Ce test sert de point d'entrée documenté
+        // Les vrais tests sont dans le module session_manager_basic_integration
+
+        // Test simple pour vérifier que l'infrastructure fonctionne
+        let manager = new_session_manager();
+        let session_code = create_session_with_manager(&manager, 4, "test".to_string()).await;
+        assert!(!session_code.is_empty());
+
+        println!("✅ Session Manager integration tests infrastructure OK!");
+    }
+}
\ No newline at end of file
diff --git a/src/services/session_service.rs b/src/services/session_service.rs
index e69de29..9c3b03a 100644
--- a/src/services/session_service.rs
+++ b/src/services/session_service.rs
@@ -0,0 +1,420 @@
+// src/services/session_service.rs - Version avec debugging amélioré
+
+use tonic::{Request, Response, Status};
+use std::sync::Arc;
+use crate::generated::takeiteasygame::v1::{
+    GetSessionStateRequest,
+    GetSessionStateResponse,
+    SessionState as ProtoSessionState
+};
+// Import des types générés par tonic
+use crate::generated::takeiteasygame::v1::*;
+use crate::generated::takeiteasygame::v1::session_service_server::SessionService;
+
+use crate::services::session_manager::{SessionManager, new_session_manager, get_store_from_manager, add_player_to_session, set_player_ready_in_session, session_to_game_state, transform_session_in_store, get_session_by_code_with_manager, update_session_with_manager, create_session_functional_with_manager, get_session_by_id_with_manager};
+
+#[derive(Clone)]
+pub struct SessionServiceImpl {
+    session_manager: Arc<SessionManager>,
+}
+
+impl SessionServiceImpl {
+    pub fn new() -> Self {
+        Self {
+            session_manager: Arc::new(new_session_manager()), // Fonction extraite !
+        }
+    }
+    pub fn new_with_manager(session_manager: Arc<SessionManager>) -> Self {
+        Self {
+            session_manager,
+        }
+    }
+    
+}
+
+// ============================================================================
+// FONCTIONS PURES - CRÉATION DE RÉPONSES (inchangées)
+// ============================================================================
+
+fn create_success_response(
+    session_code: String,
+    session_id: String,
+    player_id: String,
+    player: Player
+) -> CreateSessionResponse {
+    CreateSessionResponse {
+        result: Some(create_session_response::Result::Success(
+            CreateSessionSuccess {
+                session_code,
+                session_id,
+                player_id,
+                player: Some(player),
+            }
+        )),
+    }
+}
+
+fn create_error_response(code: String, message: String) -> CreateSessionResponse {
+    CreateSessionResponse {
+        result: Some(create_session_response::Result::Error(Error {
+            code,
+            message,
+            details: std::collections::HashMap::new(),
+        })),
+    }
+}
+
+fn join_success_response(
+    session_id: String,
+    player_id: String,
+    game_state: GameState
+) -> JoinSessionResponse {
+    JoinSessionResponse {
+        result: Some(join_session_response::Result::Success(
+            JoinSessionSuccess {
+                session_id,
+                player_id,
+                game_state: Some(game_state),
+            }
+        )),
+    }
+}
+
+fn join_error_response(code: String, message: String) -> JoinSessionResponse {
+    JoinSessionResponse {
+        result: Some(join_session_response::Result::Error(Error {
+            code,
+            message,
+            details: std::collections::HashMap::new(),
+        })),
+    }
+}
+
+fn set_ready_success_response(game_started: bool) -> SetReadyResponse {
+    SetReadyResponse {
+        success: true,
+        error: None,
+        game_started,
+    }
+}
+
+fn set_ready_error_response(code: String, message: String) -> SetReadyResponse {
+    SetReadyResponse {
+        success: false,
+        error: Some(Error {
+            code,
+            message,
+            details: std::collections::HashMap::new(),
+        }),
+        game_started: false,
+    }
+}
+
+// ============================================================================
+// FONCTIONS COMPOSABLES - LOGIQUE MÉTIER AVEC DEBUG AMÉLIORÉ
+// ============================================================================
+
+// session_service.rs - dans create_session_logic_with_manager
+async fn create_session_logic_with_manager(
+    manager: &SessionManager,
+    player_name: String,
+    max_players: i32,
+    game_mode: String
+) -> Result<Response<CreateSessionResponse>, Status> {
+    match create_session_functional_with_manager(manager, max_players, game_mode).await {
+        Ok(session_code) => {
+            if let Some(mut session) = get_session_by_code_with_manager(manager, &session_code).await {
+                // Ajouter le joueur humain
+                match add_player_to_session(session.clone(), player_name.clone()) {
+                    Ok((mut updated_session, player_id)) => {
+
+                        // 🤖 AJOUTER AUTOMATIQUEMENT MCTS À CHAQUE SESSION
+                        let mcts_player = Player {
+                            id: "mcts_ai".to_string(),
+                            name: "🤖 MCTS IA".to_string(),
+                            score: 0,
+                            is_ready: true,  // MCTS toujours prêt
+                            is_connected: true,
+                            joined_at: chrono::Utc::now().timestamp(),
+                        };
+
+                        updated_session.players.insert("mcts_ai".to_string(), mcts_player);
+                        let player = updated_session.players.get(&player_id).cloned()
+                            .ok_or_else(|| Status::internal("Player not found after creation"))?;
+
+                        let session_id = updated_session.id.clone();
+
+                        // Sauvegarder avec MCTS
+                        update_session_with_manager(manager, updated_session).await
+                            .map_err(|e| Status::internal(e))?;
+
+                        let response = create_success_response(session_code, session_id, player_id, player);
+                        Ok(Response::new(response))
+                    },
+                    Err(e) => {
+                        log::error!("❌ Échec ajout joueur: {}", e);
+                        let response = create_error_response(e, "Failed to add player to session".to_string());
+                        Ok(Response::new(response))
+                    }
+                }
+            } else {
+                log::error!("❌ Session introuvable après création: {}", session_code);
+                Err(Status::internal("Failed to retrieve created session"))
+            }
+        },
+        Err(e) => {
+            log::error!("❌ Échec création session: {}", e);
+            let response = create_error_response(
+                "CREATION_FAILED".to_string(),
+                "Failed to create session".to_string()
+            );
+            Ok(Response::new(response))
+        }
+    }
+}
+
+// session_service.rs - dans join_session_logic
+async fn join_session_logic(
+    manager: &SessionManager,
+    session_code: String,
+    player_name: String
+) -> Result<Response<JoinSessionResponse>, Status> {
+    let session = match get_session_by_code_with_manager(manager, &session_code).await {
+        Some(session) => {            session
+        },
+        None => {
+            log::error!("❌ Session introuvable avec code: {}", session_code);
+            return Ok(Response::new(join_error_response(
+                "SESSION_NOT_FOUND".to_string(),
+                format!("Session with code {} not found", session_code)
+            )));
+        }
+    };
+
+    // 🔧 NOUVEAU: Gestion spéciale pour les viewers
+    if player_name.contains("Viewer") || player_name.contains("Observer") {
+        // Créer un joueur viewer (read-only)
+        let viewer_id = format!("viewer_{}", uuid::Uuid::new_v4().to_string()[0..8].to_string());
+        let viewer_player = Player {
+            id: viewer_id.clone(),
+            name: player_name.clone(),
+            score: 0,
+            is_ready: true,  // Toujours prêt (n'affecte pas le jeu)
+            is_connected: true,
+            joined_at: chrono::Utc::now().timestamp(),
+        };
+
+        // 🔧 NE PAS ajouter le viewer à la session (juste retourner l'état)
+        let session_id = session.id.clone();
+        let game_state = session_to_game_state(&session);
+        let response = join_success_response(session_id, viewer_id, game_state);
+        return Ok(Response::new(response));
+    }
+
+    match add_player_to_session(session, player_name.clone()) {
+        Ok((mut updated_session, player_id)) => {
+
+            // 🤖 VÉRIFIER SI MCTS EST DÉJÀ PRÉSENT, SINON L'AJOUTER
+            if !updated_session.players.contains_key("mcts_ai") {
+                let mcts_player = Player {
+                    id: "mcts_ai".to_string(),
+                    name: "🤖 MCTS IA".to_string(),
+                    score: 0,
+                    is_ready: true,
+                    is_connected: true,
+                    joined_at: chrono::Utc::now().timestamp(),
+                };
+
+                updated_session.players.insert("mcts_ai".to_string(), mcts_player);            } else {            }
+
+            let session_id = updated_session.id.clone();
+            let game_state = session_to_game_state(&updated_session);
+            update_session_with_manager(manager, updated_session).await
+                .map_err(|e| Status::internal(e))?;
+
+            let response = join_success_response(session_id, player_id, game_state);
+            Ok(Response::new(response))
+        },
+        Err(e) => {
+            log::error!("❌ Échec join session: {}", e);
+            let response = join_error_response(e, "Failed to join session".to_string());
+            Ok(Response::new(response))
+        }
+    }
+}
+
+// 🔧 FONCTION SET_READY AVEC DEBUG ULTRA-DÉTAILLÉ
+async fn set_ready_logic(
+    manager: &SessionManager,
+    session_id: String,
+    player_id: String,
+    ready: bool
+) -> Result<Response<SetReadyResponse>, Status> {
+    // 🔍 Étape 1: Vérifier l'existence de la session AVANT transform
+    match get_session_by_id_with_manager(manager, &session_id).await {
+        Some(session) => {
+            // Vérifier si le joueur existe
+            if let Some(player) = session.players.get(&player_id) {            } else {
+                log::error!("❌ Joueur {} introuvable dans session {}", player_id, session_id);
+                return Ok(Response::new(set_ready_error_response(
+                    "PLAYER_NOT_FOUND".to_string(),
+                    format!("Player {} not found in session {}", player_id, session_id)
+                )));
+            }
+        },
+        None => {
+            log::error!("❌ Session {} introuvable lors de SET_READY", session_id);
+
+            // 🔍 Debug: Lister toutes les sessions existantes
+            let store = get_store_from_manager(manager);
+            let state = store.read().await;
+            log::error!("🔍 Sessions existantes ({} total):", state.sessions.len());
+            for (sid, session) in &state.sessions {
+                log::error!("  - id={}, code={}, players={}", sid, session.code, session.players.len());
+            }
+            drop(state);
+
+            return Ok(Response::new(set_ready_error_response(
+                "SESSION_NOT_FOUND".to_string(),
+                format!("Session {} not found", session_id)
+            )));
+        }
+    }
+
+    // 🔧 Étape 2: Continuer avec la logique normale
+    let store = get_store_from_manager(manager);
+
+    // Utilisation directe de transform_session_in_store pour récupérer game_started
+    let result = transform_session_in_store(store, &session_id, |session| {        set_player_ready_in_session(session, &player_id, ready)
+    }).await;
+
+    match result {
+        Ok(Some(game_started)) => {            Ok(Response::new(set_ready_success_response(game_started)))
+        },
+        Ok(None) => {
+            log::error!("❌ Session {} disparue pendant transform", session_id);
+            Ok(Response::new(set_ready_error_response(
+                "SESSION_NOT_FOUND".to_string(),
+                "Session not found during update".to_string()
+            )))
+        },
+        Err(error_code) => {
+            log::error!("❌ Erreur pendant SET_READY: {}", error_code);
+            Ok(Response::new(set_ready_error_response(
+                error_code,
+                "Failed to set ready status".to_string()
+            )))
+        }
+    }
+}
+
+// ============================================================================
+// IMPLÉMENTATION GRPC - TRAIT GÉNÉRÉ PAR TONIC (inchangé)
+// ============================================================================
+
+#[tonic::async_trait]
+impl SessionService for SessionServiceImpl {
+    async fn create_session(
+        &self,
+        request: Request<CreateSessionRequest>,
+    ) -> Result<Response<CreateSessionResponse>, Status> {
+        let req = request.into_inner();
+        create_session_logic_with_manager(
+            &self.session_manager,
+            req.player_name,
+            req.max_players,
+            req.game_mode
+        ).await
+    }
+
+    async fn join_session(
+        &self,
+        request: Request<JoinSessionRequest>,
+    ) -> Result<Response<JoinSessionResponse>, Status> {
+        let req = request.into_inner();
+        join_session_logic(
+            &self.session_manager,
+            req.session_code,
+            req.player_name
+        ).await
+    }
+
+    async fn set_ready(
+        &self,
+        request: Request<SetReadyRequest>,
+    ) -> Result<Response<SetReadyResponse>, Status> {
+        let req = request.into_inner();
+        set_ready_logic(
+            &self.session_manager,
+            req.session_id,
+            req.player_id,
+            req.ready
+        ).await
+    }
+
+    // 🔍 GET_SESSION_STATE AVEC DEBUG AMÉLIORÉ
+    async fn get_session_state(
+        &self,
+        request: Request<GetSessionStateRequest>,
+    ) -> Result<Response<GetSessionStateResponse>, Status> {
+        let req = request.into_inner();
+        // Utiliser votre fonction fonctionnelle get_session_by_id_with_manager
+        match get_session_by_id_with_manager(&self.session_manager, &req.session_id).await {
+            Some(session) => {
+                // Convertir votre GameSession en GameState proto
+                let proto_players: Vec<crate::generated::takeiteasygame::v1::Player> =
+                    session.players.values().map(|p| {
+                        crate::generated::takeiteasygame::v1::Player {
+                            id: p.id.clone(),
+                            name: p.name.clone(),
+                            score: p.score,
+                            is_ready: p.is_ready,
+                            is_connected: p.is_connected,
+                            joined_at: p.joined_at,
+                        }
+                    }).collect();
+
+                let game_state = crate::generated::takeiteasygame::v1::GameState {
+                    session_id: session.id.clone(),
+                    players: proto_players,
+                    current_player_id: session.current_player_id.clone().unwrap_or_default(),
+                    state: match session.state {
+                        0 => ProtoSessionState::Waiting as i32,
+                        1 => ProtoSessionState::InProgress as i32,
+                        2 => ProtoSessionState::Finished as i32,
+                        _ => ProtoSessionState::Waiting as i32,
+                    },
+                    board_state: session.board_state.clone(),
+                    turn_number: session.turn_number,
+                };
+
+                Ok(Response::new(GetSessionStateResponse {
+                    game_state: Some(game_state),
+                    error: None,
+                }))
+            }
+            None => {
+                log::error!("❌ GET_SESSION_STATE: Session {} introuvable", req.session_id);
+
+                // 🔍 Debug: Lister toutes les sessions existantes
+                let store = get_store_from_manager(&self.session_manager);
+                let state = store.read().await;
+                log::error!("🔍 Sessions existantes ({} total):", state.sessions.len());
+                for (sid, session) in &state.sessions {
+                    log::error!("  - id={}, code={}", sid, session.code);
+                }
+                drop(state);
+
+                // Session non trouvée
+                Ok(Response::new(GetSessionStateResponse {
+                    game_state: None,
+                    error: Some(crate::generated::takeiteasygame::v1::Error {
+                        code: "SESSION_NOT_FOUND".to_string(),
+                        message: format!("Session {} not found", req.session_id),
+                        details: std::collections::HashMap::new(),
+                    }),
+                }))
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/training/evaluator.rs b/src/training/evaluator.rs
index 052208b..98ec549 100644
--- a/src/training/evaluator.rs
+++ b/src/training/evaluator.rs
@@ -7,9 +7,7 @@ use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
 use crate::neural::policy_value_net::{PolicyNet, ValueNet};
 use crate::scoring::scoring::result;
 
-pub async fn evaluate_model(policy_net: &PolicyNet, value_net: &ValueNet, num_simulations: usize) {
-    log::info!("Evaluating model...");
-    let mut scores = Vec::new();
+pub async fn evaluate_model(policy_net: &PolicyNet, value_net: &ValueNet, num_simulations: usize) {    let mut scores = Vec::new();
 
     for _ in 0..10 {
         let mut deck = create_deck();
@@ -39,7 +37,5 @@ pub async fn evaluate_model(policy_net: &PolicyNet, value_net: &ValueNet, num_si
         scores.push(game_score);
     }
 
-    let avg_score: f64 = scores.iter().copied().sum::<i32>() as f64 / scores.len() as f64;
-    log::info!("Model Evaluation Complete. Avg Score: {:.2}", avg_score);
-    // **Stop ping task**
+    let avg_score: f64 = scores.iter().copied().sum::<i32>() as f64 / scores.len() as f64;    // **Stop ping task**
 }
\ No newline at end of file
diff --git a/src/training/session.rs b/src/training/session.rs
index 63d48a6..9a15a2c 100644
--- a/src/training/session.rs
+++ b/src/training/session.rs
@@ -50,16 +50,6 @@ pub async fn train_and_evaluate(
         let evaluation_interval_average = 10;
 
         while games_played < num_games {
-            log::info!(
-                "Starting training iteration {}/{}...",
-                games_played + 1,
-                num_games
-            );
-            log::info!(
-                "\n🚀 Starting Batch {}",
-                games_played / evaluation_interval + 1
-            );
-
             let mut batch_games_played = 0; // Tracks games processed in this evaluation interval
             let max_memory_size = 1000; // Store last 500 games
 
@@ -198,10 +188,7 @@ pub async fn train_and_evaluate(
                         optimizer_policy,
                         optimizer_value,
                     );
-                }
-
-                log::info!("Game {} finished with score: {}", game + 1, final_score);
-                scores.push(final_score);
+                }                scores.push(final_score);
 
                 // Update batch-specific counters
                 batch_games_played += 1;
@@ -209,14 +196,6 @@ pub async fn train_and_evaluate(
 
                 if game % evaluation_interval_average == 0 && game != 0 {
                     let moyenne: f64 = scores.iter().sum::<i32>() as f64 / scores.len() as f64;
-                    log::info!(
-                        "📊 [Batch {}] Avg Score: {:.2} | Games Played: {}",
-                        games_played / evaluation_interval,
-                        moyenne,
-                        games_played
-                    );
-                    log::info!("batch {} - Score moyen: {:.2}", game, moyenne);
-
                     // 🔄 REMPLACEMENT: write.send().await.unwrap() → send_websocket_message()
                     let result_message = format!("GAME_RESULT:{}", moyenne);
                     if let Err(e) = send_websocket_message(
@@ -263,16 +242,9 @@ pub async fn train_and_evaluate(
             // Evaluate model after each interval
             evaluate_model(policy_net, value_net, num_simulations).await;
 
-            log::info!(
-                "Games Played: {}, Total Score: {}, Avg Score: {:.2}",
-                games_played,
-                total_score,
-                total_score as f32 / games_played as f32
-            );
+         
             let model_path = "model_weights";
             // Save model weights
-            log::info!("Saving models to {}", model_path);
-            log::info!("Saving model weights...");
             if let Err(e) = policy_net.save_model(vs_policy, "model_weights/policy/policy.params") {
                 log::error!("Error saving PolicyNet weights: {:?}", e);
             }
diff --git a/src/training/websocket.rs b/src/training/websocket.rs
index 3ca151d..a1a4380 100644
--- a/src/training/websocket.rs
+++ b/src/training/websocket.rs
@@ -8,9 +8,7 @@ pub async fn reconnect_websocket(
     listener: &TcpListener,
 ) -> Option<SplitSink<WebSocketStream<tokio::net::TcpStream>, Message>> {
     match listener.accept().await {
-        Ok((stream, _)) => {
-            log::info!("Re-establishing WebSocket connection...");
-            let ws_stream = accept_async(stream)
+        Ok((stream, _)) => {            let ws_stream = accept_async(stream)
                 .await
                 .expect("Failed to accept WebSocket");
             let (write, _) = ws_stream.split();
