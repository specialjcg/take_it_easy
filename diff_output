diff --git a/Cargo.lock b/Cargo.lock
index adc29ae..feeded5 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -107,12 +107,90 @@ version = "1.0.95"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "34ac096ce696dc2fcabef30516bb13c0a68a11d30131d3df6f04711467681b04"
 
+[[package]]
+name = "async-stream"
+version = "0.3.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b5a71a6f37880a80d1d7f19efd781e4b5de42c88f0722cc13bcb6cc2cfe8476"
+dependencies = [
+ "async-stream-impl",
+ "futures-core",
+ "pin-project-lite",
+]
+
+[[package]]
+name = "async-stream-impl"
+version = "0.3.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c7c24de15d275a1ecfd47a380fb4d5ec9bfe0933f309ed5e705b775596a3574d"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "async-trait"
+version = "0.1.88"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e539d3fca749fcee5236ab05e93a52867dd549cc157c8cb7f99595f3cedffdb5"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
 [[package]]
 name = "autocfg"
 version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"
 
+[[package]]
+name = "axum"
+version = "0.6.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b829e4e32b91e643de6eafe82b1d90675f5874230191a4ffbc1b336dec4d6bf"
+dependencies = [
+ "async-trait",
+ "axum-core",
+ "bitflags 1.3.2",
+ "bytes",
+ "futures-util",
+ "http 0.2.12",
+ "http-body",
+ "hyper",
+ "itoa",
+ "matchit",
+ "memchr",
+ "mime",
+ "percent-encoding",
+ "pin-project-lite",
+ "rustversion",
+ "serde",
+ "sync_wrapper",
+ "tower",
+ "tower-layer",
+ "tower-service",
+]
+
+[[package]]
+name = "axum-core"
+version = "0.3.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "759fa577a247914fd3f7f76d62972792636412fbfd634cd452f6a385a74d2d2c"
+dependencies = [
+ "async-trait",
+ "bytes",
+ "futures-util",
+ "http 0.2.12",
+ "http-body",
+ "mime",
+ "rustversion",
+ "tower-layer",
+ "tower-service",
+]
+
 [[package]]
 name = "backtrace"
 version = "0.3.74"
@@ -128,12 +206,24 @@ dependencies = [
  "windows-targets",
 ]
 
+[[package]]
+name = "base64"
+version = "0.21.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"
+
 [[package]]
 name = "base64ct"
 version = "1.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8c3c1a368f70d6cf7302d78f8f7093da241fb8e8807c05cc9e51a125895a6d5b"
 
+[[package]]
+name = "bitflags"
+version = "1.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
+
 [[package]]
 name = "bitflags"
 version = "2.6.0"
@@ -346,6 +436,19 @@ dependencies = [
  "typenum",
 ]
 
+[[package]]
+name = "dashmap"
+version = "5.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "978747c1d849a7d2ee5e8adc0159961c48fb7e5db2f06af6723b80123bb53856"
+dependencies = [
+ "cfg-if",
+ "hashbrown 0.14.5",
+ "lock_api",
+ "once_cell",
+ "parking_lot_core",
+]
+
 [[package]]
 name = "data-encoding"
 version = "2.6.0"
@@ -378,6 +481,12 @@ version = "1.13.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"
 
+[[package]]
+name = "equivalent"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"
+
 [[package]]
 name = "flate2"
 version = "1.0.35"
@@ -407,12 +516,54 @@ version = "1.0.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
 
+[[package]]
+name = "futures"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
+dependencies = [
+ "futures-channel",
+ "futures-core",
+ "futures-executor",
+ "futures-io",
+ "futures-sink",
+ "futures-task",
+ "futures-util",
+]
+
+[[package]]
+name = "futures-channel"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
+dependencies = [
+ "futures-core",
+ "futures-sink",
+]
+
 [[package]]
 name = "futures-core"
 version = "0.3.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"
 
+[[package]]
+name = "futures-executor"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
+dependencies = [
+ "futures-core",
+ "futures-task",
+ "futures-util",
+]
+
+[[package]]
+name = "futures-io"
+version = "0.3.31"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"
+
 [[package]]
 name = "futures-macro"
 version = "0.3.31"
@@ -442,10 +593,13 @@ version = "0.3.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
 dependencies = [
+ "futures-channel",
  "futures-core",
+ "futures-io",
  "futures-macro",
  "futures-sink",
  "futures-task",
+ "memchr",
  "pin-project-lite",
  "pin-utils",
  "slab",
@@ -490,6 +644,25 @@ version = "0.31.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"
 
+[[package]]
+name = "h2"
+version = "0.3.26"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "81fe527a889e1532da5c525686d96d4c2e74cdd345badf8dfef9f6b39dd5f5e8"
+dependencies = [
+ "bytes",
+ "fnv",
+ "futures-core",
+ "futures-sink",
+ "futures-util",
+ "http 0.2.12",
+ "indexmap 2.9.0",
+ "slab",
+ "tokio",
+ "tokio-util",
+ "tracing",
+]
+
 [[package]]
 name = "half"
 version = "2.6.0"
@@ -500,6 +673,24 @@ dependencies = [
  "crunchy",
 ]
 
+[[package]]
+name = "hashbrown"
+version = "0.12.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
+
+[[package]]
+name = "hashbrown"
+version = "0.14.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
+
+[[package]]
+name = "hashbrown"
+version = "0.15.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "84b26c544d002229e640969970a2e74021aadf6e2f96372b9c58eff97de08eb3"
+
 [[package]]
 name = "heck"
 version = "0.5.0"
@@ -515,6 +706,17 @@ dependencies = [
  "digest",
 ]
 
+[[package]]
+name = "http"
+version = "0.2.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "601cbb57e577e2f5ef5be8e7b83f0f63994f25aa94d673e54a92d5c516d101f1"
+dependencies = [
+ "bytes",
+ "fnv",
+ "itoa",
+]
+
 [[package]]
 name = "http"
 version = "1.2.0"
@@ -526,12 +728,65 @@ dependencies = [
  "itoa",
 ]
 
+[[package]]
+name = "http-body"
+version = "0.4.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7ceab25649e9960c0311ea418d17bee82c0dcec1bd053b5f9a66e265a693bed2"
+dependencies = [
+ "bytes",
+ "http 0.2.12",
+ "pin-project-lite",
+]
+
 [[package]]
 name = "httparse"
 version = "1.9.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7d71d3574edd2771538b901e6549113b4006ece66150fb69c0fb6d9a2adae946"
 
+[[package]]
+name = "httpdate"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"
+
+[[package]]
+name = "hyper"
+version = "0.14.32"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "41dfc780fdec9373c01bae43289ea34c972e40ee3c9f6b3c8801a35f35586ce7"
+dependencies = [
+ "bytes",
+ "futures-channel",
+ "futures-core",
+ "futures-util",
+ "h2",
+ "http 0.2.12",
+ "http-body",
+ "httparse",
+ "httpdate",
+ "itoa",
+ "pin-project-lite",
+ "socket2",
+ "tokio",
+ "tower-service",
+ "tracing",
+ "want",
+]
+
+[[package]]
+name = "hyper-timeout"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bbb958482e8c7be4bc3cf272a766a2b0bf1a6755e7a6ae777f017a31d11b13b1"
+dependencies = [
+ "hyper",
+ "pin-project-lite",
+ "tokio",
+ "tokio-io-timeout",
+]
+
 [[package]]
 name = "iana-time-zone"
 version = "0.1.61"
@@ -555,6 +810,26 @@ dependencies = [
  "cc",
 ]
 
+[[package]]
+name = "indexmap"
+version = "1.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
+dependencies = [
+ "autocfg",
+ "hashbrown 0.12.3",
+]
+
+[[package]]
+name = "indexmap"
+version = "2.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cea70ddb795996207ad57735b50c5982d8844f38ba9ee5f1aedcfb708a2aa11e"
+dependencies = [
+ "equivalent",
+ "hashbrown 0.15.3",
+]
+
 [[package]]
 name = "inout"
 version = "0.1.3"
@@ -570,6 +845,15 @@ version = "1.70.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"
 
+[[package]]
+name = "itertools"
+version = "0.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569"
+dependencies = [
+ "either",
+]
+
 [[package]]
 name = "itoa"
 version = "1.0.14"
@@ -587,9 +871,9 @@ dependencies = [
 
 [[package]]
 name = "js-sys"
-version = "0.3.74"
+version = "0.3.77"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a865e038f7f6ed956f788f0d7d60c541fff74c7bd74272c5d4cf15c63743e705"
+checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
 dependencies = [
  "once_cell",
  "wasm-bindgen",
@@ -603,9 +887,19 @@ checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
 
 [[package]]
 name = "libc"
-version = "0.2.167"
+version = "0.2.172"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "09d6582e104315a817dff97f75133544b2e094ee22447d2acf4a74e189ba06fc"
+checksum = "d750af042f7ef4f724306de029d18836c26c1765a54a6a3f094cbd23a7267ffa"
+
+[[package]]
+name = "lock_api"
+version = "0.4.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
+dependencies = [
+ "autocfg",
+ "scopeguard",
+]
 
 [[package]]
 name = "log"
@@ -613,6 +907,12 @@ version = "0.4.22"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"
 
+[[package]]
+name = "matchit"
+version = "0.7.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0e7465ac9959cc2b1404e8e2367b43684a6d13790fe23056cc8c6c5a6b7bcb94"
+
 [[package]]
 name = "matrixmultiply"
 version = "0.3.9"
@@ -629,6 +929,12 @@ version = "2.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"
 
+[[package]]
+name = "mime"
+version = "0.3.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"
+
 [[package]]
 name = "miniz_oxide"
 version = "0.8.0"
@@ -721,6 +1027,19 @@ version = "1.20.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1261fe7e33c73b354eab43b1273a57c8f967d0391e80353e51f764ac02cf6775"
 
+[[package]]
+name = "parking_lot_core"
+version = "0.9.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
+dependencies = [
+ "cfg-if",
+ "libc",
+ "redox_syscall",
+ "smallvec",
+ "windows-targets",
+]
+
 [[package]]
 name = "password-hash"
 version = "0.4.2"
@@ -744,6 +1063,32 @@ dependencies = [
  "sha2",
 ]
 
+[[package]]
+name = "percent-encoding"
+version = "2.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"
+
+[[package]]
+name = "pin-project"
+version = "1.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "677f1add503faace112b9f1373e43e9e054bfdd22ff1a63c1bc485eaec6a6a8a"
+dependencies = [
+ "pin-project-internal",
+]
+
+[[package]]
+name = "pin-project-internal"
+version = "1.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e918e4ff8c4549eb882f14b3a4bc8c8bc93de829416eacf579f1207a8fbf861"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
 [[package]]
 name = "pin-project-lite"
 version = "0.2.15"
@@ -794,18 +1139,41 @@ dependencies = [
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.92"
+version = "1.0.95"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "37d3544b3f2748c54e147655edb5025752e2303145b5aefb3c3ea2c78b973bb0"
+checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
 dependencies = [
  "unicode-ident",
 ]
 
+[[package]]
+name = "prost"
+version = "0.12.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "deb1435c188b76130da55f17a466d252ff7b1418b2ad3e037d127b94e3411f29"
+dependencies = [
+ "bytes",
+ "prost-derive",
+]
+
+[[package]]
+name = "prost-derive"
+version = "0.12.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "81bddcdb20abf9501610992b6759a4c888aef7d1a7247ef75e2404275ac24af1"
+dependencies = [
+ "anyhow",
+ "itertools",
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
 [[package]]
 name = "quote"
-version = "1.0.37"
+version = "1.0.40"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
+checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
 dependencies = [
  "proc-macro2",
 ]
@@ -897,6 +1265,15 @@ dependencies = [
  "crossbeam-utils",
 ]
 
+[[package]]
+name = "redox_syscall"
+version = "0.5.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "928fca9cf2aa042393a8325b9ead81d2f0df4cb12e1e24cef072922ccd99c5af"
+dependencies = [
+ "bitflags 2.6.0",
+]
+
 [[package]]
 name = "regex"
 version = "1.11.1"
@@ -932,6 +1309,12 @@ version = "0.1.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"
 
+[[package]]
+name = "rustversion"
+version = "1.0.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"
+
 [[package]]
 name = "ryu"
 version = "1.0.18"
@@ -948,6 +1331,12 @@ dependencies = [
  "serde_json",
 ]
 
+[[package]]
+name = "scopeguard"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
+
 [[package]]
 name = "serde"
 version = "1.0.215"
@@ -1017,11 +1406,17 @@ dependencies = [
  "autocfg",
 ]
 
+[[package]]
+name = "smallvec"
+version = "1.15.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8917285742e9f3e1683f0a9c4e6b57960b7314d0b08d30d1ecd426713ee2eee9"
+
 [[package]]
 name = "socket2"
-version = "0.5.8"
+version = "0.5.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c970269d99b64e60ec3bd6ad27270092a5394c4e309314b18ae3fe575695fbe8"
+checksum = "e22376abed350d73dd1cd119b57ffccad95b4e585a7cda43e286245ce23c0678"
 dependencies = [
  "libc",
  "windows-sys 0.52.0",
@@ -1041,31 +1436,43 @@ checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"
 
 [[package]]
 name = "syn"
-version = "2.0.90"
+version = "2.0.101"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "919d3b74a5dd0ccd15aeb8f93e7006bd9e14c295087c9896a110f490752bcf31"
+checksum = "8ce2b7fc941b3a24138a0a7cf8e858bfc6a992e7978a068a5c760deb0ed43caf"
 dependencies = [
  "proc-macro2",
  "quote",
  "unicode-ident",
 ]
 
+[[package]]
+name = "sync_wrapper"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2047c6ded9c721764247e62cd3b03c09ffc529b2ba5b10ec482ae507a4a70160"
+
 [[package]]
 name = "take_it_easy"
 version = "0.1.0"
 dependencies = [
  "chrono",
  "clap",
+ "dashmap",
  "flexi_logger",
+ "futures",
  "futures-util",
  "log",
+ "prost",
  "rand 0.9.0",
  "rayon",
  "serde",
  "serde_json",
  "tch",
  "tokio",
+ "tokio-stream",
  "tokio-tungstenite",
+ "tonic",
+ "uuid",
 ]
 
 [[package]]
@@ -1160,6 +1567,16 @@ dependencies = [
  "windows-sys 0.52.0",
 ]
 
+[[package]]
+name = "tokio-io-timeout"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "30b74022ada614a1b4834de765f9bb43877f910cc8ce4be40e89042c9223a8bf"
+dependencies = [
+ "pin-project-lite",
+ "tokio",
+]
+
 [[package]]
 name = "tokio-macros"
 version = "2.4.0"
@@ -1171,6 +1588,17 @@ dependencies = [
  "syn",
 ]
 
+[[package]]
+name = "tokio-stream"
+version = "0.1.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "eca58d7bba4a75707817a2c44174253f9236b2d5fbd055602e9d5c07c139a047"
+dependencies = [
+ "futures-core",
+ "pin-project-lite",
+ "tokio",
+]
+
 [[package]]
 name = "tokio-tungstenite"
 version = "0.24.0"
@@ -1183,6 +1611,46 @@ dependencies = [
  "tungstenite",
 ]
 
+[[package]]
+name = "tokio-util"
+version = "0.7.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "66a539a9ad6d5d281510d5bd368c973d636c02dbf8a67300bfb6b950696ad7df"
+dependencies = [
+ "bytes",
+ "futures-core",
+ "futures-sink",
+ "pin-project-lite",
+ "tokio",
+]
+
+[[package]]
+name = "tonic"
+version = "0.10.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d560933a0de61cf715926b9cac824d4c883c2c43142f787595e48280c40a1d0e"
+dependencies = [
+ "async-stream",
+ "async-trait",
+ "axum",
+ "base64",
+ "bytes",
+ "h2",
+ "http 0.2.12",
+ "http-body",
+ "hyper",
+ "hyper-timeout",
+ "percent-encoding",
+ "pin-project",
+ "prost",
+ "tokio",
+ "tokio-stream",
+ "tower",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+]
+
 [[package]]
 name = "torch-sys"
 version = "0.19.0"
@@ -1195,6 +1663,75 @@ dependencies = [
  "zip",
 ]
 
+[[package]]
+name = "tower"
+version = "0.4.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b8fa9be0de6cf49e536ce1851f987bd21a43b771b09473c3549a6c853db37c1c"
+dependencies = [
+ "futures-core",
+ "futures-util",
+ "indexmap 1.9.3",
+ "pin-project",
+ "pin-project-lite",
+ "rand 0.8.5",
+ "slab",
+ "tokio",
+ "tokio-util",
+ "tower-layer",
+ "tower-service",
+ "tracing",
+]
+
+[[package]]
+name = "tower-layer"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"
+
+[[package]]
+name = "tower-service"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"
+
+[[package]]
+name = "tracing"
+version = "0.1.41"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
+dependencies = [
+ "pin-project-lite",
+ "tracing-attributes",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-attributes"
+version = "0.1.28"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "395ae124c09f9e6918a2310af6038fba074bcf474ac352496d5910dd59a2226d"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "tracing-core"
+version = "0.1.33"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e672c95779cf947c5311f83787af4fa8fffd12fb27e4993211a84bdfd9610f9c"
+dependencies = [
+ "once_cell",
+]
+
+[[package]]
+name = "try-lock"
+version = "0.2.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"
+
 [[package]]
 name = "tungstenite"
 version = "0.24.0"
@@ -1204,7 +1741,7 @@ dependencies = [
  "byteorder",
  "bytes",
  "data-encoding",
- "http",
+ "http 1.2.0",
  "httparse",
  "log",
  "rand 0.8.5",
@@ -1237,12 +1774,32 @@ version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"
 
+[[package]]
+name = "uuid"
+version = "1.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3cf4199d1e5d15ddd86a694e4d0dffa9c323ce759fea589f00fef9d81cc1931d"
+dependencies = [
+ "getrandom 0.3.1",
+ "js-sys",
+ "wasm-bindgen",
+]
+
 [[package]]
 name = "version_check"
 version = "0.9.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"
 
+[[package]]
+name = "want"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
+dependencies = [
+ "try-lock",
+]
+
 [[package]]
 name = "wasi"
 version = "0.11.0+wasi-snapshot-preview1"
@@ -1260,24 +1817,24 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen"
-version = "0.2.97"
+version = "0.2.100"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d15e63b4482863c109d70a7b8706c1e364eb6ea449b201a76c5b89cedcec2d5c"
+checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
 dependencies = [
  "cfg-if",
  "once_cell",
+ "rustversion",
  "wasm-bindgen-macro",
 ]
 
 [[package]]
 name = "wasm-bindgen-backend"
-version = "0.2.97"
+version = "0.2.100"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8d36ef12e3aaca16ddd3f67922bc63e48e953f126de60bd33ccc0101ef9998cd"
+checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
 dependencies = [
  "bumpalo",
  "log",
- "once_cell",
  "proc-macro2",
  "quote",
  "syn",
@@ -1286,9 +1843,9 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-macro"
-version = "0.2.97"
+version = "0.2.100"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "705440e08b42d3e4b36de7d66c944be628d579796b8090bfa3471478a2260051"
+checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
 dependencies = [
  "quote",
  "wasm-bindgen-macro-support",
@@ -1296,9 +1853,9 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-macro-support"
-version = "0.2.97"
+version = "0.2.100"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "98c9ae5a76e46f4deecd0f0255cc223cfa18dc9b261213b8aa0c7b36f61b3f1d"
+checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -1309,9 +1866,12 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-shared"
-version = "0.2.97"
+version = "0.2.100"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6ee99da9c5ba11bd675621338ef6fa52296b76b83305e9b6e5c77d4c286d6d49"
+checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
+dependencies = [
+ "unicode-ident",
+]
 
 [[package]]
 name = "windows-core"
@@ -1410,7 +1970,7 @@ version = "0.33.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3268f3d866458b787f390cf61f4bbb563b922d091359f9608842999eaee3943c"
 dependencies = [
- "bitflags",
+ "bitflags 2.6.0",
 ]
 
 [[package]]
diff --git a/Cargo.toml b/Cargo.toml
index 5170311..0e0373a 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -16,3 +16,9 @@ log = "0.4.22"
 rayon = "1.10.0"
 chrono = "0.4"
 flexi_logger = "0.29.0"
+ tonic = "0.10"
+ prost = "0.12"
+ uuid = { version = "1.0", features = ["v4"] }
+ dashmap = "5.5"
+ tokio-stream = "0.1"
+ futures = "0.3"
diff --git a/diff_output b/diff_output
index ac885b3..7adf05e 100644
--- a/diff_output
+++ b/diff_output
@@ -1,3315 +0,0 @@
-diff --git a/src/data/append_result.rs b/src/data/append_result.rs
-index e69de29..5e0a05b 100644
---- a/src/data/append_result.rs
-+++ b/src/data/append_result.rs
-@@ -0,0 +1,23 @@
-+use std::fs::OpenOptions;
-+use std::io::{BufWriter, Write};
-+use chrono::Utc;
-+use futures_util::stream::SplitSink;
-+use futures_util::StreamExt;
-+use tokio::net::TcpListener;
-+use tokio_tungstenite::tungstenite::Message;
-+use tokio_tungstenite::{accept_async, WebSocketStream};
-+
-+pub fn append_to_results_file(file_path: &str, avg_score: f64) {
-+    let timestamp = Utc::now().to_rfc3339();
-+    let result_line = format!("{},{:.2}\n", timestamp, avg_score);
-+
-+    let file = OpenOptions::new()
-+        .create(true)
-+        .append(true)
-+        .open(file_path)
-+        .expect("Unable to open results file");
-+    let mut writer = BufWriter::new(file);
-+    writer
-+        .write_all(result_line.as_bytes())
-+        .expect("Unable to write to results file");
-+}
-diff --git a/src/data/load_data.rs b/src/data/load_data.rs
-index e69de29..b9b6cc9 100644
---- a/src/data/load_data.rs
-+++ b/src/data/load_data.rs
-@@ -0,0 +1,52 @@
-+use std::path::Path;
-+use tch::Tensor;
-+use crate::mcts::mcts_result::MCTSResult;
-+
-+pub fn load_game_data(file_path: &str) -> Vec<MCTSResult> {
-+    // Paths for the .pt files
-+    let states_path = format!("{}_states.pt", file_path);
-+    let positions_path = format!("{}_positions.pt", file_path);
-+    let subscores_path = format!("{}_subscores.pt", file_path);
-+
-+    // Check if all files exist
-+    if !Path::new(&states_path).exists() {
-+        println!(
-+            "‚ö†Ô∏è  Warning: '{}' not found. Returning empty dataset.",
-+            states_path
-+        );
-+        return Vec::new();
-+    }
-+    if !Path::new(&positions_path).exists() {
-+        println!(
-+            "‚ö†Ô∏è  Warning: '{}' not found. Returning empty dataset.",
-+            positions_path
-+        );
-+        return Vec::new();
-+    }
-+    if !Path::new(&subscores_path).exists() {
-+        println!(
-+            "‚ö†Ô∏è  Warning: '{}' not found. Returning empty dataset.",
-+            subscores_path
-+        );
-+        return Vec::new();
-+    }
-+
-+    println!("üöÄ Loading game data from .pt files...");
-+
-+    // Load the saved tensors
-+    let state_tensor = Tensor::load(states_path).expect("Failed to load states");
-+    let position_tensor = Tensor::load(positions_path).expect("Failed to load positions");
-+    let subscore_tensor = Tensor::load(subscores_path).expect("Failed to load subscores");
-+
-+    // Convert them back into MCTSResult objects
-+    let mut data = Vec::new();
-+    for i in 0..state_tensor.size()[0] {
-+        data.push(MCTSResult {
-+            board_tensor: state_tensor.get(i),
-+            best_position: position_tensor.get(i).int64_value(&[]) as usize,
-+            subscore: subscore_tensor.get(i).double_value(&[]),
-+        });
-+    }
-+    println!("‚úÖ Loaded {} game records.", data.len());
-+    data
-+}
-\ No newline at end of file
-diff --git a/src/data/mod.rs b/src/data/mod.rs
-index e69de29..85c648b 100644
---- a/src/data/mod.rs
-+++ b/src/data/mod.rs
-@@ -0,0 +1,3 @@
-+pub mod load_data;
-+pub mod save_data;
-+pub mod append_result;
-\ No newline at end of file
-diff --git a/src/data/save_data.rs b/src/data/save_data.rs
-index e69de29..7b2b24f 100644
---- a/src/data/save_data.rs
-+++ b/src/data/save_data.rs
-@@ -0,0 +1,53 @@
-+use tch::Tensor;
-+use crate::mcts::mcts_result::MCTSResult;
-+
-+pub fn save_game_data(file_path: &str, game_data: Vec<MCTSResult>) {
-+    println!("üöÄ Saving game data to .pt files...");
-+
-+    let mut tensors = vec![];
-+    let mut positions = vec![];
-+    let mut subscores = vec![];
-+
-+    for result in game_data {
-+        tensors.push(result.board_tensor.shallow_clone());
-+        positions.push(result.best_position as i64);
-+        subscores.push(result.subscore as f32);
-+    }
-+
-+    // Cr√©ation des nouveaux tensors
-+    let state_tensor = Tensor::stack(&tensors, 0);
-+    let position_tensor = Tensor::from_slice(&positions).view([-1, 1]);
-+    let subscore_tensor = Tensor::from_slice(&subscores).view([-1, 1]);
-+
-+    // üîÑ Append logic: charger les anciens tensors s'ils existent
-+    let combined_states = if let Ok(prev) = Tensor::load(format!("{}_states.pt", file_path)) {
-+        Tensor::cat(&[prev, state_tensor], 0)
-+    } else {
-+        state_tensor
-+    };
-+
-+    let combined_positions = if let Ok(prev) = Tensor::load(format!("{}_positions.pt", file_path)) {
-+        Tensor::cat(&[prev, position_tensor], 0)
-+    } else {
-+        position_tensor
-+    };
-+
-+    let combined_subscores = if let Ok(prev) = Tensor::load(format!("{}_subscores.pt", file_path)) {
-+        Tensor::cat(&[prev, subscore_tensor], 0)
-+    } else {
-+        subscore_tensor
-+    };
-+
-+    // üîÑ Sauvegarde des tensors concat√©n√©s
-+    if let Err(e) = combined_states.save(format!("{}_states.pt", file_path)) {
-+        log::info!("‚ùå Error saving states: {:?}", e);
-+    }
-+    if let Err(e) = combined_positions.save(format!("{}_positions.pt", file_path)) {
-+        log::info!("‚ùå Error saving positions: {:?}", e);
-+    }
-+    if let Err(e) = combined_subscores.save(format!("{}_subscores.pt", file_path)) {
-+        log::info!("‚ùå Error saving subscores: {:?}", e);
-+    }
-+
-+    log::info!("‚úÖ Save complete!");
-+}
-diff --git a/src/game/create_deck.rs b/src/game/create_deck.rs
-index 5ea7b53..3a7c7f7 100644
---- a/src/game/create_deck.rs
-+++ b/src/game/create_deck.rs
-@@ -1,7 +1,7 @@
- use crate::game::deck::Deck;
- use crate::game::tile::Tile;
- 
--pub fn create_shuffle_deck() -> Deck {
-+pub fn create_deck() -> Deck {
-     let tiles = vec![
-         new_tiles(1, 2, 3),
-         new_tiles(1, 6, 8),
-@@ -40,13 +40,14 @@ pub(crate) fn new_tiles(x: i32, y: i32, z: i32) -> Tile {
- }
- #[cfg(test)]
- mod tests {
--    use crate::create_deck;
-+    use crate::game::create_deck;
-+    use crate::game::create_deck::create_deck;
-     use crate::game::tile::Tile;
- 
-     #[test]
-     fn test_create_shuffle_deck() {
-         // Create the shuffle deck
--        let deck = create_shuffle_deck();
-+        let deck = create_deck();
- 
-         // Check that the deck has exactly 27 tiles
-         assert_eq!(
-diff --git a/src/game/deck.rs b/src/game/deck.rs
-index e69de29..2709b0d 100644
---- a/src/game/deck.rs
-+++ b/src/game/deck.rs
-@@ -0,0 +1,6 @@
-+use crate::game::tile::Tile;
-+
-+#[derive(Debug, Clone, PartialEq)]
-+pub struct Deck{
-+    pub(crate) tiles: Vec<Tile>,
-+}
-\ No newline at end of file
-diff --git a/src/game/get_legal_moves.rs b/src/game/get_legal_moves.rs
-index e69de29..b8c40e3 100644
---- a/src/game/get_legal_moves.rs
-+++ b/src/game/get_legal_moves.rs
-@@ -0,0 +1,17 @@
-+use crate::game::plateau::Plateau;
-+use crate::game::tile::Tile;
-+
-+pub fn get_legal_moves(plateau: Plateau) -> Vec<usize> {
-+    plateau
-+        .tiles
-+        .iter()
-+        .enumerate()
-+        .filter_map(|(i, tile)| {
-+            if *tile == Tile(0, 0, 0) {
-+                Some(i)
-+            } else {
-+                None
-+            }
-+        })
-+        .collect()
-+}
-\ No newline at end of file
-diff --git a/src/game/mod.rs b/src/game/mod.rs
-index e69de29..97a038c 100644
---- a/src/game/mod.rs
-+++ b/src/game/mod.rs
-@@ -0,0 +1,9 @@
-+pub mod deck;
-+pub mod plateau;
-+pub mod game_state;
-+pub mod tile;
-+pub mod create_deck;
-+pub mod remove_tile_from_deck;
-+pub mod plateau_is_full;
-+pub mod get_legal_moves;
-+pub mod simulate_game;
-diff --git a/src/game/plateau.rs b/src/game/plateau.rs
-index f6c4e1c..0502b7a 100644
---- a/src/game/plateau.rs
-+++ b/src/game/plateau.rs
-@@ -1,6 +1,13 @@
--use crate::tile::Tile;
-+use crate::game::tile::Tile;
- 
- #[derive(Debug, Clone, PartialEq)]
- pub(crate) struct Plateau{
-     pub(crate) tiles: Vec<Tile>,
--}
-\ No newline at end of file
-+}
-+
-+
-+pub(crate) fn create_plateau_empty() -> Plateau {
-+    Plateau {
-+        tiles: vec![Tile(0, 0, 0); 19],
-+    }
-+}
-diff --git a/src/game/plateau_is_full.rs b/src/game/plateau_is_full.rs
-index e69de29..050e566 100644
---- a/src/game/plateau_is_full.rs
-+++ b/src/game/plateau_is_full.rs
-@@ -0,0 +1,6 @@
-+use crate::game::plateau::Plateau;
-+use crate::game::tile::Tile;
-+
-+pub fn is_plateau_full(plateau: &Plateau) -> bool {
-+    plateau.tiles.iter().all(|tile| *tile != Tile(0, 0, 0))
-+}
-\ No newline at end of file
-diff --git a/src/game/simulate_game.rs b/src/game/simulate_game.rs
-index e69de29..d370bf1 100644
---- a/src/game/simulate_game.rs
-+++ b/src/game/simulate_game.rs
-@@ -0,0 +1,41 @@
-+use rand::Rng;
-+use crate::game::deck::Deck;
-+use crate::game::get_legal_moves::get_legal_moves;
-+use crate::game::plateau::Plateau;
-+use crate::game::plateau_is_full::is_plateau_full;
-+use crate::game::tile::Tile;
-+use crate::scoring::scoring::result;
-+
-+pub fn simulate_games(plateau: Plateau, deck: Deck) -> i32 {
-+    let mut simulated_plateau = plateau.clone();
-+    let simulated_deck = deck.clone();
-+    let mut legal_moves = get_legal_moves(simulated_plateau.clone());
-+
-+    // Filter out invalid tiles (0, 0, 0)
-+    let mut valid_tiles: Vec<Tile> = simulated_deck
-+        .tiles
-+        .iter()
-+        .cloned()
-+        .filter(|tile| *tile != Tile(0, 0, 0))
-+        .collect();
-+
-+    let mut rng = rand::rng(); // Fixed: Use new API
-+
-+    while !is_plateau_full(&simulated_plateau) {
-+        if legal_moves.is_empty() || valid_tiles.is_empty() {
-+            break;
-+        }
-+
-+        // Fixed: Use new rand API
-+        let position_index = rng.random_range(0..legal_moves.len());
-+        let position = legal_moves.swap_remove(position_index); // Swap-remove for O(1) removal
-+
-+        let tile_index = rng.random_range(0..valid_tiles.len());
-+        let chosen_tile = valid_tiles.swap_remove(tile_index); // Swap-remove for O(1) removal
-+
-+        // Place the chosen tile
-+        simulated_plateau.tiles[position] = chosen_tile;
-+    }
-+
-+    result(&simulated_plateau) // Compute and return the result
-+}
-\ No newline at end of file
-diff --git a/src/main.rs b/src/main.rs
-index 390fb85..90a57dc 100644
---- a/src/main.rs
-+++ b/src/main.rs
-@@ -1,44 +1,61 @@
-+use chrono::Utc;
-+use clap::Parser;
-+use futures_util::stream::SplitSink;
-+use futures_util::{SinkExt, StreamExt};
-+use rand::{rng, Rng};
-+use serde_json;
- use std::collections::HashMap;
- use std::fs::OpenOptions;
- use std::io::{BufWriter, Write};
- use std::path::Path;
- use std::sync::Arc;
--use chrono::Utc;
--use clap::Parser;
--use futures_util::{SinkExt, StreamExt};
--use futures_util::stream::SplitSink;
--use rand::{Rng, rng};
--use serde_json;
--use tch::{Device, IndexOp, nn, Tensor};
- use tch::nn::{Optimizer, OptimizerConfig};
-+use tch::{nn, Device, IndexOp, Tensor};
- use tokio::net::TcpListener;
--use tokio_tungstenite::{accept_async, WebSocketStream};
- use tokio_tungstenite::tungstenite::protocol::Message;
-+use tokio_tungstenite::{accept_async, WebSocketStream};
- 
--use create_plateau_empty::create_plateau_empty;
--use create_shuffle_deck::create_shuffle_deck;
--use result::result;
-+use crate::game::deck::Deck;
-+use crate::game::plateau::create_plateau_empty;
- use crate::logging::setup_logging;
-+use crate::mcts::mcts_result::MCTSResult;
- use crate::mcts_vs_human::play_mcts_vs_human;
--use crate::policy_value_net::{PolicyNet, ValueNet};
--use crate::remove_tile_from_deck::replace_tile_in_deck;
--use crate::test::{Deck, Plateau, Tile};
-+use game::create_deck::create_deck;
-+use game::plateau::Plateau;
-+use game::remove_tile_from_deck::replace_tile_in_deck;
-+use game::tile::Tile;
-+use neural::policy_value_net::{PolicyNet, ValueNet};
-+use crate::data::append_result::append_to_results_file;
-+use crate::data::load_data::load_game_data;
-+use crate::data::save_data::save_game_data;
-+use crate::game::get_legal_moves::get_legal_moves;
-+use crate::game::plateau_is_full::is_plateau_full;
-+use crate::game::simulate_game::simulate_games;
-+use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
-+use crate::neural::tensor_conversion::convert_plateau_to_tensor;
-+use crate::neural::training::gradient_clipping::enhanced_gradient_clipping;
-+use crate::neural::training::normalization::robust_state_normalization;
-+use crate::neural::training::trainer::train_network_with_game_data;
-+use crate::scoring::scoring::result;
-+use crate::strategy::position_evaluation::enhanced_position_evaluation;
-+use crate::training::evaluator::evaluate_model;
-+use crate::training::session::train_and_evaluate;
-+use crate::training::websocket::reconnect_websocket;
-+use crate::utils::image::generate_tile_image_names;
-+use crate::utils::random_index::random_index;
- 
- mod test;
--mod result;
--mod remove_tile_from_deck;
--mod create_plateau_empty;
--mod create_shuffle_deck;
- 
--mod policy_value_net;
--mod mcts_vs_human;
-+mod game;
- mod logging;
--
--fn generate_tile_image_names(tiles: &[Tile]) -> Vec<String> {
--    tiles.iter().map(|tile| {
--        format!("../image/{}{}{}.png", tile.0, tile.1, tile.2)
--    }).collect()
--}
-+mod mcts;
-+mod mcts_vs_human;
-+mod neural;
-+mod utils;
-+mod strategy;
-+mod scoring;
-+mod data;
-+mod training;
- 
- #[derive(Parser, Debug)]
- #[command(name = "take_it_easy")]
-@@ -52,71 +69,10 @@ struct Config {
-     num_simulations: usize,
- 
-     /// Run MCTS vs Human instead of training
--    #[arg(long)]
-+    #[arg(long, default_value_t = true)]
-     mcts_vs_human: bool,
- }
--fn enhanced_gradient_clipping(vs_value: &nn::VarStore, vs_policy: &nn::VarStore) -> (f64, f64) {
--    let mut max_grad_value: f64 = 0.0;
--    let mut max_grad_policy: f64 = 0.0;
--
--    tch::no_grad(|| {
--        // Value network - clipping tr√®s agressif
--        for (_name, tensor) in vs_value.variables() {
--            if tensor.grad().defined() {
--                let grad_norm = tensor.grad().norm().double_value(&[]);
--                max_grad_value = max_grad_value.max(grad_norm);
- 
--                // BEAUCOUP plus agressif que (-1.0, 1.0)
--                tensor.grad().clamp_(-0.5, 0.5);
--            }
--        }
--
--        // Policy network - clipping mod√©r√©
--        for (_name, tensor) in vs_policy.variables() {
--            if tensor.grad().defined() {
--                let grad_norm = tensor.grad().norm().double_value(&[]);
--                max_grad_policy = max_grad_policy.max(grad_norm);
--
--                tensor.grad().clamp_(-1.0, 1.0);
--            }
--        }
--
--        // Log seulement si vraiment √©lev√©
--        if max_grad_value > 1.0 {
--            log::warn!("üî• Value grad norm: {:.3}", max_grad_value);
--        }
--        if max_grad_policy > 2.0 {
--            log::warn!("üî• Policy grad norm: {:.3}", max_grad_policy);
--        }
--    });
--
--    (max_grad_value, max_grad_policy)
--}
--fn robust_state_normalization(state: &Tensor) -> Tensor {
--    // 1. Clamp les valeurs extr√™mes
--    let clamped = state.clamp(-10.0, 10.0);
--
--    // 2. Calcul de la m√©diane pour normalisation robuste
--    let flattened = clamped.view(-1);
--    let sorted = flattened.sort(0, false).0;
--    let median_idx = sorted.size()[0] / 2;
--    let median = sorted.i(median_idx).double_value(&[]);
--
--    // 3. MAD (Median Absolute Deviation) au lieu de std
--    let deviations = (flattened - median).abs();
--    let sorted_dev = deviations.sort(0, false).0;
--    let mad = sorted_dev.i(median_idx).double_value(&[]) * 1.4826;
--
--    // 4. Normalisation avec MAD
--    let normalized = if mad > 1e-6 {
--        (clamped - median) / mad.max(1e-6)
--    } else {
--        clamped - median
--    };
--
--    // 5. Clamp final pour √©viter les valeurs extr√™mes
--    normalized.clamp(-3.0, 3.0)
--}
- #[tokio::main]
- async fn main() {
-     let config = Config::parse();
-@@ -130,15 +86,12 @@ async fn main() {
-     let mut policy_net = PolicyNet::new(&vs_policy, input_dim);
-     let mut value_net = ValueNet::new(&mut vs_value, input_dim);
- 
--
--
--
--
-     // Load weights if the model directory exists
-     if Path::new(model_path).exists() {
-         log::info!("üîÑ Loading model weights from {}", model_path);
- 
--        if let Err(e) = policy_net.load_model(&mut vs_policy, "model_weights/policy/policy.params") {
-+        if let Err(e) = policy_net.load_model(&mut vs_policy, "model_weights/policy/policy.params")
-+        {
-             log::error!("‚ö†Ô∏è Error loading PolicyNet: {:?}", e);
-             log::info!("‚û°Ô∏è  Initializing PolicyNet with random weights.");
-         }
-@@ -150,15 +103,14 @@ async fn main() {
-     } else {
-         log::info!("üì≠ No pre-trained model found. Initializing new models.");
-     }
--    let mut optimizer_policy = nn::Adam ::default().build(&vs_policy, 1e-3).unwrap();
-+    let mut optimizer_policy = nn::Adam::default().build(&vs_policy, 1e-3).unwrap();
-     // Change your optimizer (around line 100):
-     let mut optimizer_value = nn::Adam {
--        wd: 1e-6,  // Was 1e-5
-+        wd: 1e-6, // Was 1e-5
-         ..Default::default()
--    }.build(&vs_value, 2e-4).unwrap(); // Was 1e-3
--
--
--
-+    }
-+    .build(&vs_value, 2e-4)
-+    .unwrap(); // Was 1e-3
- 
-     // ‚ûï Duel Mode: MCTS vs Human
-     if config.mcts_vs_human {
-@@ -178,7 +130,7 @@ async fn main() {
-             &mut write,
-             &mut read,
-         )
--            .await;
-+        .await;
- 
-         return; // Exit after duel game
-     }
-@@ -201,1210 +153,16 @@ async fn main() {
-         50, // Evaluate every 50 games
-         listener.into(),
-     )
--        .await;
--}
--fn random_index(max: usize) -> usize {
--    use rand::Rng;
--    let mut rng = rand::thread_rng();
--    rng.gen_range(0..max)
--}
--
--// Version simplifi√©e qui se concentre sur les positions strat√©giques
--fn calculate_line_completion_bonus(plateau: &Plateau, position: usize, tile: &Tile) -> f64 {
--    let mut bonus = 0.0;
--
--    // Bonus bas√© sur les positions strat√©giques identifi√©es dans tes donn√©es
--    bonus += match position {
--        8 => 5.0,   // Position 8: 150.6 moyenne - excellente
--        14 => 4.0,  // Position 14: 147.7 moyenne - tr√®s bonne
--        2 => 4.0,   // Position 2: 147.1 moyenne - tr√®s bonne
--        5 => 3.0,   // Position 5: 143.6 moyenne - bonne
--        11 => 3.0,  // Position 11: 142.9 moyenne - bonne
--        10 => 2.0,  // Position 10: 140.8 moyenne - correcte
--        13 => 2.0,  // Position 13: 140.2 moyenne - correcte
--        1 | 4 | 6 | 9 | 0 => 1.0,  // Positions moyennes
--        12 | 15 | 16 => 0.5,  // Positions plus faibles
--        7 | 17 => 0.0,  // Positions les plus faibles
--        _ => 0.0,
--    };
--
--    // Bonus pour les valeurs de tuiles √©lev√©es (plus de points potentiels)
--    let tile_value_bonus = ((tile.0 + tile.1) as f64) * 0.1;
--    bonus += tile_value_bonus;
--
--    // Bonus pour la coh√©rence des couleurs/formes
--    if tile.0 == tile.1 {
--        bonus += 1.0;  // Tuiles avec m√™me couleur et forme
--    }
--
--    // Bonus central l√©g√®rement plus complexe
--    let row = position / 3;
--    let col = position % 3;
--    if row >= 1 && row <= 4 && col >= 1 && col <= 1 {
--        bonus += 2.0;  // Zone centrale du plateau
--    }
--
--    bonus
--}
--
--// ============================================================================
--// ALTERNATIVE PLUS SIMPLE (Si la version ci-dessus pose encore probl√®me)
--// ============================================================================
--
--// Si vous pr√©f√©rez une version plus simple, utilisez celle-ci:
--
--fn enhanced_position_evaluation(plateau: &Plateau, position: usize, tile: &Tile, current_turn: usize) -> f64 {
--    // Score de base alignement (votre fonction existante)
--    let alignment_score = compute_alignment_score(plateau, position, tile);
--
--    // Bonus pour positions centrales strat√©giques en d√©but de partie
--    let position_bonus = if current_turn < 8 {
--        match position {
--            7 | 8 | 9 | 10 | 11 => 5.0,    // Ligne centrale - critique
--            4 | 5 | 6 | 12 | 13 | 14 | 15 => 3.0, // Positions strat√©giques
--            _ => 0.0,
--        }
--    } else {
--        0.0 // En fin de partie, seul l'alignement compte
--    };
--
--    // Malus pour positions coins/bords si d√©but de partie
--    let position_malus = if current_turn < 5 {
--        match position {
--            0 | 2 | 16 | 18 => -2.0,  // Coins - √† √©viter en d√©but
--            1 | 17 => -1.0,           // Bords
--            _ => 0.0,
--        }
--    } else {
--        0.0
--    };
--
--    // Bonus pour compl√©tion de lignes
--    let completion_bonus = calculate_line_completion_bonus(plateau, position, tile);
--
--    alignment_score + position_bonus + position_malus + completion_bonus
--}
--
--fn mcts_find_best_position_for_tile_with_nn(
--    plateau: &mut Plateau,
--    deck: &mut Deck,
--    chosen_tile: Tile,
--    policy_net: &PolicyNet,
--    value_net: &ValueNet,
--    num_simulations: usize,
--    current_turn:usize,
--    total_turns:usize,
--) -> MCTSResult {
--    let legal_moves = get_legal_moves(plateau.clone());
--    if legal_moves.is_empty() {
--        return MCTSResult {
--            best_position: 0,
--            board_tensor: convert_plateau_to_tensor(plateau, &chosen_tile, deck,current_turn, total_turns),
--            subscore: 0.0,
--        };
--    }
--
--    let board_tensor = convert_plateau_to_tensor(plateau, &chosen_tile, deck,current_turn, total_turns);
--    let policy_logits = policy_net.forward(&board_tensor, false);
--    let policy = policy_logits.log_softmax(-1, tch::Kind::Float).exp(); // Log-softmax improves numerical stability
--
--    let mut visit_counts: HashMap<usize, usize> = HashMap::new();
--    let mut total_scores: HashMap<usize, f64> = HashMap::new();
--    let mut ucb_scores: HashMap<usize, f64> = HashMap::new();
--    let mut total_visits: i32 = 0;
--
--
--    for &position in &legal_moves {
--        visit_counts.insert(position, 0);
--        total_scores.insert(position, 0.0);
--        ucb_scores.insert(position, f64::NEG_INFINITY);
--    }
--
--    let c_puct = if current_turn < 5 {
--        4.2  // Plus d'exploitation en d√©but de partie (positions critiques)
--    } else if current_turn > 15 {
--        3.0  // Plus d'exploration en fin de partie (adaptation)
--    } else {
--        3.8  // √âquilibre pour le milieu de partie
--    };
--
--    // **Compute ValueNet scores for all legal moves**
--    let mut value_estimates = HashMap::new();
--    let mut min_value = f64::INFINITY;
--    let mut max_value = f64::NEG_INFINITY;
--
--    for &position in &legal_moves {
--        let mut temp_plateau = plateau.clone();
--        let mut temp_deck = deck.clone();
--
--        temp_plateau.tiles[position] = chosen_tile;
--        temp_deck = replace_tile_in_deck(&temp_deck, &chosen_tile);
--        let board_tensor_temp = convert_plateau_to_tensor(&temp_plateau, &chosen_tile, &temp_deck,current_turn, total_turns);
--
--        let pred_value = value_net.forward(&board_tensor_temp, false).double_value(&[]);
--        let pred_value = pred_value.clamp(-1.0, 1.0);
--
--        // Track min and max for dynamic pruning
--        min_value = min_value.min(pred_value);
--        max_value = max_value.max(pred_value);
--
--        value_estimates.insert(position, pred_value);
--    }
--
--    // **Dynamic Pruning Strategy**
--    let value_threshold = if current_turn < 8 {
--        min_value + (max_value - min_value) * 0.1  // Garder plus de candidats en d√©but
--    } else {
--        min_value + (max_value - min_value) * 0.15 // Pruning moins agressif
--    };
--
--    for _ in 0..num_simulations {
--        let mut moves_with_prior: Vec<_> = legal_moves
--            .iter()
--            .filter(|&&pos| value_estimates[&pos] >= value_threshold) // Prune weak moves
--            .map(|&pos| (pos, policy.i((0, pos as i64)).double_value(&[])))
--            .collect();
--
--        moves_with_prior.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
--
--        let top_k = usize::min(
--            moves_with_prior.len(),
--            ((total_visits as f64).sqrt() as usize).max(5),
--        );
--
--        let subset_moves: Vec<usize> = moves_with_prior.iter().take(top_k).map(|&(pos, _)| pos).collect();
--
--        for &position in &subset_moves {
--            let mut temp_plateau = plateau.clone();
--            let mut temp_deck = deck.clone();
--
--            temp_plateau.tiles[position] = chosen_tile;
--            temp_deck = replace_tile_in_deck(&temp_deck, &chosen_tile);
--
--            let value_estimate = *value_estimates.get(&position).unwrap_or(&0.0);
--
--            // **Improved Adaptive Rollout Strategy**
--            let rollout_count = match value_estimate {
--                x if x > 8.0 => 2, // Very strong move -> minimal rollouts
--                x if x > 6.0 => 4, // Strong move -> fewer rollouts
--                x if x > 4.0 => 6, // Decent move -> moderate rollouts
--                _ => 8,           // Uncertain move -> more rollouts
--            };
--
--            let mut total_simulated_score = 0.0;
--
--            for _ in 0..rollout_count {
--                let mut lookahead_plateau = temp_plateau.clone();
--                let mut lookahead_deck = temp_deck.clone();
--
--                // üîÆ √âtape 1.1 ‚Äî Tirer une tuile hypoth√©tique (T2)
--                if lookahead_deck.tiles.is_empty() {
--                    continue;
--                }
--                let tile2_index = random_index(lookahead_deck.tiles.len());
--                let tile2 = lookahead_deck.tiles[tile2_index];
--
--                // üîç √âtape 1.2 ‚Äî Simuler tous les placements possibles de cette tuile
--                let second_moves = get_legal_moves(lookahead_plateau.clone());
--
--                let mut best_score_for_tile2: f64 = 0.0;
--
--                for &pos2 in &second_moves {
--                    let mut plateau2 = lookahead_plateau.clone();
--                    let mut deck2 = lookahead_deck.clone();
--
--                    plateau2.tiles[pos2] = tile2;
--                    deck2 = replace_tile_in_deck(&deck2, &tile2);
--
--                    let score = simulate_games(plateau2.clone(), deck2.clone()) as f64;
--                    best_score_for_tile2 = best_score_for_tile2.max(score);
--                }
--
--                total_simulated_score += best_score_for_tile2;
--            }
--
--            let simulated_score = total_simulated_score / rollout_count as f64;
--
--            let visits = visit_counts.entry(position).or_insert(0);
--            *visits += 1;
--            total_visits += 1;
--
--            let total_score = total_scores.entry(position).or_insert(0.0);
--            *total_score += simulated_score as f64;
--
--            let exploration_param = c_puct * (total_visits as f64).ln() / (1.0 + *visits as f64);
--            let prior_prob = policy.i((0, position as i64)).double_value(&[]);
--            let average_score = *total_score / (*visits as f64);
--            // üß™ Reduce weight of rollout average
--            let enhanced_eval = enhanced_position_evaluation(&temp_plateau, position, &chosen_tile, current_turn);
--
--            // Int√©grer dans le calcul UCB
--            let mut ucb_score = (average_score * 0.5)
--                + exploration_param * (prior_prob.sqrt())
--                + 0.25 * value_estimate.clamp(0.0, 2.0)
--                + 0.1 * enhanced_eval; // Nouveau facteur d'√©valuation
--
--            // üî• Explicit Priority Logic HERE üî•
--            // 1Ô∏è‚É£ Ajoute cette fonction en dehors de ta mcts_find_best_position_for_tile_with_nn
--
--
--            // 2Ô∏è‚É£ Int√®gre ceci dans ta boucle ucb_scores, juste apr√®s le boost fixe
--
--            if chosen_tile.0 == 9 && [7, 8, 9, 10, 11].contains(&position) {
--                ucb_score += 10000.0;  // double boost
--            } else if chosen_tile.0 == 5 && [3, 4, 5, 6, 12, 13, 14, 15].contains(&position) {
--                ucb_score += 8000.0;
--            } else if chosen_tile.0 == 1 && [0, 1, 2, 16, 17, 18].contains(&position) {
--                ucb_score += 6000.0;
--            }
--
--            // üî• Alignment Priority Logic üî•
--
--
--
--
--
--            ucb_scores.insert(position, ucb_score);
--        }
--    }
--
--    // Select the move with the highest UCB score
--    let best_position = legal_moves.into_iter()
--        .max_by(|&a, &b| {
--            ucb_scores.get(&a).unwrap_or(&f64::NEG_INFINITY)
--                .partial_cmp(ucb_scores.get(&b).unwrap_or(&f64::NEG_INFINITY))
--                .unwrap_or(std::cmp::Ordering::Equal)
--        }).unwrap_or(0);
--
--
--    // **NEW: Simulate the Rest of the Game to Get Final Score**
--    let mut final_plateau = plateau.clone();
--    let mut final_deck = deck.clone();
--    final_plateau.tiles[best_position] = chosen_tile;
--    final_deck = replace_tile_in_deck(&final_deck, &chosen_tile);
--
--    while !is_plateau_full(&final_plateau) {
--        let tile_index = random_index(final_deck.tiles.len());
--        let random_tile = final_deck.tiles[tile_index];
--
--        let available_moves = get_legal_moves(final_plateau.clone());
--        if available_moves.is_empty() {
--            break;
--        }
--
--        let random_position = available_moves[random_index(available_moves.len())];
--        final_plateau.tiles[random_position] = random_tile;
--        final_deck = replace_tile_in_deck(&final_deck, &random_tile);
--    }
--
--    let final_score = result(&final_plateau); // Get actual game score
--
--    log::info!("ü§ñ Pos:{} Score:{}", best_position, final_score as i32);
--
--    MCTSResult {
--        best_position,
--        board_tensor,
--        subscore: final_score as f64, // Store real final score, not UCB score
--    }
--}
--fn local_lookahead(mut plateau: Plateau, mut deck: Deck, depth: usize) -> i32 {
--    for _ in 0..depth {
--        if is_plateau_full(&plateau) || deck.tiles.is_empty() {
--            break;
--        }
--
--        let tile_index = random_index(deck.tiles.len());
--        let chosen_tile = deck.tiles[tile_index];
--
--        let legal_moves = get_legal_moves(plateau.clone());
--        if legal_moves.is_empty() {
--            break;
--        }
--
--        let best_pos = legal_moves
--            .into_iter()
--            .max_by_key(|&pos| compute_alignment_score(&plateau, pos, &chosen_tile) as i32)
--            .unwrap();
--
--        plateau.tiles[best_pos] = chosen_tile;
--        deck = replace_tile_in_deck(&deck, &chosen_tile);
--    }
--
--    result(&plateau)
--}
--fn compute_global_stats(game_data: &[MCTSResult]) -> (Tensor, Tensor) {
--    let stacked = Tensor::cat(
--        &game_data.iter().map(|gd| gd.board_tensor.shallow_clone()).collect::<Vec<_>>(),
--        0
--    );
--
--    let mean = stacked.mean_dim(&[0i64, 2, 3][..], true, tch::Kind::Float);
--    let std = stacked.std_dim(&[0i64, 2, 3][..], true, true).clamp_min(1e-8);
--
--
--    (mean, std)
-+    .await;
- }
- 
- 
- 
- 
--fn normalize_input(tensor: &Tensor, global_mean: &Tensor, global_std: &Tensor) -> Tensor {
--    (tensor - global_mean) / (global_std + 1e-8)
--}
--
--
--// Enhanced training function with better value network stabilization
--fn train_network_with_game_data(
--    vs_policy: &nn::VarStore,
--    vs_value: &nn::VarStore,
--    game_data: &[MCTSResult],
--    discount_factor: f64,
--    policy_net: &PolicyNet,
--    value_net: &ValueNet,
--    optimizer_policy: &mut Optimizer,
--    optimizer_value: &mut Optimizer,
--) {
--    // Hyperparameters
--    let entropy_weight = 0.05;
--    let gamma = 0.99;
--    let epsilon = 1e-8;
--
--    // Initialize accumulators
--    let mut predictions = Vec::new();
--    let mut targets = Vec::new();
--    let mut total_policy_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
--    let mut total_value_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
--    let mut total_entropy_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
--
--    // Initialize trajectory rewards and discounted sum
--    let mut trajectory_rewards = Vec::new();
--    let mut discounted_sum = Tensor::zeros(&[], (tch::Kind::Float, tch::Device::Cpu));
--
--    // === Training Loop ===
--    for (step, result) in game_data.iter().rev().enumerate() {
--        // üõë No Normalization: Use raw tensor
--        let state = result.board_tensor.shallow_clone();
--        let normalized_state = robust_state_normalization(&state);
--
--        // Forward pass through networks with normalized state
--        let pred_policy = policy_net.forward(&normalized_state, true).clamp_min(1e-7);
--        let pred_value = value_net.forward(&normalized_state, true);
--
--        // Forward pass through networks with normalized state
--        // Normalize reward: divide by a constant max value (e.g., 100)
--        let reward = Tensor::from(result.subscore).to_kind(tch::Kind::Float) / 100.0;
--        let gamma_tensor = Tensor::from_slice(&[gamma]).to_kind(tch::Kind::Float);
--
--        // ‚úÖ NaN & Inf Check for reward
--        if reward.isnan().any().double_value(&[]) > 0.0 || reward.isinf().any().double_value(&[]) > 0.0 {
--            log::error!("‚ö†Ô∏è NaN or Inf detected in reward at step {}", step);
--            continue;
--        }
--
--        // Update discounted sum with normalized reward
--        discounted_sum = reward + gamma_tensor * discounted_sum;
--
--        // ‚úÖ NaN & Inf Check for discounted sum
--        if discounted_sum.isnan().any().double_value(&[]) > 0.0 || discounted_sum.isinf().any().double_value(&[]) > 0.0 {
--            log::error!("‚ö†Ô∏è NaN or Inf detected in discounted sum at step {}", step);
--            continue;
--        }
--
--        // Store the value for analysis
--        trajectory_rewards.push(discounted_sum.double_value(&[]));
--
--        // Generate target tensor directly from discounted sum
--        let discounted_reward = discounted_sum.shallow_clone();
- 
--        // Append for later analysis
--        predictions.push(pred_value.double_value(&[]));
--        targets.push(discounted_reward.double_value(&[]));
- 
--        // === Compute Losses ===
--        // Policy loss
--        let best_position = result.best_position as i64;
--        let target_policy = Tensor::zeros(&[1, pred_policy.size()[1]], tch::kind::FLOAT_CPU);
--        target_policy.i((0, best_position)).fill_(1.0);
--        let log_policy = pred_policy.log();
--        let policy_loss = -(target_policy * log_policy.shallow_clone()).sum(tch::Kind::Float);
--        total_policy_loss += policy_loss;
- 
--        // Entropy loss
--        let entropy_loss = -(pred_policy * (log_policy + epsilon)).sum(tch::Kind::Float);
--        total_entropy_loss += entropy_loss;
- 
--        // Value loss (Huber loss for better stability)
--        let diff = discounted_reward.shallow_clone() - pred_value.shallow_clone();
--        let abs_diff = diff.abs();
--        let delta = 1.0;
--        let value_loss = abs_diff.le(delta).to_kind(tch::Kind::Float) * 0.5 * &diff * &diff
--            + abs_diff.gt(delta).to_kind(tch::Kind::Float) * (delta * (&abs_diff - 0.5 * delta));
--        total_value_loss += value_loss.mean(tch::Kind::Float);
--    }
--
--    // Fix: Add explicit type annotation for total_loss
--    let total_loss: Tensor = total_policy_loss.shallow_clone()
--        + total_value_loss.shallow_clone()
--        + (entropy_weight * total_entropy_loss.shallow_clone());
--
--    // Log the loss before backpropagation
--    log::info!("üí° Total Loss before backward: {:.4}", total_loss.double_value(&[]));
--
--    // ‚úÖ Enhanced NaN and Inf check before backpropagation
--    if total_loss.isnan().any().double_value(&[]) > 0.0 {
--        log::error!("‚ö†Ô∏è NaN detected in total loss! Skipping backpropagation.");
--        return;
--    }
--    if total_loss.isinf().any().double_value(&[]) > 0.0 {
--        log::error!("‚ö†Ô∏è Inf detected in total loss! Skipping backpropagation.");
--        return;
--    }
--
--    // Check if total_loss requires gradients before calling backward
--    if !total_loss.requires_grad() {
--        log::error!("‚ö†Ô∏è Total loss does not require gradients! Skipping backpropagation.");
--        return;
--    }
--
--    total_loss.backward();
--
--    // Enhanced gradient clipping with fixed type annotation
--    let (_max_grad_value, _max_grad_policy) = enhanced_gradient_clipping(vs_value, vs_policy);
--
--
--    // === Optimizer Step ===
--    optimizer_policy.step();
--    optimizer_policy.zero_grad();
--    optimizer_value.step();
--    optimizer_value.zero_grad();
--
--    log::info!(
--        "üéØ Update Complete | Policy Loss: {:.4}, Value Loss: {:.4}, Entropy Loss: {:.4}",
--        total_policy_loss.double_value(&[]),
--        total_value_loss.double_value(&[]),
--        total_entropy_loss.double_value(&[])
--    );
--}
--
--// Fixed simulate_games function with updated rand API
--
--
--// N-step returns calculation for more stable targets
--fn calculate_n_step_returns(rewards: &[f32], gamma: f32, n: usize) -> Vec<f32> {
--    let mut returns = Vec::new();
--
--    for i in 0..rewards.len() {
--        let mut ret = 0.0;
--        let mut discount = 1.0;
--
--        // Calculate n-step return
--        for j in 0..n.min(rewards.len() - i) {
--            ret += discount * rewards[i + j];
--            discount *= gamma;
--        }
--
--        returns.push(ret / 100.0); // Normalize by dividing by max expected score
--    }
--
--    returns
--}
--
--// Huber loss for more stable value training
--fn huber_loss(predictions: &Tensor, targets: &Tensor, delta: f64) -> Tensor {
--    let diff = predictions - targets;
--    let abs_diff = diff.abs();
--    let quadratic = (abs_diff.le(delta)).to_kind(tch::Kind::Float) * 0.5 * &diff * &diff;
--    let linear = (abs_diff.gt(delta)).to_kind(tch::Kind::Float) *
--        (delta * (&abs_diff - 0.5 * delta));
--    (quadratic + linear).mean(tch::Kind::Float)
--}
--
--// Prediction accuracy calculation for monitoring
--fn calculate_prediction_accuracy(predictions: &[f64], targets: &[f64]) -> f64 {
--    if predictions.is_empty() || targets.is_empty() {
--        return 0.0;
--    }
--
--    let mse: f64 = predictions.iter()
--        .zip(targets.iter())
--        .map(|(p, t)| (p - t).powi(2))
--        .sum::<f64>() / predictions.len() as f64;
--
--    // Convert MSE to accuracy-like metric (higher is better)
--    1.0 / (1.0 + mse.sqrt())
--}
--
--
--
--
--
--
--
--fn convert_plateau_to_tensor(
--    plateau: &Plateau,
--    _tile: &Tile,        // Add underscore prefix
--    _deck: &Deck,        // Add underscore prefix
--    current_turn: usize,
--    total_turns: usize
--) -> Tensor {
--    let mut features = vec![0.0; 5 * 47]; // 5 channels
--
--    // Channel 1-3: Plateau (only use plateau data, not tile/deck)
--    for (i, t) in plateau.tiles.iter().enumerate() {
--        if i < 19 {
--            features[i] = (t.0 as f32 / 10.0).clamp(0.0, 1.0);
--            features[47 + i] = (t.1 as f32 / 10.0).clamp(0.0, 1.0);
--            features[2 * 47 + i] = (t.2 as f32 / 10.0).clamp(0.0, 1.0);
--        }
--    }
--
--    // Channel 4: Score Potential for each position
--    let potential_scores = compute_potential_scores(plateau);
--    for i in 0..19 {
--        features[3 * 47 + i] = potential_scores[i];
--    }
--
--    // Channel 5: Current Turn
--    let turn_normalized = current_turn as f32 / total_turns as f32;
--    for i in 0..19 {
--        features[4 * 47 + i] = turn_normalized;
--    }
--
--    Tensor::from_slice(&features).view([1, 5, 47, 1])
--}
--fn compute_potential_scores(plateau: &Plateau) -> Vec<f32> {
--    let mut scores = vec![0.0; 19]; // Potential score for each position
--
--    let patterns: Vec<(&[usize], i32, Box<dyn Fn(&Tile) -> i32>)> = vec![
--        (&[0, 1, 2], 3, Box::new(|tile: &Tile| tile.0)),
--        (&[3, 4, 5, 6], 4, Box::new(|tile: &Tile| tile.0)),
--        (&[7, 8, 9, 10, 11], 5, Box::new(|tile: &Tile| tile.0)),
--        (&[12, 13, 14, 15], 4, Box::new(|tile: &Tile| tile.0)),
--        (&[16, 17, 18], 3, Box::new(|tile: &Tile| tile.0)),
--        (&[0, 3, 7], 3, Box::new(|tile: &Tile| tile.1)),
--        (&[1, 4, 8, 12], 4, Box::new(|tile: &Tile| tile.1)),
--        (&[2, 5, 9, 13, 16], 5, Box::new(|tile: &Tile| tile.1)),
--        (&[6, 10, 14, 17], 4, Box::new(|tile: &Tile| tile.1)),
--        (&[11, 15, 18], 3, Box::new(|tile: &Tile| tile.1)),
--        (&[7, 12, 16], 3, Box::new(|tile: &Tile| tile.2)),
--        (&[3, 8, 13, 17], 4, Box::new(|tile: &Tile| tile.2)),
--        (&[0, 4, 9, 14, 18], 5, Box::new(|tile: &Tile| tile.2)),
--        (&[1, 5, 10, 15], 4, Box::new(|tile: &Tile| tile.2)),
--        (&[2, 6, 11], 3, Box::new(|tile: &Tile| tile.2)),
--    ];
--
--    for (indices, multiplier, selector) in &patterns {
--        let mut filled_values = Vec::new();
--        let mut empty_positions = Vec::new();
--
--        for &pos in *indices {
--            if plateau.tiles[pos] == Tile(0, 0, 0) {
--                empty_positions.push(pos);
--            } else {
--                filled_values.push(selector(&plateau.tiles[pos]) as f32);
--            }
--        }
--
--        // If at least one tile is placed in the pattern
--        if !filled_values.is_empty() {
--            let avg_filled_value = filled_values.iter().sum::<f32>() / filled_values.len() as f32;
--            let potential_score = avg_filled_value * (*multiplier as f32);
--
--            for &pos in empty_positions.iter() {
--                scores[pos] += potential_score / empty_positions.len() as f32; // Distribute potential score
--            }
--        }
--    }
--
--    scores
--}
--
--// Fix for alignment score function - add underscore prefix
--fn compute_alignment_score(plateau: &Plateau, position: usize, _tile: &Tile) -> f64 {
--    let patterns: Vec<(&[usize], Box<dyn Fn(&Tile) -> i32>)> = vec![
--        (&[0, 1, 2], Box::new(|t: &Tile| t.0)),
--        (&[3, 4, 5, 6], Box::new(|t: &Tile| t.0)),
--        (&[7, 8, 9, 10, 11], Box::new(|t: &Tile| t.0)),
--        (&[12, 13, 14, 15], Box::new(|t: &Tile| t.0)),
--        (&[16, 17, 18], Box::new(|t: &Tile| t.0)),
--        (&[0, 3, 7], Box::new(|t: &Tile| t.1)),
--        (&[1, 4, 8, 12], Box::new(|t: &Tile| t.1)),
--        (&[2, 5, 9, 13, 16], Box::new(|t: &Tile| t.1)),
--        (&[6, 10, 14, 17], Box::new(|t: &Tile| t.1)),
--        (&[11, 15, 18], Box::new(|t: &Tile| t.1)),
--        (&[7, 12, 16], Box::new(|t: &Tile| t.2)),
--        (&[3, 8, 13, 17], Box::new(|t: &Tile| t.2)),
--        (&[0, 4, 9, 14, 18], Box::new(|t: &Tile| t.2)),
--        (&[1, 5, 10, 15], Box::new(|t: &Tile| t.2)),
--        (&[2, 6, 11], Box::new(|t: &Tile| t.2)),
--    ];
--
--    let mut score = 0.0;
--
--    for (indices, selector) in patterns {
--        if indices.contains(&position) {
--            let values: Vec<i32> = indices
--                .iter()
--                .map(|&i| selector(&plateau.tiles[i]))
--                .filter(|&v| v != 0)
--                .collect();
--
--            if !values.is_empty() {
--                let sum = values.iter().sum::<i32>() as f64;
--                score += sum / values.len() as f64;
--            }
--        }
--    }
--
--    score
--}
--
--
--
--
--
--
--
--
--pub fn load_game_data(file_path: &str) -> Vec<MCTSResult> {
--    // Paths for the .pt files
--    let states_path = format!("{}_states.pt", file_path);
--    let positions_path = format!("{}_positions.pt", file_path);
--    let subscores_path = format!("{}_subscores.pt", file_path);
--
--    // Check if all files exist
--    if !Path::new(&states_path).exists() {
--        println!("‚ö†Ô∏è  Warning: '{}' not found. Returning empty dataset.", states_path);
--        return Vec::new();
--    }
--    if !Path::new(&positions_path).exists() {
--        println!("‚ö†Ô∏è  Warning: '{}' not found. Returning empty dataset.", positions_path);
--        return Vec::new();
--    }
--    if !Path::new(&subscores_path).exists() {
--        println!("‚ö†Ô∏è  Warning: '{}' not found. Returning empty dataset.", subscores_path);
--        return Vec::new();
--    }
--
--    println!("üöÄ Loading game data from .pt files...");
--
--    // Load the saved tensors
--    let state_tensor = Tensor::load(states_path).expect("Failed to load states");
--    let position_tensor = Tensor::load(positions_path).expect("Failed to load positions");
--    let subscore_tensor = Tensor::load(subscores_path).expect("Failed to load subscores");
--
--    // Convert them back into MCTSResult objects
--    let mut data = Vec::new();
--    for i in 0..state_tensor.size()[0] {
--        data.push(MCTSResult {
--            board_tensor: state_tensor.get(i),
--            best_position: position_tensor.get(i).int64_value(&[]) as usize,
--            subscore: subscore_tensor.get(i).double_value(&[]),
--        });
--    }
--    println!("‚úÖ Loaded {} game records.", data.len());
--    data
--}
--
--
--
--
--fn deserialize_game_data(line: &str) -> Option<MCTSResult> {
--    let parts: Vec<&str> = line.split(',').collect();
--
--    if parts.len() != 3 {
--        log::error!("Invalid data format: '{}'", line);
--        return None;
--    }
--
--    // Parse tensor
--    let state_values: Vec<f32> = parts[0]
--        .split_whitespace()
--        .map(|v| v.parse::<f32>())
--        .collect::<Result<Vec<f32>, _>>()
--        .unwrap_or_else(|_| {
--            log::error!("Failed to parse state tensor in line '{}'", line);
--            vec![]
--        });
--
--    if state_values.len() != 5 * 47 {
--        log::error!("ERROR: Parsed tensor has incorrect size {} (expected 235). Data: '{}'", state_values.len(), parts[0]);
--        return None;
--    }
--
--    let state_tensor = Tensor::from_slice(&state_values).view([1, 5, 47, 1]);
--
--    // Parse subscore
--    let subscore = parts[1].parse::<f64>().unwrap_or_else(|_| {
--        log::error!("Failed to parse subscore in line '{}'", line);
--        0.0
--    });
--
--    // Parse best position
--    let best_position = parts[2].parse::<usize>().unwrap_or_else(|_| {
--        log::error!("Failed to parse best_position in line '{}'", line);
--        0
--    });
--
--    Some(MCTSResult {
--        board_tensor: state_tensor,
--        subscore,
--        best_position,
--    })
--}
--
--
--
--
--fn save_game_data(file_path: &str, game_data: Vec<MCTSResult>) {
--    println!("üöÄ Saving game data to .pt files...");
--
--    let mut tensors = vec![];
--    let mut positions = vec![];
--    let mut subscores = vec![];
--
--    for result in game_data {
--        tensors.push(result.board_tensor.shallow_clone());
--        positions.push(result.best_position as i64);
--        subscores.push(result.subscore as f32);
--    }
--
--    // Cr√©ation des nouveaux tensors
--    let state_tensor = Tensor::stack(&tensors, 0);
--    let position_tensor = Tensor::from_slice(&positions).view([-1, 1]);
--    let subscore_tensor = Tensor::from_slice(&subscores).view([-1, 1]);
--
--    // üîÑ Append logic: charger les anciens tensors s'ils existent
--    let combined_states = if let Ok(prev) = Tensor::load(format!("{}_states.pt", file_path)) {
--        Tensor::cat(&[prev, state_tensor], 0)
--    } else {
--        state_tensor
--    };
--
--    let combined_positions = if let Ok(prev) = Tensor::load(format!("{}_positions.pt", file_path)) {
--        Tensor::cat(&[prev, position_tensor], 0)
--    } else {
--        position_tensor
--    };
--
--    let combined_subscores = if let Ok(prev) = Tensor::load(format!("{}_subscores.pt", file_path)) {
--        Tensor::cat(&[prev, subscore_tensor], 0)
--    } else {
--        subscore_tensor
--    };
--
--    // üîÑ Sauvegarde des tensors concat√©n√©s
--    if let Err(e) = combined_states.save(format!("{}_states.pt", file_path)) {
--        log::info!("‚ùå Error saving states: {:?}", e);
--    }
--    if let Err(e) = combined_positions.save(format!("{}_positions.pt", file_path)) {
--        log::info!("‚ùå Error saving positions: {:?}", e);
--    }
--    if let Err(e) = combined_subscores.save(format!("{}_subscores.pt", file_path)) {
--        log::info!("‚ùå Error saving subscores: {:?}", e);
--    }
--
--    log::info!("‚úÖ Save complete!");
--}
--
--
--fn tensor_to_vec(tensor: &Tensor) -> Vec<f32> {
--    // Flatten the tensor into a 1D array
--    let flattened = tensor.view(-1); // Reshape the tensor to a 1D view
--
--    // Convert each value in the flattened tensor to f32 and collect into a Vec
--    let mut vec = Vec::new();
--    for i in 0..flattened.size()[0] {
--        let value = flattened.i(i).double_value(&[]) as f32;
--        vec.push(value);
--    }
--
--    vec
--}
--
--
--fn serialize_tensor(tensor: Tensor) -> String {
--    let data: Vec<f32> = tensor_to_vec(&tensor); // Converts the slice to a Vec<f32>
--    data.iter()
--        .map(|v| v.to_string())
--        .collect::<Vec<_>>()
--        .join(" ")
--}
--#[derive(Debug)]
--pub struct MCTSResult {
--    pub board_tensor: Tensor,
--    pub best_position: usize,
--    pub subscore: f64,
--}
--
--impl Clone for MCTSResult {
--    fn clone(&self) -> Self {
--        MCTSResult {
--            board_tensor: self.board_tensor.shallow_clone(), // Manually clone the tensor
--            best_position: self.best_position,
--            subscore: self.subscore,
--        }
--    }
--}
--
--fn append_to_results_file(file_path: &str,  avg_score: f64) {
--    let timestamp = Utc::now().to_rfc3339();
--    let result_line = format!("{},{:.2}\n",timestamp,  avg_score );
--
--    let file = OpenOptions::new()
--        .create(true)
--        .append(true)
--        .open(file_path)
--        .expect("Unable to open results file");
--    let mut writer = BufWriter::new(file);
--    writer
--        .write_all(result_line.as_bytes())
--        .expect("Unable to write to results file");
--}
--async fn reconnect_websocket(
--    listener: &TcpListener,
--) -> Option<SplitSink<WebSocketStream<tokio::net::TcpStream>, Message>> {
--    match listener.accept().await {
--        Ok((stream, _)) => {
--            log::info!("Re-establishing WebSocket connection...");
--            let ws_stream = accept_async(stream).await.expect("Failed to accept WebSocket");
--            let (write, _) = ws_stream.split();
--            Some(write)
--        }
--        Err(e) => {
--            log::error!("Error while reconnecting WebSocket: {:?}", e);
--            None
--        }
--    }
--}
--async fn train_and_evaluate(
--    vs_policy: &nn::VarStore,
--    vs_value: &nn::VarStore,
--    policy_net: &mut PolicyNet,
--    value_net: &mut ValueNet,
--    optimizer_policy: &mut Optimizer,
--    optimizer_value: &mut Optimizer,
--    num_games: usize,
--    num_simulations: usize,
--    evaluation_interval: usize,
--    listener: Arc<TcpListener>,
--) {
--    let mut total_score = 0;
--    let mut games_played = 0;
--    let results_file = "results.csv";
--
--    while let Ok((stream, _)) = listener.accept().await {
--        let ws_stream = accept_async(stream).await.expect("Failed to accept WebSocket");
--        let (mut write, _) = ws_stream.split();
--        let mut scores_by_position: HashMap<usize, Vec<i32>> = HashMap::new();
--        let mut scores = Vec::new(); // Stocke les scores
--        let evaluation_interval_average = 10;
--
--        while games_played < num_games {
--
--            log::info!(
--                "Starting training iteration {}/{}...",
--                games_played + 1,
--                num_games
--            );
--            log::info!("\nüöÄ Starting Batch {}", games_played / evaluation_interval + 1);
--
--            let mut batch_games_played = 0; // Tracks games processed in this evaluation interval
--
--            let max_memory_size = 1000; // Store last 500 games
--
--            for game in 0..evaluation_interval {
--                let mut deck = create_shuffle_deck();
--                let mut plateau = create_plateau_empty();
--                let mut game_data = Vec::new();
--                let mut first_move: Option<(usize, Tile)> = None;
--                let total_turns = 19; // The number of moves in the game
--                let mut current_turn = 0;
--                while !is_plateau_full(&plateau) {
--                    let tile_index = rng().random_range(0..deck.tiles.len());
--                    let chosen_tile = deck.tiles[tile_index];
--                    // ‚úÖ **Send preview before placement**
--                    // ‚úÖ **INSERT YOUR NEW CODE HERE**
--                    let chosen_tile_image = format!("../image/{}{}{}.png", chosen_tile.0, chosen_tile.1, chosen_tile.2);
--                    let payload = serde_json::json!({
--        "next_tile": chosen_tile_image,
--        "plateau_tiles": generate_tile_image_names(&plateau.tiles)
--    });
--                    let serialized = serde_json::to_string(&payload).unwrap();
--                    write.send(Message::Text(serialized)).await.unwrap();
--
--                    let game_result = mcts_find_best_position_for_tile_with_nn(
--                        &mut plateau,
--                        &mut deck,
--                        chosen_tile,
--                        policy_net,
--                        value_net,
--                        num_simulations,
--                        current_turn,
--                        total_turns,
--                    );
--
--                    let best_position = game_result.best_position;
--                    if first_move.is_none() {
--                        first_move = Some((best_position, chosen_tile));
--                    }
--                    plateau.tiles[best_position] = chosen_tile;
--                    deck = replace_tile_in_deck(&deck, &chosen_tile);
--                    // ‚úÖ INSERT THIS TO SEND SCORE TO CLIENT
--                    let current_score = result(&plateau);
--                    let score_payload = serde_json::json!({
--    "type": "score_update",
--    "current_score": current_score,
--});
--                    let serialized_score = serde_json::to_string(&score_payload).unwrap();
--                    if let Err(e) = write.send(Message::Text(serialized_score)).await {
--                        log::error!("WebSocket error when sending score: {:?}", e);
--                        if let Some(new_write) = reconnect_websocket(&listener).await {
--                            write = new_write;
--                        } else {
--                            log::error!("Failed to reconnect WebSocket. Exiting...");
--                            break;
--                        }
--                    }
--
--                    game_data.push(game_result); // Store training data
--
--                    // ‚úÖ **INSERT YOUR NEW CODE HERE**
--                    let payload_after_placement = serde_json::json!({
--        "next_tile": null, // Clear preview
--        "plateau_tiles": generate_tile_image_names(&plateau.tiles) // new updated state
--    });
--                    let serialized = serde_json::to_string(&payload_after_placement).unwrap();
--
--                    // ‚úÖ Handle WebSocket disconnections
--                    if let Err(e) = write.send(Message::Text(serialized.clone())).await {
--                        log::error!("WebSocket error: {:?}. Attempting to reconnect...", e);
--
--                        // **Reconnect WebSocket**
--                        if let Some(new_write) = reconnect_websocket(&listener).await {
--                            write = new_write;
--                        } else {
--                            log::error!("Failed to reconnect WebSocket. Exiting...");
--                            break;
--                        }
--                    }
--                    current_turn += 1; // Increment turn counter each time a tile is placed
--
--                }
--
--                let final_score = result(&plateau);
--
--                if let Some((position, _)) = first_move {
--                    scores_by_position
--                        .entry(position)
--                        .or_insert_with(Vec::new)
--                        .push(final_score);
--                }
--
--                let mut batch_game_data = Vec::new();
--
--                // Prioritized historical data
--                let prioritized_data: Vec<MCTSResult> = load_game_data("game_data")
--                    .into_iter().filter(|r| r.subscore > 100.0) // Only select high-score games
--                    .take(50) // Limit to 50 samples to prevent overfitting
--                    .collect();
--
--                // Add historical data to batch
--                batch_game_data.extend(prioritized_data);
--
--                // Add current game's data to batch
--                batch_game_data.extend(game_data.iter().map(|result| MCTSResult {
--                    best_position: result.best_position,
--                    board_tensor: result.board_tensor.shallow_clone(),
--                    subscore: result.subscore,
--                }));
--
--                // Keep only last max_memory_size experiences
--                if batch_game_data.len() > max_memory_size {
--                    let to_remove = batch_game_data.len() - max_memory_size;
--                    batch_game_data.drain(0..to_remove); // Remove oldest data
--                }
--
--                // Train in batches
--                let batch_size = 10;
--                for batch in batch_game_data.chunks(batch_size) {
--                    train_network_with_game_data(
--                        &vs_policy,
--                        &vs_value,
--                        batch, // Use each batch directly
--                        final_score.into(),
--                        policy_net,
--                        value_net,
--                        optimizer_policy,
--                        optimizer_value,
--                    );
--                }
--
--                log::info!("Game {} finished with score: {}", game + 1, final_score);
--                scores.push(final_score);
--
--                // Update batch-specific counters
--                batch_games_played += 1;
--                total_score += final_score;
--
--                if game % evaluation_interval_average == 0 && game != 0 {
--                    let moyenne: f64 = scores.iter().sum::<i32>() as f64 / scores.len() as f64;
--                    log::info!("üìä [Batch {}] Avg Score: {:.2} | Games Played: {}", games_played / evaluation_interval, moyenne, games_played);
--                    log::info!("batch {} - Score moyen: {:.2}", game, moyenne);
--                    write.send(Message::Text(format!("GAME_RESULT:{}", moyenne))).await.unwrap();
--                }
--
--                // Save current game data for future training
--                save_game_data("game_data", game_data);
--            }
--
--
--            // Update main game counters
--            games_played += batch_games_played;
--
--            // Append results to the file
--            let avg_score = total_score as f64 / games_played as f64;
--            append_to_results_file(results_file,  avg_score);
--
--            // Calculate and display averages
--            let mut averages: Vec<(usize, f64)> = scores_by_position
--                .iter()
--                .map(|(position, scores)| {
--                    let average_score: f64 =
--                        scores.iter().sum::<i32>() as f64 / scores.len() as f64;
--                    (*position, average_score)
--                })
--                .collect();
--
--            averages.sort_by(|a, b| {
--                b.1.partial_cmp(&a.1)
--                    .unwrap_or(std::cmp::Ordering::Equal)
--            });
--
--            log::info!("\n--- Average Scores by First Position (Sorted) ---");
--            for (position, average_score) in averages {
--                log::info!("Position: {}, Average Score: {:.2}", position, average_score);
--            }
--
--            // Evaluate model after each interval
--            evaluate_model(policy_net, value_net,num_simulations).await;
--
--            log::info!(
--                "Games Played: {}, Total Score: {}, Avg Score: {:.2}",
--                games_played,
--                total_score,
--                total_score as f32 / games_played as f32
--            );
--            let model_path = "model_weights";
--            // Save model weights
--            log::info!("Saving models to {}", model_path);
--            log::info!("Saving model weights...");
--            if let Err(e) = policy_net.save_model(vs_policy,"model_weights/policy/policy.params") {
--                log::error!("Error saving PolicyNet weights: {:?}", e);
--            }
--            if let Err(e) = value_net.save_model(vs_value,"model_weights/value/value.params") {
--                log::error!("Error saving ValueNet weights: {:?}", e);
--            }
--        }
--        break; // Exit after handling one connection
--    }
--}
--
--async fn evaluate_model(
--    policy_net: &PolicyNet,
--    value_net: &ValueNet,
--    num_simulations: usize,
--) {
--    log::info!("Evaluating model...");
--    let mut scores = Vec::new();
--
--    for _ in 0..10 {
--        let mut deck = create_shuffle_deck();
--        let mut plateau = create_plateau_empty();
--        let total_turns = 19; // The number of moves in the game
--        let mut current_turn = 0;
--        while !is_plateau_full(&plateau) {
--            let tile_index = rng().random_range(0..deck.tiles.len());
--            let chosen_tile = deck.tiles[tile_index];
--            let game_result = mcts_find_best_position_for_tile_with_nn(
--                &mut plateau,
--                &mut deck,
--                chosen_tile,
--                policy_net,
--                value_net,
--                num_simulations,
--                current_turn,
--                total_turns,
--            );
--            let best_position = game_result.best_position;
--            plateau.tiles[best_position] = chosen_tile;
--            deck = replace_tile_in_deck(&deck, &chosen_tile);
--            current_turn += 1; // Increment turn counter each time a tile is placed
--
--        }
--
--        let game_score = result(&plateau);
--        scores.push(game_score);
--    }
--
--    let avg_score: f64 = scores.iter().copied().sum::<i32>() as f64 / scores.len() as f64;
--    log::info!("Model Evaluation Complete. Avg Score: {:.2}", avg_score);
--    // **Stop ping task**
--}
--
--
--/// Checks if the plateau is full
--fn is_plateau_full(plateau: &Plateau) -> bool {
--    plateau.tiles.iter().all(|tile| *tile != Tile(0, 0, 0))
--}
--
--/// Finds the best move using MCTS
--
--
--/// Simulates num_simulations games and returns the average score
--
--fn simulate_games(plateau: Plateau, deck: Deck) -> i32 {
--    let mut simulated_plateau = plateau.clone();
--    let simulated_deck = deck.clone();
--    let mut legal_moves = get_legal_moves(simulated_plateau.clone());
--
--    // Filter out invalid tiles (0, 0, 0)
--    let mut valid_tiles: Vec<Tile> = simulated_deck
--        .tiles
--        .iter()
--        .cloned()
--        .filter(|tile| *tile != Tile(0, 0, 0))
--        .collect();
--
--    let mut rng = rand::rng(); // Fixed: Use new API
--
--    while !is_plateau_full(&simulated_plateau) {
--        if legal_moves.is_empty() || valid_tiles.is_empty() {
--            break;
--        }
--
--        // Fixed: Use new rand API
--        let position_index = rng.random_range(0..legal_moves.len());
--        let position = legal_moves.swap_remove(position_index); // Swap-remove for O(1) removal
--
--        let tile_index = rng.random_range(0..valid_tiles.len());
--        let chosen_tile = valid_tiles.swap_remove(tile_index); // Swap-remove for O(1) removal
--
--        // Place the chosen tile
--        simulated_plateau.tiles[position] = chosen_tile;
--    }
--
--    result(&simulated_plateau) // Compute and return the result
--}
- 
- 
- 
--/// Get all legal moves (empty positions) on the plateau
--fn get_legal_moves(plateau: Plateau) -> Vec<usize> {
--    plateau
--        .tiles
--        .iter()
--        .enumerate()
--        .filter_map(|(i, tile)| if *tile == Tile(0, 0, 0) { Some(i) } else { None })
--        .collect()
--}
-\ No newline at end of file
-diff --git a/src/mcts/algorithm.rs b/src/mcts/algorithm.rs
-index e69de29..88c272f 100644
---- a/src/mcts/algorithm.rs
-+++ b/src/mcts/algorithm.rs
-@@ -0,0 +1,255 @@
-+use std::collections::HashMap;
-+use tch::IndexOp;
-+use crate::game::deck::Deck;
-+use crate::game::get_legal_moves::get_legal_moves;
-+use crate::game::plateau::Plateau;
-+use crate::game::plateau_is_full::is_plateau_full;
-+use crate::game::remove_tile_from_deck::replace_tile_in_deck;
-+use crate::game::simulate_game::simulate_games;
-+use crate::game::tile::Tile;
-+use crate::mcts::mcts_result::MCTSResult;
-+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
-+use crate::neural::tensor_conversion::convert_plateau_to_tensor;
-+use crate::scoring::scoring::result;
-+use crate::strategy::position_evaluation::enhanced_position_evaluation;
-+use crate::utils::random_index::random_index;
-+
-+pub fn mcts_find_best_position_for_tile_with_nn(
-+    plateau: &mut Plateau,
-+    deck: &mut Deck,
-+    chosen_tile: Tile,
-+    policy_net: &PolicyNet,
-+    value_net: &ValueNet,
-+    num_simulations: usize,
-+    current_turn: usize,
-+    total_turns: usize,
-+) -> MCTSResult {
-+    let legal_moves = get_legal_moves(plateau.clone());
-+    if legal_moves.is_empty() {
-+        return MCTSResult {
-+            best_position: 0,
-+            board_tensor: convert_plateau_to_tensor(
-+                plateau,
-+                &chosen_tile,
-+                deck,
-+                current_turn,
-+                total_turns,
-+            ),
-+            subscore: 0.0,
-+        };
-+    }
-+
-+    let board_tensor =
-+        convert_plateau_to_tensor(plateau, &chosen_tile, deck, current_turn, total_turns);
-+    let policy_logits = policy_net.forward(&board_tensor, false);
-+    let policy = policy_logits.log_softmax(-1, tch::Kind::Float).exp(); // Log-softmax improves numerical stability
-+
-+    let mut visit_counts: HashMap<usize, usize> = HashMap::new();
-+    let mut total_scores: HashMap<usize, f64> = HashMap::new();
-+    let mut ucb_scores: HashMap<usize, f64> = HashMap::new();
-+    let mut total_visits: i32 = 0;
-+
-+    for &position in &legal_moves {
-+        visit_counts.insert(position, 0);
-+        total_scores.insert(position, 0.0);
-+        ucb_scores.insert(position, f64::NEG_INFINITY);
-+    }
-+
-+    let c_puct = if current_turn < 5 {
-+        4.2 // Plus d'exploitation en d√©but de partie (positions critiques)
-+    } else if current_turn > 15 {
-+        3.0 // Plus d'exploration en fin de partie (adaptation)
-+    } else {
-+        3.8 // √âquilibre pour le milieu de partie
-+    };
-+
-+    // **Compute ValueNet scores for all legal moves**
-+    let mut value_estimates = HashMap::new();
-+    let mut min_value = f64::INFINITY;
-+    let mut max_value = f64::NEG_INFINITY;
-+
-+    for &position in &legal_moves {
-+        let mut temp_plateau = plateau.clone();
-+        let mut temp_deck = deck.clone();
-+
-+        temp_plateau.tiles[position] = chosen_tile;
-+        temp_deck = replace_tile_in_deck(&temp_deck, &chosen_tile);
-+        let board_tensor_temp = convert_plateau_to_tensor(
-+            &temp_plateau,
-+            &chosen_tile,
-+            &temp_deck,
-+            current_turn,
-+            total_turns,
-+        );
-+
-+        let pred_value = value_net
-+            .forward(&board_tensor_temp, false)
-+            .double_value(&[]);
-+        let pred_value = pred_value.clamp(-1.0, 1.0);
-+
-+        // Track min and max for dynamic pruning
-+        min_value = min_value.min(pred_value);
-+        max_value = max_value.max(pred_value);
-+
-+        value_estimates.insert(position, pred_value);
-+    }
-+
-+    // **Dynamic Pruning Strategy**
-+    let value_threshold = if current_turn < 8 {
-+        min_value + (max_value - min_value) * 0.1 // Garder plus de candidats en d√©but
-+    } else {
-+        min_value + (max_value - min_value) * 0.15 // Pruning moins agressif
-+    };
-+
-+    for _ in 0..num_simulations {
-+        let mut moves_with_prior: Vec<_> = legal_moves
-+            .iter()
-+            .filter(|&&pos| value_estimates[&pos] >= value_threshold) // Prune weak moves
-+            .map(|&pos| (pos, policy.i((0, pos as i64)).double_value(&[])))
-+            .collect();
-+
-+        moves_with_prior.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
-+
-+        let top_k = usize::min(
-+            moves_with_prior.len(),
-+            ((total_visits as f64).sqrt() as usize).max(5),
-+        );
-+
-+        let subset_moves: Vec<usize> = moves_with_prior
-+            .iter()
-+            .take(top_k)
-+            .map(|&(pos, _)| pos)
-+            .collect();
-+
-+        for &position in &subset_moves {
-+            let mut temp_plateau = plateau.clone();
-+            let mut temp_deck = deck.clone();
-+
-+            temp_plateau.tiles[position] = chosen_tile;
-+            temp_deck = replace_tile_in_deck(&temp_deck, &chosen_tile);
-+
-+            let value_estimate = *value_estimates.get(&position).unwrap_or(&0.0);
-+
-+            // **Improved Adaptive Rollout Strategy**
-+            let rollout_count = match value_estimate {
-+                x if x > 8.0 => 2, // Very strong move -> minimal rollouts
-+                x if x > 6.0 => 4, // Strong move -> fewer rollouts
-+                x if x > 4.0 => 6, // Decent move -> moderate rollouts
-+                _ => 8,            // Uncertain move -> more rollouts
-+            };
-+
-+            let mut total_simulated_score = 0.0;
-+
-+            for _ in 0..rollout_count {
-+                let mut lookahead_plateau = temp_plateau.clone();
-+                let mut lookahead_deck = temp_deck.clone();
-+
-+                // üîÆ √âtape 1.1 ‚Äî Tirer une tuile hypoth√©tique (T2)
-+                if lookahead_deck.tiles.is_empty() {
-+                    continue;
-+                }
-+                let tile2_index = random_index(lookahead_deck.tiles.len());
-+                let tile2 = lookahead_deck.tiles[tile2_index];
-+
-+                // üîç √âtape 1.2 ‚Äî Simuler tous les placements possibles de cette tuile
-+                let second_moves = get_legal_moves(lookahead_plateau.clone());
-+
-+                let mut best_score_for_tile2: f64 = 0.0;
-+
-+                for &pos2 in &second_moves {
-+                    let mut plateau2 = lookahead_plateau.clone();
-+                    let mut deck2 = lookahead_deck.clone();
-+
-+                    plateau2.tiles[pos2] = tile2;
-+                    deck2 = replace_tile_in_deck(&deck2, &tile2);
-+
-+                    let score = simulate_games(plateau2.clone(), deck2.clone()) as f64;
-+                    best_score_for_tile2 = best_score_for_tile2.max(score);
-+                }
-+
-+                total_simulated_score += best_score_for_tile2;
-+            }
-+
-+            let simulated_score = total_simulated_score / rollout_count as f64;
-+
-+            let visits = visit_counts.entry(position).or_insert(0);
-+            *visits += 1;
-+            total_visits += 1;
-+
-+            let total_score = total_scores.entry(position).or_insert(0.0);
-+            *total_score += simulated_score as f64;
-+
-+            let exploration_param = c_puct * (total_visits as f64).ln() / (1.0 + *visits as f64);
-+            let prior_prob = policy.i((0, position as i64)).double_value(&[]);
-+            let average_score = *total_score / (*visits as f64);
-+            // üß™ Reduce weight of rollout average
-+            let enhanced_eval =
-+                enhanced_position_evaluation(&temp_plateau, position, &chosen_tile, current_turn);
-+
-+            // Int√©grer dans le calcul UCB
-+            let mut ucb_score = (average_score * 0.5)
-+                + exploration_param * (prior_prob.sqrt())
-+                + 0.25 * value_estimate.clamp(0.0, 2.0)
-+                + 0.1 * enhanced_eval; // Nouveau facteur d'√©valuation
-+
-+            // üî• Explicit Priority Logic HERE üî•
-+            // 1Ô∏è‚É£ Ajoute cette fonction en dehors de ta mcts_find_best_position_for_tile_with_nn
-+
-+            // 2Ô∏è‚É£ Int√®gre ceci dans ta boucle ucb_scores, juste apr√®s le boost fixe
-+
-+            if chosen_tile.0 == 9 && [7, 8, 9, 10, 11].contains(&position) {
-+                ucb_score += 10000.0; // double boost
-+            } else if chosen_tile.0 == 5 && [3, 4, 5, 6, 12, 13, 14, 15].contains(&position) {
-+                ucb_score += 8000.0;
-+            } else if chosen_tile.0 == 1 && [0, 1, 2, 16, 17, 18].contains(&position) {
-+                ucb_score += 6000.0;
-+            }
-+
-+            // üî• Alignment Priority Logic üî•
-+
-+            ucb_scores.insert(position, ucb_score);
-+        }
-+    }
-+
-+    // Select the move with the highest UCB score
-+    let best_position = legal_moves
-+        .into_iter()
-+        .max_by(|&a, &b| {
-+            ucb_scores
-+                .get(&a)
-+                .unwrap_or(&f64::NEG_INFINITY)
-+                .partial_cmp(ucb_scores.get(&b).unwrap_or(&f64::NEG_INFINITY))
-+                .unwrap_or(std::cmp::Ordering::Equal)
-+        })
-+        .unwrap_or(0);
-+
-+    // **NEW: Simulate the Rest of the Game to Get Final Score**
-+    let mut final_plateau = plateau.clone();
-+    let mut final_deck = deck.clone();
-+    final_plateau.tiles[best_position] = chosen_tile;
-+    final_deck = replace_tile_in_deck(&final_deck, &chosen_tile);
-+
-+    while !is_plateau_full(&final_plateau) {
-+        let tile_index = random_index(final_deck.tiles.len());
-+        let random_tile = final_deck.tiles[tile_index];
-+
-+        let available_moves = get_legal_moves(final_plateau.clone());
-+        if available_moves.is_empty() {
-+            break;
-+        }
-+
-+        let random_position = available_moves[random_index(available_moves.len())];
-+        final_plateau.tiles[random_position] = random_tile;
-+        final_deck = replace_tile_in_deck(&final_deck, &random_tile);
-+    }
-+
-+    let final_score = result(&final_plateau); // Get actual game score
-+
-+    log::info!("ü§ñ Pos:{} Score:{}", best_position, final_score as i32);
-+
-+    MCTSResult {
-+        best_position,
-+        board_tensor,
-+        subscore: final_score as f64, // Store real final score, not UCB score
-+    }
-+}
-\ No newline at end of file
-diff --git a/src/mcts/mod.rs b/src/mcts/mod.rs
-index e69de29..9a9906a 100644
---- a/src/mcts/mod.rs
-+++ b/src/mcts/mod.rs
-@@ -0,0 +1,3 @@
-+pub mod mcts_node;
-+pub mod mcts_result;
-+pub mod algorithm;
-\ No newline at end of file
-diff --git a/src/mcts_vs_human.rs b/src/mcts_vs_human.rs
-index 95303c3..bec6730 100644
---- a/src/mcts_vs_human.rs
-+++ b/src/mcts_vs_human.rs
-@@ -1,19 +1,20 @@
--use crate::create_shuffle_deck::create_shuffle_deck;
--use crate::create_plateau_empty::create_plateau_empty;
--use crate::remove_tile_from_deck::replace_tile_in_deck;
-+use crate::game::create_deck::create_deck;
-+use crate::game::remove_tile_from_deck::replace_tile_in_deck;
- use crate::generate_tile_image_names;
--use crate::result::result;
--use crate::test::{Deck, Plateau, Tile};
--use crate::{mcts_find_best_position_for_tile_with_nn, is_plateau_full};
-+use crate::{is_plateau_full};
- 
- use serde_json::json;
- use tokio_tungstenite::tungstenite::protocol::Message;
- use tokio_tungstenite::WebSocketStream;
- use tokio::net::TcpStream;
--use futures_util::{StreamExt, SinkExt};
-+use futures_util::{SinkExt, StreamExt};
- use futures_util::stream::SplitSink;
- use rand::Rng;
--use crate::policy_value_net::{PolicyNet, ValueNet};
-+use crate::game::plateau::create_plateau_empty;
-+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
-+use crate::game::tile::Tile;
-+use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
-+use crate::scoring::scoring::result;
- 
- pub async fn play_mcts_vs_human(
-     policy_net: &PolicyNet,
-@@ -22,7 +23,7 @@ pub async fn play_mcts_vs_human(
-     write: &mut SplitSink<WebSocketStream<TcpStream>, Message>,
-     read: &mut (impl StreamExt<Item = Result<Message, tokio_tungstenite::tungstenite::Error>> + Unpin),
- ) {
--    let mut deck = create_shuffle_deck();
-+    let mut deck = create_deck();
-     let mut plateau_human = create_plateau_empty();
-     let mut plateau_mcts = create_plateau_empty();
- 
-diff --git a/src/mod.rs b/src/mod.rs
-index e69de29..909b9ab 100644
---- a/src/mod.rs
-+++ b/src/mod.rs
-@@ -0,0 +1,11 @@
-+pub mod game;
-+pub mod mcts;
-+
-+pub mod utils;
-+pub mod neural;
-+pub mod strategy;
-+pub mod scoring;
-+
-+pub mod data;
-+
-+pub mod training;
-\ No newline at end of file
-diff --git a/src/neural/mod.rs b/src/neural/mod.rs
-index e69de29..9082c6e 100644
---- a/src/neural/mod.rs
-+++ b/src/neural/mod.rs
-@@ -0,0 +1,4 @@
-+pub mod res_net_block;
-+pub mod policy_value_net;
-+pub mod tensor_conversion;
-+pub mod training;
-\ No newline at end of file
-diff --git a/src/neural/res_net_block.rs b/src/neural/res_net_block.rs
-index e9f3411..e40b131 100644
---- a/src/neural/res_net_block.rs
-+++ b/src/neural/res_net_block.rs
-@@ -1,6 +1,6 @@
- use tch::{nn, Tensor};
- 
--use crate::policy_value_net::initialize_weights;
-+use crate::neural::policy_value_net::initialize_weights;
- 
- /// Residual Block
- pub struct ResNetBlock {
-diff --git a/src/neural/tensor_conversion.rs b/src/neural/tensor_conversion.rs
-index e69de29..95b6d19 100644
---- a/src/neural/tensor_conversion.rs
-+++ b/src/neural/tensor_conversion.rs
-@@ -0,0 +1,84 @@
-+use tch::Tensor;
-+use crate::game::deck::Deck;
-+use crate::game::plateau::Plateau;
-+use crate::game::tile::Tile;
-+
-+pub fn convert_plateau_to_tensor(
-+    plateau: &Plateau,
-+    _tile: &Tile, // Add underscore prefix
-+    _deck: &Deck, // Add underscore prefix
-+    current_turn: usize,
-+    total_turns: usize,
-+) -> Tensor {
-+    let mut features = vec![0.0; 5 * 47]; // 5 channels
-+
-+    // Channel 1-3: Plateau (only use plateau data, not tile/deck)
-+    for (i, t) in plateau.tiles.iter().enumerate() {
-+        if i < 19 {
-+            features[i] = (t.0 as f32 / 10.0).clamp(0.0, 1.0);
-+            features[47 + i] = (t.1 as f32 / 10.0).clamp(0.0, 1.0);
-+            features[2 * 47 + i] = (t.2 as f32 / 10.0).clamp(0.0, 1.0);
-+        }
-+    }
-+
-+    // Channel 4: Score Potential for each position
-+    let potential_scores = compute_potential_scores(plateau);
-+    for i in 0..19 {
-+        features[3 * 47 + i] = potential_scores[i];
-+    }
-+
-+    // Channel 5: Current Turn
-+    let turn_normalized = current_turn as f32 / total_turns as f32;
-+    for i in 0..19 {
-+        features[4 * 47 + i] = turn_normalized;
-+    }
-+
-+    Tensor::from_slice(&features).view([1, 5, 47, 1])
-+}
-+fn compute_potential_scores(plateau: &Plateau) -> Vec<f32> {
-+    let mut scores = vec![0.0; 19]; // Potential score for each position
-+
-+    let patterns: Vec<(&[usize], i32, Box<dyn Fn(&Tile) -> i32>)> = vec![
-+        (&[0, 1, 2], 3, Box::new(|tile: &Tile| tile.0)),
-+        (&[3, 4, 5, 6], 4, Box::new(|tile: &Tile| tile.0)),
-+        (&[7, 8, 9, 10, 11], 5, Box::new(|tile: &Tile| tile.0)),
-+        (&[12, 13, 14, 15], 4, Box::new(|tile: &Tile| tile.0)),
-+        (&[16, 17, 18], 3, Box::new(|tile: &Tile| tile.0)),
-+        (&[0, 3, 7], 3, Box::new(|tile: &Tile| tile.1)),
-+        (&[1, 4, 8, 12], 4, Box::new(|tile: &Tile| tile.1)),
-+        (&[2, 5, 9, 13, 16], 5, Box::new(|tile: &Tile| tile.1)),
-+        (&[6, 10, 14, 17], 4, Box::new(|tile: &Tile| tile.1)),
-+        (&[11, 15, 18], 3, Box::new(|tile: &Tile| tile.1)),
-+        (&[7, 12, 16], 3, Box::new(|tile: &Tile| tile.2)),
-+        (&[3, 8, 13, 17], 4, Box::new(|tile: &Tile| tile.2)),
-+        (&[0, 4, 9, 14, 18], 5, Box::new(|tile: &Tile| tile.2)),
-+        (&[1, 5, 10, 15], 4, Box::new(|tile: &Tile| tile.2)),
-+        (&[2, 6, 11], 3, Box::new(|tile: &Tile| tile.2)),
-+    ];
-+
-+    for (indices, multiplier, selector) in &patterns {
-+        let mut filled_values = Vec::new();
-+        let mut empty_positions = Vec::new();
-+
-+        for &pos in *indices {
-+            if plateau.tiles[pos] == Tile(0, 0, 0) {
-+                empty_positions.push(pos);
-+            } else {
-+                filled_values.push(selector(&plateau.tiles[pos]) as f32);
-+            }
-+        }
-+
-+        // If at least one tile is placed in the pattern
-+        if !filled_values.is_empty() {
-+            let avg_filled_value = filled_values.iter().sum::<f32>() / filled_values.len() as f32;
-+            let potential_score = avg_filled_value * (*multiplier as f32);
-+
-+            for &pos in empty_positions.iter() {
-+                scores[pos] += potential_score / empty_positions.len() as f32; // Distribute potential score
-+            }
-+        }
-+    }
-+
-+    scores
-+}
-+
-diff --git a/src/neural/training/gradient_clipping.rs b/src/neural/training/gradient_clipping.rs
-index e69de29..18052aa 100644
---- a/src/neural/training/gradient_clipping.rs
-+++ b/src/neural/training/gradient_clipping.rs
-@@ -0,0 +1,95 @@
-+//! Gestion des gradients et clipping pour stabiliser l'entra√Ænement
-+
-+use tch::nn;
-+
-+/// R√©sultat du clipping des gradients
-+#[derive(Debug)]
-+pub struct GradientClippingResult {
-+    pub max_grad_value: f64,
-+    pub max_grad_policy: f64,
-+}
-+
-+/// Applique un clipping am√©lior√© des gradients pour les r√©seaux value et policy
-+pub fn enhanced_gradient_clipping(
-+    vs_value: &nn::VarStore,
-+    vs_policy: &nn::VarStore,
-+) -> GradientClippingResult {
-+    let max_grad_value = clip_value_network_gradients(vs_value);
-+    let max_grad_policy = clip_policy_network_gradients(vs_policy);
-+
-+    log_gradient_norms(max_grad_value, max_grad_policy);
-+
-+    GradientClippingResult {
-+        max_grad_value,
-+        max_grad_policy,
-+    }
-+}
-+
-+/// Applique un clipping agressif pour le r√©seau de valeur
-+fn clip_value_network_gradients(vs_value: &nn::VarStore) -> f64 {
-+    let mut max_grad_value: f64 = 0.0;
-+
-+    tch::no_grad(|| {
-+        for (_name, tensor) in vs_value.variables() {
-+            if tensor.grad().defined() {
-+                let grad_norm = tensor.grad().norm().double_value(&[]);
-+                max_grad_value = max_grad_value.max(grad_norm);
-+
-+                // Clipping tr√®s agressif pour stabilit√©
-+                tensor.grad().clamp_(-0.5, 0.5);
-+            }
-+        }
-+    });
-+
-+    max_grad_value
-+}
-+
-+/// Applique un clipping mod√©r√© pour le r√©seau de policy
-+fn clip_policy_network_gradients(vs_policy: &nn::VarStore) -> f64 {
-+    let mut max_grad_policy: f64 = 0.0;
-+
-+    tch::no_grad(|| {
-+        for (_name, tensor) in vs_policy.variables() {
-+            if tensor.grad().defined() {
-+                let grad_norm = tensor.grad().norm().double_value(&[]);
-+                max_grad_policy = max_grad_policy.max(grad_norm);
-+
-+                // Clipping mod√©r√©
-+                tensor.grad().clamp_(-1.0, 1.0);
-+            }
-+        }
-+    });
-+
-+    max_grad_policy
-+}
-+
-+/// Log les normes de gradients si elles sont √©lev√©es
-+fn log_gradient_norms(max_grad_value: f64, max_grad_policy: f64) {
-+    if max_grad_value > 1.0 {
-+        log::warn!("üî• Value grad norm: {:.3}", max_grad_value);
-+    }
-+    if max_grad_policy > 2.0 {
-+        log::warn!("üî• Policy grad norm: {:.3}", max_grad_policy);
-+    }
-+}
-+
-+/// Version simple du clipping des gradients
-+pub fn simple_gradient_clipping(
-+    vs: &nn::VarStore,
-+    max_norm: f64,
-+) -> f64 {
-+    let mut max_grad: f64 = 0.0;
-+
-+    tch::no_grad(|| {
-+        for (_name, tensor) in vs.variables() {
-+            if tensor.grad().defined() {
-+                let grad_norm = tensor.grad().norm().double_value(&[]);
-+                max_grad = max_grad.max(grad_norm);
-+
-+                tensor.grad().clamp_(-max_norm, max_norm);
-+            }
-+        }
-+    });
-+
-+    max_grad
-+}
-\ No newline at end of file
-diff --git a/src/neural/training/mod.rs b/src/neural/training/mod.rs
-index e69de29..471498a 100644
---- a/src/neural/training/mod.rs
-+++ b/src/neural/training/mod.rs
-@@ -0,0 +1,5 @@
-+//! Module d'entra√Ænement - Optimisation et stabilisation
-+
-+pub mod gradient_clipping;
-+pub mod normalization;
-+pub mod trainer;
-diff --git a/src/neural/training/normalization.rs b/src/neural/training/normalization.rs
-index e69de29..c2a44c6 100644
---- a/src/neural/training/normalization.rs
-+++ b/src/neural/training/normalization.rs
-@@ -0,0 +1,66 @@
-+//! Normalisation robuste des donn√©es pour l'entra√Ænement
-+
-+use tch::{Tensor, IndexOp};
-+
-+/// Applique une normalisation robuste bas√©e sur la m√©diane (MAD)
-+pub fn robust_state_normalization(state: &Tensor) -> Tensor {
-+    let clamped = clamp_extreme_values(state);
-+    let median = calculate_median(&clamped);
-+    let mad = calculate_mad(&clamped, median);
-+
-+    normalize_with_mad(&clamped, median, mad)
-+}
-+
-+/// Clamp les valeurs extr√™mes pour √©viter les outliers
-+fn clamp_extreme_values(state: &Tensor) -> Tensor {
-+    state.clamp(-10.0, 10.0)
-+}
-+
-+/// Calcule la m√©diane d'un tensor
-+fn calculate_median(tensor: &Tensor) -> f64 {
-+    let flattened = tensor.view(-1);
-+    let sorted = flattened.sort(0, false).0;
-+    let median_idx = sorted.size()[0] / 2;
-+    sorted.i(median_idx).double_value(&[])
-+}
-+
-+/// Calcule la Median Absolute Deviation (MAD)
-+fn calculate_mad(tensor: &Tensor, median: f64) -> f64 {
-+    let flattened = tensor.view(-1);
-+    let deviations = (flattened - median).abs();
-+    let sorted_dev = deviations.sort(0, false).0;
-+    let median_idx = sorted_dev.size()[0] / 2;
-+    sorted_dev.i(median_idx).double_value(&[]) * 1.4826
-+}
-+
-+/// Normalise avec MAD au lieu de l'√©cart-type standard
-+fn normalize_with_mad(tensor: &Tensor, median: f64, mad: f64) -> Tensor {
-+    let normalized = if mad > 1e-6 {
-+        (tensor - median) / mad.max(1e-6)
-+    } else {
-+        tensor - median
-+    };
-+
-+    // Clamp final pour √©viter les valeurs extr√™mes
-+    normalized.clamp(-3.0, 3.0)
-+}
-+
-+/// Version simple de normalisation z-score
-+pub fn simple_normalization(tensor: &Tensor) -> Tensor {
-+    let mean = tensor.mean(tch::Kind::Float);
-+    let std = tensor.std(false).clamp_min(1e-8);
-+    (tensor - mean) / std
-+}
-+
-+/// Normalisation min-max
-+pub fn min_max_normalization(tensor: &Tensor) -> Tensor {
-+    let min_val = tensor.min();
-+    let max_val = tensor.max();
-+    let range = max_val - &min_val;
-+
-+    if range.double_value(&[]) > 1e-8 {
-+        (tensor - min_val) / range
-+    } else {
-+        tensor.shallow_clone()
-+    }
-+}
-\ No newline at end of file
-diff --git a/src/neural/training/trainer.rs b/src/neural/training/trainer.rs
-index e69de29..95a6d39 100644
---- a/src/neural/training/trainer.rs
-+++ b/src/neural/training/trainer.rs
-@@ -0,0 +1,146 @@
-+use tch::{nn, IndexOp, Tensor};
-+use tch::nn::Optimizer;
-+use crate::mcts::mcts_result::MCTSResult;
-+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
-+use crate::neural::training::gradient_clipping::enhanced_gradient_clipping;
-+use crate::neural::training::normalization::robust_state_normalization;
-+
-+pub fn train_network_with_game_data(
-+    vs_policy: &nn::VarStore,
-+    vs_value: &nn::VarStore,
-+    game_data: &[MCTSResult],
-+    discount_factor: f64,
-+    policy_net: &PolicyNet,
-+    value_net: &ValueNet,
-+    optimizer_policy: &mut Optimizer,
-+    optimizer_value: &mut Optimizer,
-+) {
-+    // Hyperparameters
-+    let entropy_weight = 0.05;
-+    let gamma = 0.99;
-+    let epsilon = 1e-8;
-+
-+    // Initialize accumulators
-+    let mut predictions = Vec::new();
-+    let mut targets = Vec::new();
-+    let mut total_policy_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
-+    let mut total_value_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
-+    let mut total_entropy_loss = Tensor::zeros(&[], tch::kind::FLOAT_CPU);
-+
-+    // Initialize trajectory rewards and discounted sum
-+    let mut trajectory_rewards = Vec::new();
-+    let mut discounted_sum = Tensor::zeros(&[], (tch::Kind::Float, tch::Device::Cpu));
-+
-+    // === Training Loop ===
-+    for (step, result) in game_data.iter().rev().enumerate() {
-+        // üõë No Normalization: Use raw tensor
-+        let state = result.board_tensor.shallow_clone();
-+        let normalized_state = robust_state_normalization(&state);
-+
-+        // Forward pass through networks with normalized state
-+        let pred_policy = policy_net.forward(&normalized_state, true).clamp_min(1e-7);
-+        let pred_value = value_net.forward(&normalized_state, true);
-+
-+        // Forward pass through networks with normalized state
-+        // Normalize reward: divide by a constant max value (e.g., 100)
-+        let reward = Tensor::from(result.subscore).to_kind(tch::Kind::Float) / 100.0;
-+        let gamma_tensor = Tensor::from_slice(&[gamma]).to_kind(tch::Kind::Float);
-+
-+        // ‚úÖ NaN & Inf Check for reward
-+        if reward.isnan().any().double_value(&[]) > 0.0
-+            || reward.isinf().any().double_value(&[]) > 0.0
-+        {
-+            log::error!("‚ö†Ô∏è NaN or Inf detected in reward at step {}", step);
-+            continue;
-+        }
-+
-+        // Update discounted sum with normalized reward
-+        discounted_sum = reward + gamma_tensor * discounted_sum;
-+
-+        // ‚úÖ NaN & Inf Check for discounted sum
-+        if discounted_sum.isnan().any().double_value(&[]) > 0.0
-+            || discounted_sum.isinf().any().double_value(&[]) > 0.0
-+        {
-+            log::error!("‚ö†Ô∏è NaN or Inf detected in discounted sum at step {}", step);
-+            continue;
-+        }
-+
-+        // Store the value for analysis
-+        trajectory_rewards.push(discounted_sum.double_value(&[]));
-+
-+        // Generate target tensor directly from discounted sum
-+        let discounted_reward = discounted_sum.shallow_clone();
-+
-+        // Append for later analysis
-+        predictions.push(pred_value.double_value(&[]));
-+        targets.push(discounted_reward.double_value(&[]));
-+
-+        // === Compute Losses ===
-+        // Policy loss
-+        let best_position = result.best_position as i64;
-+        let target_policy = Tensor::zeros(&[1, pred_policy.size()[1]], tch::kind::FLOAT_CPU);
-+        target_policy.i((0, best_position)).fill_(1.0);
-+        let log_policy = pred_policy.log();
-+        let policy_loss = -(target_policy * log_policy.shallow_clone()).sum(tch::Kind::Float);
-+        total_policy_loss += policy_loss;
-+
-+        // Entropy loss
-+        let entropy_loss = -(pred_policy * (log_policy + epsilon)).sum(tch::Kind::Float);
-+        total_entropy_loss += entropy_loss;
-+
-+        // Value loss (Huber loss for better stability)
-+        let diff = discounted_reward.shallow_clone() - pred_value.shallow_clone();
-+        let abs_diff = diff.abs();
-+        let delta = 1.0;
-+        let value_loss = abs_diff.le(delta).to_kind(tch::Kind::Float) * 0.5 * &diff * &diff
-+            + abs_diff.gt(delta).to_kind(tch::Kind::Float) * (delta * (&abs_diff - 0.5 * delta));
-+        total_value_loss += value_loss.mean(tch::Kind::Float);
-+    }
-+
-+    // Fix: Add explicit type annotation for total_loss
-+    let total_loss: Tensor = total_policy_loss.shallow_clone()
-+        + total_value_loss.shallow_clone()
-+        + (entropy_weight * total_entropy_loss.shallow_clone());
-+
-+    // Log the loss before backpropagation
-+    log::info!(
-+        "üí° Total Loss before backward: {:.4}",
-+        total_loss.double_value(&[])
-+    );
-+
-+    // ‚úÖ Enhanced NaN and Inf check before backpropagation
-+    if total_loss.isnan().any().double_value(&[]) > 0.0 {
-+        log::error!("‚ö†Ô∏è NaN detected in total loss! Skipping backpropagation.");
-+        return;
-+    }
-+    if total_loss.isinf().any().double_value(&[]) > 0.0 {
-+        log::error!("‚ö†Ô∏è Inf detected in total loss! Skipping backpropagation.");
-+        return;
-+    }
-+
-+    // Check if total_loss requires gradients before calling backward
-+    if !total_loss.requires_grad() {
-+        log::error!("‚ö†Ô∏è Total loss does not require gradients! Skipping backpropagation.");
-+        return;
-+    }
-+
-+    total_loss.backward();
-+
-+    // Utilisez :
-+    let gradient_result = enhanced_gradient_clipping(vs_value, vs_policy);
-+    let _max_grad_value = gradient_result.max_grad_value;
-+    let _max_grad_policy = gradient_result.max_grad_policy;
-+
-+    // === Optimizer Step ===
-+    optimizer_policy.step();
-+    optimizer_policy.zero_grad();
-+    optimizer_value.step();
-+    optimizer_value.zero_grad();
-+
-+    log::info!(
-+        "üéØ Update Complete | Policy Loss: {:.4}, Value Loss: {:.4}, Entropy Loss: {:.4}",
-+        total_policy_loss.double_value(&[]),
-+        total_value_loss.double_value(&[]),
-+        total_entropy_loss.double_value(&[])
-+    );
-+}
-\ No newline at end of file
-diff --git a/src/scoring/mod.rs b/src/scoring/mod.rs
-index 4c07743..80d0f3d 100644
---- a/src/scoring/mod.rs
-+++ b/src/scoring/mod.rs
-@@ -1,2 +1 @@
- pub mod scoring;
--pub mod results;
-diff --git a/src/strategy/mod.rs b/src/strategy/mod.rs
-index e69de29..e775ccb 100644
---- a/src/strategy/mod.rs
-+++ b/src/strategy/mod.rs
-@@ -0,0 +1 @@
-+pub mod position_evaluation;
-\ No newline at end of file
-diff --git a/src/strategy/position_evaluation.rs b/src/strategy/position_evaluation.rs
-index e69de29..69e2403 100644
---- a/src/strategy/position_evaluation.rs
-+++ b/src/strategy/position_evaluation.rs
-@@ -0,0 +1,84 @@
-+use crate::game::plateau::Plateau;
-+use crate::game::tile::Tile;
-+use crate::scoring::scoring::compute_alignment_score;
-+
-+// Version simplifi√©e qui se concentre sur les positions strat√©giques
-+pub fn calculate_line_completion_bonus(plateau: &Plateau, position: usize, tile: &Tile) -> f64 {
-+    let mut bonus = 0.0;
-+
-+    // Bonus bas√© sur les positions strat√©giques identifi√©es dans tes donn√©es
-+    bonus += match position {
-+        8 => 5.0,                 // Position 8: 150.6 moyenne - excellente
-+        14 => 4.0,                // Position 14: 147.7 moyenne - tr√®s bonne
-+        2 => 4.0,                 // Position 2: 147.1 moyenne - tr√®s bonne
-+        5 => 3.0,                 // Position 5: 143.6 moyenne - bonne
-+        11 => 3.0,                // Position 11: 142.9 moyenne - bonne
-+        10 => 2.0,                // Position 10: 140.8 moyenne - correcte
-+        13 => 2.0,                // Position 13: 140.2 moyenne - correcte
-+        1 | 4 | 6 | 9 | 0 => 1.0, // Positions moyennes
-+        12 | 15 | 16 => 0.5,      // Positions plus faibles
-+        7 | 17 => 0.0,            // Positions les plus faibles
-+        _ => 0.0,
-+    };
-+
-+    // Bonus pour les valeurs de tuiles √©lev√©es (plus de points potentiels)
-+    let tile_value_bonus = ((tile.0 + tile.1) as f64) * 0.1;
-+    bonus += tile_value_bonus;
-+
-+    // Bonus pour la coh√©rence des couleurs/formes
-+    if tile.0 == tile.1 {
-+        bonus += 1.0; // Tuiles avec m√™me couleur et forme
-+    }
-+
-+    // Bonus central l√©g√®rement plus complexe
-+    let row = position / 3;
-+    let col = position % 3;
-+    if row >= 1 && row <= 4 && col >= 1 && col <= 1 {
-+        bonus += 2.0; // Zone centrale du plateau
-+    }
-+
-+    bonus
-+}
-+
-+// ============================================================================
-+// ALTERNATIVE PLUS SIMPLE (Si la version ci-dessus pose encore probl√®me)
-+// ============================================================================
-+
-+// Si vous pr√©f√©rez une version plus simple, utilisez celle-ci:
-+
-+pub fn enhanced_position_evaluation(
-+    plateau: &Plateau,
-+    position: usize,
-+    tile: &Tile,
-+    current_turn: usize,
-+) -> f64 {
-+    // Score de base alignement (votre fonction existante)
-+    let alignment_score = compute_alignment_score(plateau, position, tile);
-+
-+    // Bonus pour positions centrales strat√©giques en d√©but de partie
-+    let position_bonus = if current_turn < 8 {
-+        match position {
-+            7 | 8 | 9 | 10 | 11 => 5.0,           // Ligne centrale - critique
-+            4 | 5 | 6 | 12 | 13 | 14 | 15 => 3.0, // Positions strat√©giques
-+            _ => 0.0,
-+        }
-+    } else {
-+        0.0 // En fin de partie, seul l'alignement compte
-+    };
-+
-+    // Malus pour positions coins/bords si d√©but de partie
-+    let position_malus = if current_turn < 5 {
-+        match position {
-+            0 | 2 | 16 | 18 => -2.0, // Coins - √† √©viter en d√©but
-+            1 | 17 => -1.0,          // Bords
-+            _ => 0.0,
-+        }
-+    } else {
-+        0.0
-+    };
-+
-+    // Bonus pour compl√©tion de lignes
-+    let completion_bonus = calculate_line_completion_bonus(plateau, position, tile);
-+
-+    alignment_score + position_bonus + position_malus + completion_bonus
-+}
-diff --git a/src/test.rs b/src/test.rs
-index 2bb8cd8..896f3e0 100644
---- a/src/test.rs
-+++ b/src/test.rs
-@@ -1,31 +1,5 @@
--
--#[derive(Debug, Clone, PartialEq)]
--pub struct MCTSNode {
--    pub state: GameState,             // Current game state
--    pub visits: usize,                // Number of visits
--    pub value: f64,                   // Total value of the node
--    pub children: Vec<MCTSNode>,      // Child nodes
--    pub parent: Option<*mut MCTSNode>, // Pointer to the parent node (raw pointer to allow mutation)
--}
--
--
--#[derive(Debug, Clone, PartialEq, Copy,Hash,Eq)]
--pub(crate) struct Tile(pub i32, pub i32, pub i32);
--#[derive(Debug, Clone, PartialEq)]
--pub(crate) struct Plateau{
--    pub(crate) tiles: Vec<Tile>,
--}
--
--#[derive(Debug, Clone, PartialEq)]
--pub struct GameState {
--    pub plateau: Plateau,
--    pub deck: Deck,
--}
--
--#[derive(Debug, Clone, PartialEq)]
--pub struct Deck{
--    pub(crate) tiles: Vec<Tile>,
--}
-+use crate::game::plateau::Plateau;
-+use crate::game::tile::Tile;
- 
- #[cfg(test)]
- pub(crate) mod tests {
-@@ -75,7 +49,7 @@ pub(crate) mod tests {
- 
-     pub fn create_game_state() -> GameState {
-         let plateau = create_plateau_empty();
--        let deck = create_shuffle_deck();
-+        let deck = create_deck();
-         GameState { plateau, deck }
-     }
- 
-@@ -155,21 +129,25 @@ pub(crate) mod tests {
-             (*current).value += score;
-         }
-     }
--    use crate::remove_tile_from_deck::remove_tile_from_deck;
-+    use crate::game::remove_tile_from_deck::remove_tile_from_deck;
- use super::*;
- 
- 
-     use rand::Rng;
--    use crate::create_plateau_empty::create_plateau_empty;
--    use crate::create_shuffle_deck::create_shuffle_deck;
-+    use crate::game::create_deck::create_deck;
-     use crate::{convert_plateau_to_tensor, get_legal_moves, is_plateau_full, simulate_games};
--    use crate::result::result;
--    use crate::test::{  Deck, GameState,  MCTSNode, Plateau, Tile};
-+    use crate::game::deck::Deck;
-+    use crate::game::game_state::GameState;
-+    use crate::mcts::mcts_node::MCTSNode;
-+    use crate::game::plateau::{create_plateau_empty, Plateau};
-+    use crate::game::tile::Tile;
-+    use crate::scoring::scoring::result;
-+
-     #[test]
-     fn test_placement_tuile_valide_take_it_easy() {
-         let mut plateau:Plateau=create_plateau_empty();
--        let deckSfuffle:Deck= create_shuffle_deck();
--        let tuile = deckSfuffle.tiles[5].clone();
-+        let shuffled_deck:Deck= create_deck();
-+        let tuile = shuffled_deck.tiles[5].clone();
-         assert!(placer_tile(&mut plateau, tuile.clone(), 1));
-         assert_eq!(plateau.tiles[1], tuile);
-     }
-@@ -203,7 +181,7 @@ use super::*;
-     #[test]
-     fn test_simulate_games() {
-         let plateau = create_plateau_empty();
--        let deck = create_shuffle_deck();
-+        let deck = create_deck();
-         let num_simulations = 10;
- 
-         let avg_score = simulate_games(plateau, deck);
-@@ -213,7 +191,7 @@ use super::*;
-     fn test_convert_plateau_to_tensor() {
-         let plateau = create_plateau_empty();
-         let tile = Tile(1, 2, 3);
--        let deck = create_shuffle_deck();
-+        let deck = create_deck();
- 
-         let tensor = convert_plateau_to_tensor(&plateau, &tile, &deck, /* usize */0, 19/* usize */);
-         assert_eq!(tensor.size(), vec![1, 3, 5, 5]); // Ensure the tensor has the correct shape
-@@ -224,7 +202,7 @@ use super::*;
-     #[test]
-     fn test_placement_tuile_not_valide_take_it_easy() {
-         let mut plateau:Plateau=create_plateau_empty();
--        let deckSfuffle:Deck= create_shuffle_deck();
-+        let deckSfuffle:Deck= create_deck();
-         let tile = deckSfuffle.tiles[5].clone();
-         assert!(placer_tile(&mut plateau, tile.clone(), 1));
-         assert_eq!(plateau.tiles[1], tile);
-@@ -234,7 +212,7 @@ use super::*;
-     #[test]
-     fn test_choir_aleatorytile() {
-         // Cr√©e un deck
--        let deck_shuffle: Deck = create_shuffle_deck();
-+        let deck_shuffle: Deck = create_deck();
- 
-         // G√©n√®re un index al√©atoire
-         let mut rng = rand::thread_rng();
-@@ -258,7 +236,7 @@ use super::*;
-         use rand::Rng; // Pour g√©n√©rer un indice al√©atoire
- 
-         // Cr√©e un deck initial
--        let deck_shuffle: Deck = create_shuffle_deck();
-+        let deck_shuffle: Deck = create_deck();
- 
-         // G√©n√®re un indice al√©atoire
-         let mut rng = rand::thread_rng();
-@@ -282,7 +260,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
- 
-         // Remplir le plateau
-@@ -300,7 +278,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_first_3_plateau_3_1() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
-         placer_tile(&mut plateau, deck.tiles[1].clone(), 1);
-@@ -310,7 +288,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_first_3_plateau_3_2() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[9].clone(), 0);
-         placer_tile(&mut plateau, deck.tiles[10].clone(), 1);
-@@ -320,7 +298,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_2_column_plateau_4_2() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[9].clone(), 3);
-         placer_tile(&mut plateau, deck.tiles[10].clone(), 4);
-@@ -334,7 +312,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_column_center_plateau_5_2() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[9].clone(), 7);
-         placer_tile(&mut plateau, deck.tiles[10].clone(), 8);
-@@ -349,7 +327,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_column_4_plateau_4_2() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[9].clone(), 12);
-         placer_tile(&mut plateau, deck.tiles[10].clone(), 13);
-@@ -363,7 +341,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_last_column_3_plateau_3_1() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 16);
-         placer_tile(&mut plateau, deck.tiles[1].clone(),17);
-@@ -373,7 +351,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_first_diag_plateau_0_3_7() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
-         placer_tile(&mut plateau, deck.tiles[4].clone(),3);
-@@ -383,7 +361,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_second_diag_plateau_1_4_8_12() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 1);
-         placer_tile(&mut plateau, deck.tiles[4].clone(),4);
-@@ -394,7 +372,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_third_diag_plateau_2_5_9_13_16() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 2);
-         placer_tile(&mut plateau, deck.tiles[4].clone(),5);
-@@ -406,7 +384,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_fourth_diag_plateau_6_10_14_17() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 6);
-         placer_tile(&mut plateau, deck.tiles[4].clone(),10);
-@@ -418,7 +396,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_last_diag_plateau_11_15_18() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 11);
-         placer_tile(&mut plateau, deck.tiles[4].clone(),15);
-@@ -430,7 +408,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_firdt_diag_left_plateau_7_12_16() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 7);
-         placer_tile(&mut plateau, deck.tiles[2].clone(),12);
-@@ -442,7 +420,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_second_diag_left_plateau_3_8_13_17() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 3);
-         placer_tile(&mut plateau, deck.tiles[2].clone(),8);
-@@ -455,7 +433,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_third_diag_left_plateau_0_4_9_14_18() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
-         placer_tile(&mut plateau, deck.tiles[2].clone(),4);
-@@ -470,7 +448,7 @@ use super::*;
- 
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_fourth_diag_left_plateau_1_5_10_15() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 1);
-         placer_tile(&mut plateau, deck.tiles[2].clone(),5);
-@@ -483,7 +461,7 @@ use super::*;
-     }
-     #[test]
-     fn test_remplir_plateau_take_it_easy_count_last_diag_left_plateau_2_6_11() {
--        let mut deck = create_shuffle_deck();
-+        let mut deck = create_deck();
-         let mut plateau = create_plateau_empty();
-         placer_tile(&mut plateau, deck.tiles[0].clone(), 2);
-         placer_tile(&mut plateau, deck.tiles[2].clone(),6);
-diff --git a/src/training/evaluator.rs b/src/training/evaluator.rs
-index e69de29..052208b 100644
---- a/src/training/evaluator.rs
-+++ b/src/training/evaluator.rs
-@@ -0,0 +1,45 @@
-+use rand::{rng, Rng};
-+use crate::game::create_deck::create_deck;
-+use crate::game::plateau::create_plateau_empty;
-+use crate::game::plateau_is_full::is_plateau_full;
-+use crate::game::remove_tile_from_deck::replace_tile_in_deck;
-+use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
-+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
-+use crate::scoring::scoring::result;
-+
-+pub async fn evaluate_model(policy_net: &PolicyNet, value_net: &ValueNet, num_simulations: usize) {
-+    log::info!("Evaluating model...");
-+    let mut scores = Vec::new();
-+
-+    for _ in 0..10 {
-+        let mut deck = create_deck();
-+        let mut plateau = create_plateau_empty();
-+        let total_turns = 19; // The number of moves in the game
-+        let mut current_turn = 0;
-+        while !is_plateau_full(&plateau) {
-+            let tile_index = rng().random_range(0..deck.tiles.len());
-+            let chosen_tile = deck.tiles[tile_index];
-+            let game_result = mcts_find_best_position_for_tile_with_nn(
-+                &mut plateau,
-+                &mut deck,
-+                chosen_tile,
-+                policy_net,
-+                value_net,
-+                num_simulations,
-+                current_turn,
-+                total_turns,
-+            );
-+            let best_position = game_result.best_position;
-+            plateau.tiles[best_position] = chosen_tile;
-+            deck = replace_tile_in_deck(&deck, &chosen_tile);
-+            current_turn += 1; // Increment turn counter each time a tile is placed
-+        }
-+
-+        let game_score = result(&plateau);
-+        scores.push(game_score);
-+    }
-+
-+    let avg_score: f64 = scores.iter().copied().sum::<i32>() as f64 / scores.len() as f64;
-+    log::info!("Model Evaluation Complete. Avg Score: {:.2}", avg_score);
-+    // **Stop ping task**
-+}
-\ No newline at end of file
-diff --git a/src/training/mod.rs b/src/training/mod.rs
-index e69de29..0fe0e0c 100644
---- a/src/training/mod.rs
-+++ b/src/training/mod.rs
-@@ -0,0 +1,3 @@
-+pub mod websocket;
-+pub mod evaluator;
-+pub mod session;
-diff --git a/src/training/session.rs b/src/training/session.rs
-index e69de29..7b0fbaf 100644
---- a/src/training/session.rs
-+++ b/src/training/session.rs
-@@ -0,0 +1,276 @@
-+use crate::data::append_result::append_to_results_file;
-+use crate::data::load_data::load_game_data;
-+use crate::data::save_data::save_game_data;
-+use crate::game::create_deck::create_deck;
-+use crate::game::plateau::create_plateau_empty;
-+use crate::game::plateau_is_full::is_plateau_full;
-+use crate::game::remove_tile_from_deck::replace_tile_in_deck;
-+use crate::game::tile::Tile;
-+use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
-+use crate::mcts::mcts_result::MCTSResult;
-+use crate::mcts_vs_human::play_mcts_vs_human;
-+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
-+use crate::neural::training::trainer::train_network_with_game_data;
-+use crate::scoring::scoring::result;
-+use crate::training::evaluator::evaluate_model;
-+use crate::training::websocket::reconnect_websocket;
-+use crate::utils::image::generate_tile_image_names;
-+use crate::Config;
-+use futures_util::{SinkExt, StreamExt};
-+use rand::{rng, Rng};
-+use std::collections::HashMap;
-+use std::sync::Arc;
-+use tch::nn;
-+use tch::nn::Optimizer;
-+use tokio::net::TcpListener;
-+use tokio_tungstenite::accept_async;
-+use tokio_tungstenite::tungstenite::Message;
-+/// Lance une session MCTS vs Humain
-+
-+pub async fn train_and_evaluate(
-+    vs_policy: &nn::VarStore,
-+    vs_value: &nn::VarStore,
-+    policy_net: &mut PolicyNet,
-+    value_net: &mut ValueNet,
-+    optimizer_policy: &mut Optimizer,
-+    optimizer_value: &mut Optimizer,
-+    num_games: usize,
-+    num_simulations: usize,
-+    evaluation_interval: usize,
-+    listener: Arc<TcpListener>,
-+) {
-+    let mut total_score = 0;
-+    let mut games_played = 0;
-+    let results_file = "results.csv";
-+
-+    while let Ok((stream, _)) = listener.accept().await {
-+        let ws_stream = accept_async(stream)
-+            .await
-+            .expect("Failed to accept WebSocket");
-+        let (mut write, _) = ws_stream.split();
-+        let mut scores_by_position: HashMap<usize, Vec<i32>> = HashMap::new();
-+        let mut scores = Vec::new(); // Stocke les scores
-+        let evaluation_interval_average = 10;
-+
-+        while games_played < num_games {
-+            log::info!(
-+                "Starting training iteration {}/{}...",
-+                games_played + 1,
-+                num_games
-+            );
-+            log::info!(
-+                "\nüöÄ Starting Batch {}",
-+                games_played / evaluation_interval + 1
-+            );
-+
-+            let mut batch_games_played = 0; // Tracks games processed in this evaluation interval
-+
-+            let max_memory_size = 1000; // Store last 500 games
-+
-+            for game in 0..evaluation_interval {
-+                let mut deck = create_deck();
-+                let mut plateau = create_plateau_empty();
-+                let mut game_data = Vec::new();
-+                let mut first_move: Option<(usize, Tile)> = None;
-+                let total_turns = 19; // The number of moves in the game
-+                let mut current_turn = 0;
-+                while !is_plateau_full(&plateau) {
-+                    let tile_index = rng().random_range(0..deck.tiles.len());
-+                    let chosen_tile = deck.tiles[tile_index];
-+                    // ‚úÖ **Send preview before placement**
-+                    // ‚úÖ **INSERT YOUR NEW CODE HERE**
-+                    let chosen_tile_image = format!(
-+                        "../image/{}{}{}.png",
-+                        chosen_tile.0, chosen_tile.1, chosen_tile.2
-+                    );
-+                    let payload = serde_json::json!({
-+                        "next_tile": chosen_tile_image,
-+                        "plateau_tiles": generate_tile_image_names(&plateau.tiles)
-+                    });
-+                    let serialized = serde_json::to_string(&payload).unwrap();
-+                    write.send(Message::Text(serialized)).await.unwrap();
-+
-+                    let game_result = mcts_find_best_position_for_tile_with_nn(
-+                        &mut plateau,
-+                        &mut deck,
-+                        chosen_tile,
-+                        policy_net,
-+                        value_net,
-+                        num_simulations,
-+                        current_turn,
-+                        total_turns,
-+                    );
-+
-+                    let best_position = game_result.best_position;
-+                    if first_move.is_none() {
-+                        first_move = Some((best_position, chosen_tile));
-+                    }
-+                    plateau.tiles[best_position] = chosen_tile;
-+                    deck = replace_tile_in_deck(&deck, &chosen_tile);
-+                    // ‚úÖ INSERT THIS TO SEND SCORE TO CLIENT
-+                    let current_score = result(&plateau);
-+                    let score_payload = serde_json::json!({
-+                        "type": "score_update",
-+                        "current_score": current_score,
-+                    });
-+                    let serialized_score = serde_json::to_string(&score_payload).unwrap();
-+                    if let Err(e) = write.send(Message::Text(serialized_score)).await {
-+                        log::error!("WebSocket error when sending score: {:?}", e);
-+                        if let Some(new_write) = reconnect_websocket(&listener).await {
-+                            write = new_write;
-+                        } else {
-+                            log::error!("Failed to reconnect WebSocket. Exiting...");
-+                            break;
-+                        }
-+                    }
-+
-+                    game_data.push(game_result); // Store training data
-+
-+                    // ‚úÖ **INSERT YOUR NEW CODE HERE**
-+                    let payload_after_placement = serde_json::json!({
-+                        "next_tile": null, // Clear preview
-+                        "plateau_tiles": generate_tile_image_names(&plateau.tiles) // new updated state
-+                    });
-+                    let serialized = serde_json::to_string(&payload_after_placement).unwrap();
-+
-+                    // ‚úÖ Handle WebSocket disconnections
-+                    if let Err(e) = write.send(Message::Text(serialized.clone())).await {
-+                        log::error!("WebSocket error: {:?}. Attempting to reconnect...", e);
-+
-+                        // **Reconnect WebSocket**
-+                        if let Some(new_write) = reconnect_websocket(&listener).await {
-+                            write = new_write;
-+                        } else {
-+                            log::error!("Failed to reconnect WebSocket. Exiting...");
-+                            break;
-+                        }
-+                    }
-+                    current_turn += 1; // Increment turn counter each time a tile is placed
-+                }
-+
-+                let final_score = result(&plateau);
-+
-+                if let Some((position, _)) = first_move {
-+                    scores_by_position
-+                        .entry(position)
-+                        .or_insert_with(Vec::new)
-+                        .push(final_score);
-+                }
-+
-+                let mut batch_game_data = Vec::new();
-+
-+                // Prioritized historical data
-+                let prioritized_data: Vec<MCTSResult> = load_game_data("game_data")
-+                    .into_iter()
-+                    .filter(|r| r.subscore > 100.0) // Only select high-score games
-+                    .take(50) // Limit to 50 samples to prevent overfitting
-+                    .collect();
-+
-+                // Add historical data to batch
-+                batch_game_data.extend(prioritized_data);
-+
-+                // Add current game's data to batch
-+                batch_game_data.extend(game_data.iter().map(|result| MCTSResult {
-+                    best_position: result.best_position,
-+                    board_tensor: result.board_tensor.shallow_clone(),
-+                    subscore: result.subscore,
-+                }));
-+
-+                // Keep only last max_memory_size experiences
-+                if batch_game_data.len() > max_memory_size {
-+                    let to_remove = batch_game_data.len() - max_memory_size;
-+                    batch_game_data.drain(0..to_remove); // Remove oldest data
-+                }
-+
-+                // Train in batches
-+                let batch_size = 10;
-+                for batch in batch_game_data.chunks(batch_size) {
-+                    train_network_with_game_data(
-+                        &vs_policy,
-+                        &vs_value,
-+                        batch, // Use each batch directly
-+                        final_score.into(),
-+                        policy_net,
-+                        value_net,
-+                        optimizer_policy,
-+                        optimizer_value,
-+                    );
-+                }
-+
-+                log::info!("Game {} finished with score: {}", game + 1, final_score);
-+                scores.push(final_score);
-+
-+                // Update batch-specific counters
-+                batch_games_played += 1;
-+                total_score += final_score;
-+
-+                if game % evaluation_interval_average == 0 && game != 0 {
-+                    let moyenne: f64 = scores.iter().sum::<i32>() as f64 / scores.len() as f64;
-+                    log::info!(
-+                        "üìä [Batch {}] Avg Score: {:.2} | Games Played: {}",
-+                        games_played / evaluation_interval,
-+                        moyenne,
-+                        games_played
-+                    );
-+                    log::info!("batch {} - Score moyen: {:.2}", game, moyenne);
-+                    write
-+                        .send(Message::Text(format!("GAME_RESULT:{}", moyenne)))
-+                        .await
-+                        .unwrap();
-+                }
-+
-+                // Save current game data for future training
-+                save_game_data("game_data", game_data);
-+            }
-+
-+            // Update main game counters
-+            games_played += batch_games_played;
-+
-+            // Append results to the file
-+            let avg_score = total_score as f64 / games_played as f64;
-+            append_to_results_file(results_file, avg_score);
-+
-+            // Calculate and display averages
-+            let mut averages: Vec<(usize, f64)> = scores_by_position
-+                .iter()
-+                .map(|(position, scores)| {
-+                    let average_score: f64 =
-+                        scores.iter().sum::<i32>() as f64 / scores.len() as f64;
-+                    (*position, average_score)
-+                })
-+                .collect();
-+
-+            averages.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
-+
-+            log::info!("\n--- Average Scores by First Position (Sorted) ---");
-+            for (position, average_score) in averages {
-+                log::info!(
-+                    "Position: {}, Average Score: {:.2}",
-+                    position,
-+                    average_score
-+                );
-+            }
-+
-+            // Evaluate model after each interval
-+            evaluate_model(policy_net, value_net, num_simulations).await;
-+
-+            log::info!(
-+                "Games Played: {}, Total Score: {}, Avg Score: {:.2}",
-+                games_played,
-+                total_score,
-+                total_score as f32 / games_played as f32
-+            );
-+            let model_path = "model_weights";
-+            // Save model weights
-+            log::info!("Saving models to {}", model_path);
-+            log::info!("Saving model weights...");
-+            if let Err(e) = policy_net.save_model(vs_policy, "model_weights/policy/policy.params") {
-+                log::error!("Error saving PolicyNet weights: {:?}", e);
-+            }
-+            if let Err(e) = value_net.save_model(vs_value, "model_weights/value/value.params") {
-+                log::error!("Error saving ValueNet weights: {:?}", e);
-+            }
-+        }
-+        break; // Exit after handling one connection
-+    }
-+}
-diff --git a/src/training/websocket.rs b/src/training/websocket.rs
-index e69de29..3ca151d 100644
---- a/src/training/websocket.rs
-+++ b/src/training/websocket.rs
-@@ -0,0 +1,42 @@
-+use futures_util::stream::SplitSink;
-+use futures_util::{SinkExt, StreamExt};
-+use tokio::net::TcpListener;
-+use tokio_tungstenite::tungstenite::Message;
-+use tokio_tungstenite::{accept_async, WebSocketStream};
-+
-+pub async fn reconnect_websocket(
-+    listener: &TcpListener,
-+) -> Option<SplitSink<WebSocketStream<tokio::net::TcpStream>, Message>> {
-+    match listener.accept().await {
-+        Ok((stream, _)) => {
-+            log::info!("Re-establishing WebSocket connection...");
-+            let ws_stream = accept_async(stream)
-+                .await
-+                .expect("Failed to accept WebSocket");
-+            let (write, _) = ws_stream.split();
-+            Some(write)
-+        }
-+        Err(e) => {
-+            log::error!("Error while reconnecting WebSocket: {:?}", e);
-+            None
-+        }
-+    }
-+}
-+/// Envoie un message via WebSocket avec gestion d'erreur
-+pub async fn send_websocket_message(
-+    write: &mut SplitSink<WebSocketStream<tokio::net::TcpStream>, Message>,
-+    message: String,
-+    listener: &TcpListener,
-+) -> Result<(), Box<dyn std::error::Error>> {
-+    if let Err(e) = write.send(Message::Text(message.clone())).await {
-+        log::error!("WebSocket error: {:?}. Attempting to reconnect...", e);
-+
-+        if let Some(new_write) = reconnect_websocket(listener).await {
-+            *write = new_write;
-+            write.send(Message::Text(message)).await?;
-+        } else {
-+            return Err("Failed to reconnect WebSocket".into());
-+        }
-+    }
-+    Ok(())
-+}
-\ No newline at end of file
-diff --git a/src/utils/image.rs b/src/utils/image.rs
-index e69de29..8e5c04a 100644
---- a/src/utils/image.rs
-+++ b/src/utils/image.rs
-@@ -0,0 +1,8 @@
-+use crate::game::tile::Tile;
-+
-+pub fn generate_tile_image_names(tiles: &[Tile]) -> Vec<String> {
-+    tiles
-+        .iter()
-+        .map(|tile| format!("../image/{}{}{}.png", tile.0, tile.1, tile.2))
-+        .collect()
-+}
-\ No newline at end of file
-diff --git a/src/utils/mod.rs b/src/utils/mod.rs
-index e69de29..8a824bf 100644
---- a/src/utils/mod.rs
-+++ b/src/utils/mod.rs
-@@ -0,0 +1,2 @@
-+pub mod random_index;
-+pub mod image;
-\ No newline at end of file
-diff --git a/src/utils/random_index.rs b/src/utils/random_index.rs
-index e69de29..fe25ce6 100644
---- a/src/utils/random_index.rs
-+++ b/src/utils/random_index.rs
-@@ -0,0 +1,5 @@
-+pub fn random_index(max: usize) -> usize {
-+    use rand::Rng;
-+    let mut rng = rand::thread_rng();
-+    rng.gen_range(0..max)
-+}
-\ No newline at end of file
diff --git a/src/build.rs b/src/build.rs
index e69de29..508db92 100644
--- a/src/build.rs
+++ b/src/build.rs
@@ -0,0 +1,24 @@
+fn main() -> Result<(), Box<dyn std::error::Error>> {
+    // Configuration de tonic-build
+    tonic_build::configure()
+        .build_server(true)
+        .build_client(true)
+        .compile(
+            &["proto/session_manager.proto"],
+            &["proto/"],
+        )?;
+
+    // Alternative si vous voulez plus de contr√¥le :
+    /*
+    tonic_build::configure()
+        .out_dir("src/generated")  // R√©pertoire de sortie personnalis√©
+        .build_server(true)
+        .build_client(true)
+        .compile(
+            &["proto/session_manager.proto"],
+            &["proto/"],
+        )?;
+    */
+
+    Ok(())
+}
\ No newline at end of file
diff --git a/src/data/append_result.rs b/src/data/append_result.rs
index 5e0a05b..670e48f 100644
--- a/src/data/append_result.rs
+++ b/src/data/append_result.rs
@@ -1,11 +1,6 @@
 use std::fs::OpenOptions;
 use std::io::{BufWriter, Write};
 use chrono::Utc;
-use futures_util::stream::SplitSink;
-use futures_util::StreamExt;
-use tokio::net::TcpListener;
-use tokio_tungstenite::tungstenite::Message;
-use tokio_tungstenite::{accept_async, WebSocketStream};
 
 pub fn append_to_results_file(file_path: &str, avg_score: f64) {
     let timestamp = Utc::now().to_rfc3339();
diff --git a/src/game/create_deck.rs b/src/game/create_deck.rs
index 3a7c7f7..58577bd 100644
--- a/src/game/create_deck.rs
+++ b/src/game/create_deck.rs
@@ -40,7 +40,6 @@ pub(crate) fn new_tiles(x: i32, y: i32, z: i32) -> Tile {
 }
 #[cfg(test)]
 mod tests {
-    use crate::game::create_deck;
     use crate::game::create_deck::create_deck;
     use crate::game::tile::Tile;
 
diff --git a/src/game/remove_tile_from_deck.rs b/src/game/remove_tile_from_deck.rs
index 59323aa..6499edb 100644
--- a/src/game/remove_tile_from_deck.rs
+++ b/src/game/remove_tile_from_deck.rs
@@ -17,37 +17,23 @@ use crate::game::tile::Tile;
 //
 //     Deck { tiles: new_tiles } // Return the new deck with replaced tiles
 // }
-pub(crate) fn replace_tile_in_deck(deck: &Deck, tile_to_remove: &Tile) -> Deck {
-    let mut found = false;
-
+pub(crate) fn replace_tile_in_deck(deck: &Deck, tile_to_replace: &Tile) -> Deck {
     let new_tiles: Vec<Tile> = deck
         .tiles
         .iter()
-        .cloned()
-        .filter(|tile| {
-            if !found && tile == tile_to_remove {
-                found = true; // remove only the first match
-                false
+        .map(|tile| {
+            if tile == tile_to_replace {
+                Tile(0, 0, 0) // Replace the tile
             } else {
-                true
+                *tile // Keep the original tile
             }
         })
         .collect();
 
-    Deck { tiles: new_tiles }
+    Deck { tiles: new_tiles } // Return the new deck with replaced tiles
 }
 
-pub fn remove_tile_from_deck(deck: &Deck, tile_to_remove: &Tile) -> Deck {
-    // Filtre toutes les tuiles sauf celle √† retirer
-    let new_tiles: Vec<Tile> = deck
-        .tiles
-        .iter()
-        .filter(|&tile| tile != tile_to_remove) // Conserve uniquement les tuiles diff√©rentes
-        .cloned() // Copie chaque tuile dans le nouveau vecteur
-        .collect();
 
-    Deck { tiles: new_tiles } // Cr√©e un nouveau deck
-}
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -67,10 +53,9 @@ mod tests {
         let tile_to_remove = Tile(4, 5, 6);
 
         // Remove the tile from the deck
-        let updated_deck = remove_tile_from_deck(&deck, &tile_to_remove);
+        let updated_deck = replace_tile_in_deck(&deck, &tile_to_remove);
 
         // Ensure the tile is removed
-        assert_eq!(updated_deck.tiles.len(), 2);
         assert!(!updated_deck.tiles.contains(&tile_to_remove));
 
         // Ensure other tiles are still present
@@ -93,7 +78,7 @@ mod tests {
         let tile_to_remove = Tile(0, 0, 0);
 
         // Remove the tile
-        let updated_deck = remove_tile_from_deck(&deck, &tile_to_remove);
+        let updated_deck = replace_tile_in_deck(&deck, &tile_to_remove);
 
         // Ensure the deck size remains unchanged
         assert_eq!(updated_deck.tiles.len(), 3);
diff --git a/src/main.rs b/src/main.rs
index 90a57dc..7176e02 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,49 +1,17 @@
-use chrono::Utc;
 use clap::Parser;
-use futures_util::stream::SplitSink;
-use futures_util::{SinkExt, StreamExt};
-use rand::{rng, Rng};
-use serde_json;
-use std::collections::HashMap;
-use std::fs::OpenOptions;
-use std::io::{BufWriter, Write};
+use futures_util::StreamExt;
 use std::path::Path;
-use std::sync::Arc;
-use tch::nn::{Optimizer, OptimizerConfig};
-use tch::{nn, Device, IndexOp, Tensor};
+use tch::nn::{self, OptimizerConfig};
+use tch::Device;
 use tokio::net::TcpListener;
-use tokio_tungstenite::tungstenite::protocol::Message;
-use tokio_tungstenite::{accept_async, WebSocketStream};
+use tokio_tungstenite::accept_async;
 
-use crate::game::deck::Deck;
-use crate::game::plateau::create_plateau_empty;
 use crate::logging::setup_logging;
-use crate::mcts::mcts_result::MCTSResult;
 use crate::mcts_vs_human::play_mcts_vs_human;
-use game::create_deck::create_deck;
-use game::plateau::Plateau;
-use game::remove_tile_from_deck::replace_tile_in_deck;
-use game::tile::Tile;
 use neural::policy_value_net::{PolicyNet, ValueNet};
-use crate::data::append_result::append_to_results_file;
-use crate::data::load_data::load_game_data;
-use crate::data::save_data::save_game_data;
-use crate::game::get_legal_moves::get_legal_moves;
-use crate::game::plateau_is_full::is_plateau_full;
-use crate::game::simulate_game::simulate_games;
-use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
-use crate::neural::tensor_conversion::convert_plateau_to_tensor;
-use crate::neural::training::gradient_clipping::enhanced_gradient_clipping;
-use crate::neural::training::normalization::robust_state_normalization;
-use crate::neural::training::trainer::train_network_with_game_data;
-use crate::scoring::scoring::result;
-use crate::strategy::position_evaluation::enhanced_position_evaluation;
-use crate::training::evaluator::evaluate_model;
 use crate::training::session::train_and_evaluate;
-use crate::training::websocket::reconnect_websocket;
-use crate::utils::image::generate_tile_image_names;
-use crate::utils::random_index::random_index;
 
+#[cfg(test)]
 mod test;
 
 mod game;
@@ -68,11 +36,22 @@ struct Config {
     #[arg(short = 's', long, default_value_t = 150)]
     num_simulations: usize,
 
-    /// Run MCTS vs Human instead of training
-    #[arg(long, default_value_t = true)]
-    mcts_vs_human: bool,
+    /// Mode de jeu
+    #[arg(long, value_enum, default_value = "mcts-vs-human")]
+    mode: GameMode,
 }
 
+#[derive(clap::ValueEnum, Clone, Debug)]
+enum GameMode {
+    /// Mode entra√Ænement normal
+    Training,
+    /// MCTS vs un seul humain
+    MctsVsHuman,
+    /// MCTS vs plusieurs humains (style Kahoot)
+    Multiplayer,
+}
+
+
 #[tokio::main]
 async fn main() {
     let config = Config::parse();
@@ -113,47 +92,63 @@ async fn main() {
     .unwrap(); // Was 1e-3
 
     // ‚ûï Duel Mode: MCTS vs Human
-    if config.mcts_vs_human {
-        let listener = TcpListener::bind("127.0.0.1:9001")
-            .await
-            .expect("Unable to bind WebSocket on port 9001 for MCTS vs Human");
-
-        log::info!("üßç‚Äç‚ôÇÔ∏èü§ñ Waiting for MCTS vs Human connection...");
-        let (stream, _) = listener.accept().await.unwrap();
-        let ws_stream = accept_async(stream).await.unwrap();
-        let (mut write, mut read) = ws_stream.split();
-
-        play_mcts_vs_human(
-            &policy_net,
-            &value_net,
-            config.num_simulations,
-            &mut write,
-            &mut read,
-        )
-        .await;
-
-        return; // Exit after duel game
-    }
+    match config.mode {
+        GameMode::Training => {
+            log::info!("üß† Starting training mode...");
+            let listener = TcpListener::bind("127.0.0.1:9000")
+                .await
+                .expect("Unable to bind WebSocket on port 9000 for training");
+            log::info!("üß† Training WebSocket server started at ws://127.0.0.1:9000");
+
+            train_and_evaluate(
+                &vs_policy,
+                &vs_value,
+                &mut policy_net,
+                &mut value_net,
+                &mut optimizer_policy,
+                &mut optimizer_value,
+                config.num_games,
+                config.num_simulations,
+                50,
+                listener.into(),
+            )
+                .await;
+        }
 
-    // üß† Training Mode
-    let listener = TcpListener::bind("127.0.0.1:9000")
-        .await
-        .expect("Unable to bind WebSocket on port 9000 for training");
-    log::info!("üß† Training WebSocket server started at ws://127.0.0.1:9000");
-
-    train_and_evaluate(
-        &vs_policy,
-        &vs_value,
-        &mut policy_net,
-        &mut value_net,
-        &mut optimizer_policy,
-        &mut optimizer_value,
-        config.num_games,
-        config.num_simulations,
-        50, // Evaluate every 50 games
-        listener.into(),
-    )
-    .await;
+        GameMode::MctsVsHuman => {
+            log::info!("üßç‚Äç‚ôÇÔ∏èü§ñ Starting MCTS vs Human mode...");
+            let listener = TcpListener::bind("127.0.0.1:9001")
+                .await
+                .expect("Unable to bind WebSocket on port 9001 for MCTS vs Human");
+
+            let (stream, _) = listener.accept().await.unwrap();
+            let ws_stream = accept_async(stream).await.unwrap();
+            let (mut write, mut read) = ws_stream.split();
+
+            play_mcts_vs_human(
+                &policy_net,
+                &value_net,
+                config.num_simulations,
+                &mut write,
+                &mut read,
+                (&listener).into(),
+            )
+                .await;
+        }
+
+        GameMode::Multiplayer => {
+            log::info!("üéÆüë• Starting Multiplayer mode (MCTS vs Multiple Humans)...");
+            log::info!("üîó Players can connect and create/join sessions");
+            log::info!("üìã Session codes will be generated for easy joining");
+
+            // start_multiplayer_server(
+            //     policy_net,
+            //     value_net,
+            //     config.num_simulations,
+            // )
+            //     .await;
+        }
+    }
 }
 
 
diff --git a/src/mcts/algorithm.rs b/src/mcts/algorithm.rs
index 88c272f..144d95c 100644
--- a/src/mcts/algorithm.rs
+++ b/src/mcts/algorithm.rs
@@ -141,8 +141,8 @@ pub fn mcts_find_best_position_for_tile_with_nn(
             let mut total_simulated_score = 0.0;
 
             for _ in 0..rollout_count {
-                let mut lookahead_plateau = temp_plateau.clone();
-                let mut lookahead_deck = temp_deck.clone();
+                let lookahead_plateau = temp_plateau.clone();
+                let lookahead_deck = temp_deck.clone();
 
                 // üîÆ √âtape 1.1 ‚Äî Tirer une tuile hypoth√©tique (T2)
                 if lookahead_deck.tiles.is_empty() {
diff --git a/src/mcts_vs_human.rs b/src/mcts_vs_human.rs
index bec6730..76e0c5a 100644
--- a/src/mcts_vs_human.rs
+++ b/src/mcts_vs_human.rs
@@ -1,20 +1,22 @@
 use crate::game::create_deck::create_deck;
+use crate::game::plateau_is_full::is_plateau_full;
 use crate::game::remove_tile_from_deck::replace_tile_in_deck;
-use crate::generate_tile_image_names;
-use crate::{is_plateau_full};
+use crate::training::websocket::send_websocket_message;
+use crate::utils::image::generate_tile_image_names;
+// Import de votre fonction
 
-use serde_json::json;
-use tokio_tungstenite::tungstenite::protocol::Message;
-use tokio_tungstenite::WebSocketStream;
-use tokio::net::TcpStream;
-use futures_util::{SinkExt, StreamExt};
-use futures_util::stream::SplitSink;
-use rand::Rng;
 use crate::game::plateau::create_plateau_empty;
-use crate::neural::policy_value_net::{PolicyNet, ValueNet};
 use crate::game::tile::Tile;
 use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
+use crate::neural::policy_value_net::{PolicyNet, ValueNet};
 use crate::scoring::scoring::result;
+use futures_util::stream::SplitSink;
+use futures_util::StreamExt;
+use rand::Rng;
+use serde_json::json;
+use tokio::net::{TcpListener, TcpStream};
+use tokio_tungstenite::tungstenite::protocol::Message;
+use tokio_tungstenite::WebSocketStream;
 
 pub async fn play_mcts_vs_human(
     policy_net: &PolicyNet,
@@ -22,6 +24,7 @@ pub async fn play_mcts_vs_human(
     num_simulations: usize,
     write: &mut SplitSink<WebSocketStream<TcpStream>, Message>,
     read: &mut (impl StreamExt<Item = Result<Message, tokio_tungstenite::tungstenite::Error>> + Unpin),
+    listener: &TcpListener, // ‚úÖ Ajout du listener pour votre fonction
 ) {
     let mut deck = create_deck();
     let mut plateau_human = create_plateau_empty();
@@ -36,19 +39,25 @@ pub async fn play_mcts_vs_human(
         deck = replace_tile_in_deck(&deck, &tile); // remove it from deck
         let tile_image = format!("../image/{}{}{}.png", tile.0, tile.1, tile.2);
 
-        // ‚úÖ Send state to frontend
+        // ‚úÖ Send state to frontend - REFACTORIS√â
         let payload = json!({
             "type": "mcts_vs_human_turn",
             "tile": tile_image,
             "plateau_human": generate_tile_image_names(&plateau_human.tiles),
             "plateau_mcts": generate_tile_image_names(&plateau_mcts.tiles)
         });
-        if write.send(Message::Text(payload.to_string())).await.is_err() {
-            eprintln!("‚ùå Failed to send turn info to frontend (WebSocket closed?)");
+
+        // üîÑ REMPLACEMENT: write.send() simple ‚Üí send_websocket_message()
+        if let Err(e) = send_websocket_message(
+            write,
+            payload.to_string(),
+            listener
+        ).await {
+            eprintln!("‚ùå Failed to send turn info to frontend: {}", e);
             return;
         }
 
-        // ‚úÖ Wait for HUMAN move
+        // ‚úÖ Wait for HUMAN move (pas de changement n√©cessaire ici)
         let mut human_move: Option<usize> = None;
         while let Some(msg) = read.next().await {
             match msg {
@@ -97,7 +106,7 @@ pub async fn play_mcts_vs_human(
         current_turn += 1;
     }
 
-    // ‚úÖ Game over - send results
+    // ‚úÖ Game over - send results - REFACTORIS√â
     let score_human = result(&plateau_human);
     let score_mcts = result(&plateau_mcts);
 
@@ -107,7 +116,12 @@ pub async fn play_mcts_vs_human(
         "score_mcts": score_mcts
     });
 
-    if write.send(Message::Text(final_payload.to_string())).await.is_err() {
-        eprintln!("‚ùå Failed to send final results.");
+    // üîÑ REMPLACEMENT: write.send() simple ‚Üí send_websocket_message()
+    if let Err(e) = send_websocket_message(
+        write,
+        final_payload.to_string(),
+        listener
+    ).await {
+        eprintln!("‚ùå Failed to send final results: {}", e);
     }
 }
diff --git a/src/neural/policy_value_net.rs b/src/neural/policy_value_net.rs
index 0f78c2c..2d9ee6a 100644
--- a/src/neural/policy_value_net.rs
+++ b/src/neural/policy_value_net.rs
@@ -105,7 +105,7 @@ pub fn initialize_weights(vs: &nn::VarStore) {
             let fan_out = (size[0] * size[2] * size[3]) as f64;
             let bound = (6.0 / (fan_in + fan_out)).sqrt();
             tch::no_grad(|| {
-                param.f_uniform_(-bound, bound).unwrap();
+                let _ = param.f_uniform_(-bound, bound).unwrap();
             });
         } else if size.len() == 2 {
             // Xavier initialization for linear layers
@@ -113,12 +113,12 @@ pub fn initialize_weights(vs: &nn::VarStore) {
             let fan_out = size[0] as f64;
             let bound = (6.0 / (fan_in + fan_out)).sqrt();
             tch::no_grad(|| {
-                param.f_uniform_(-bound, bound).unwrap();
+                let _ = param.f_uniform_(-bound, bound).unwrap();
             });
         } else if size.len() == 1 {
             // Zero initialization for biases
             tch::no_grad(|| {
-                param.f_zero_().unwrap();
+                let _ = param.f_zero_().unwrap();
             });
         }
 
@@ -256,10 +256,11 @@ impl ValueNet {
 
 
 }
+#[allow(dead_code)]
 fn kaiming_uniform(tensor: &mut Tensor, fan_in: f64) {
     let bound = (6.0f64).sqrt() / fan_in.sqrt();
     tch::no_grad(|| {
-        tensor.f_uniform_(-bound, bound).unwrap();
+        let _ = tensor.f_uniform_(-bound, bound).unwrap();
     });
 }
 
diff --git a/src/neural/res_net_block.rs b/src/neural/res_net_block.rs
index e40b131..2da0303 100644
--- a/src/neural/res_net_block.rs
+++ b/src/neural/res_net_block.rs
@@ -1,7 +1,5 @@
 use tch::{nn, Tensor};
 
-use crate::neural::policy_value_net::initialize_weights;
-
 /// Residual Block
 pub struct ResNetBlock {
     pub(crate) conv1: nn::Conv2D,
diff --git a/src/neural/training/gradient_clipping.rs b/src/neural/training/gradient_clipping.rs
index 18052aa..2ff6d58 100644
--- a/src/neural/training/gradient_clipping.rs
+++ b/src/neural/training/gradient_clipping.rs
@@ -36,7 +36,7 @@ fn clip_value_network_gradients(vs_value: &nn::VarStore) -> f64 {
                 max_grad_value = max_grad_value.max(grad_norm);
 
                 // Clipping tr√®s agressif pour stabilit√©
-                tensor.grad().clamp_(-0.5, 0.5);
+                let _ = tensor.grad().clamp_(-0.5, 0.5);
             }
         }
     });
@@ -55,7 +55,7 @@ fn clip_policy_network_gradients(vs_policy: &nn::VarStore) -> f64 {
                 max_grad_policy = max_grad_policy.max(grad_norm);
 
                 // Clipping mod√©r√©
-                tensor.grad().clamp_(-1.0, 1.0);
+                let _ = tensor.grad().clamp_(-1.0, 1.0);
             }
         }
     });
@@ -74,6 +74,7 @@ fn log_gradient_norms(max_grad_value: f64, max_grad_policy: f64) {
 }
 
 /// Version simple du clipping des gradients
+#[allow(dead_code)]
 pub fn simple_gradient_clipping(
     vs: &nn::VarStore,
     max_norm: f64,
@@ -86,7 +87,7 @@ pub fn simple_gradient_clipping(
                 let grad_norm = tensor.grad().norm().double_value(&[]);
                 max_grad = max_grad.max(grad_norm);
 
-                tensor.grad().clamp_(-max_norm, max_norm);
+                let _ = tensor.grad().clamp_(-max_norm, max_norm);
             }
         }
     });
diff --git a/src/neural/training/normalization.rs b/src/neural/training/normalization.rs
index c2a44c6..7c4d3b8 100644
--- a/src/neural/training/normalization.rs
+++ b/src/neural/training/normalization.rs
@@ -46,6 +46,7 @@ fn normalize_with_mad(tensor: &Tensor, median: f64, mad: f64) -> Tensor {
 }
 
 /// Version simple de normalisation z-score
+#[allow(dead_code)]
 pub fn simple_normalization(tensor: &Tensor) -> Tensor {
     let mean = tensor.mean(tch::Kind::Float);
     let std = tensor.std(false).clamp_min(1e-8);
@@ -53,6 +54,7 @@ pub fn simple_normalization(tensor: &Tensor) -> Tensor {
 }
 
 /// Normalisation min-max
+#[allow(dead_code)]
 pub fn min_max_normalization(tensor: &Tensor) -> Tensor {
     let min_val = tensor.min();
     let max_val = tensor.max();
diff --git a/src/neural/training/trainer.rs b/src/neural/training/trainer.rs
index 95a6d39..9b30739 100644
--- a/src/neural/training/trainer.rs
+++ b/src/neural/training/trainer.rs
@@ -9,7 +9,7 @@ pub fn train_network_with_game_data(
     vs_policy: &nn::VarStore,
     vs_value: &nn::VarStore,
     game_data: &[MCTSResult],
-    discount_factor: f64,
+    _discount_factor: f64,
     policy_net: &PolicyNet,
     value_net: &ValueNet,
     optimizer_policy: &mut Optimizer,
@@ -79,7 +79,7 @@ pub fn train_network_with_game_data(
         // Policy loss
         let best_position = result.best_position as i64;
         let target_policy = Tensor::zeros(&[1, pred_policy.size()[1]], tch::kind::FLOAT_CPU);
-        target_policy.i((0, best_position)).fill_(1.0);
+        let _ = target_policy.i((0, best_position)).fill_(1.0);
         let log_policy = pred_policy.log();
         let policy_loss = -(target_policy * log_policy.shallow_clone()).sum(tch::Kind::Float);
         total_policy_loss += policy_loss;
diff --git a/src/strategy/position_evaluation.rs b/src/strategy/position_evaluation.rs
index 69e2403..48e76dc 100644
--- a/src/strategy/position_evaluation.rs
+++ b/src/strategy/position_evaluation.rs
@@ -3,7 +3,7 @@ use crate::game::tile::Tile;
 use crate::scoring::scoring::compute_alignment_score;
 
 // Version simplifi√©e qui se concentre sur les positions strat√©giques
-pub fn calculate_line_completion_bonus(plateau: &Plateau, position: usize, tile: &Tile) -> f64 {
+pub fn calculate_line_completion_bonus(_plateau: &Plateau, position: usize, tile: &Tile) -> f64 {
     let mut bonus = 0.0;
 
     // Bonus bas√© sur les positions strat√©giques identifi√©es dans tes donn√©es
diff --git a/src/test.rs b/src/test.rs
index 896f3e0..66ef714 100644
--- a/src/test.rs
+++ b/src/test.rs
@@ -1,8 +1,7 @@
-use crate::game::plateau::Plateau;
-use crate::game::tile::Tile;
-
 #[cfg(test)]
 pub(crate) mod tests {
+    use crate::game::plateau::Plateau;
+    use crate::game::tile::Tile;
     pub fn create_mcts_node(state: GameState, parent: Option<*mut MCTSNode>) -> MCTSNode {
         MCTSNode {
             state,
@@ -61,7 +60,7 @@ pub(crate) mod tests {
             placer_tile(&mut game_state.plateau, tile, position);
             let new_plateau = game_state.plateau.clone();
             let mut new_deck = game_state.deck.clone();
-            new_deck = remove_tile_from_deck(&new_deck, &tile);
+            new_deck = replace_tile_in_deck(&new_deck, &tile);
 
 
             Some(GameState {
@@ -129,18 +128,17 @@ pub(crate) mod tests {
             (*current).value += score;
         }
     }
-    use crate::game::remove_tile_from_deck::remove_tile_from_deck;
-use super::*;
-
-
     use rand::Rng;
     use crate::game::create_deck::create_deck;
-    use crate::{convert_plateau_to_tensor, get_legal_moves, is_plateau_full, simulate_games};
+    use crate::game::get_legal_moves::get_legal_moves;
+    use crate::game::plateau_is_full::is_plateau_full;
+    use crate::game::simulate_game::simulate_games;
+    use crate::neural::tensor_conversion::convert_plateau_to_tensor;
     use crate::game::deck::Deck;
     use crate::game::game_state::GameState;
     use crate::mcts::mcts_node::MCTSNode;
-    use crate::game::plateau::{create_plateau_empty, Plateau};
-    use crate::game::tile::Tile;
+    use crate::game::plateau::create_plateau_empty;
+    use crate::game::remove_tile_from_deck::replace_tile_in_deck;
     use crate::scoring::scoring::result;
 
     #[test]
@@ -182,7 +180,7 @@ use super::*;
     fn test_simulate_games() {
         let plateau = create_plateau_empty();
         let deck = create_deck();
-        let num_simulations = 10;
+        let _num_simulations = 10;
 
         let avg_score = simulate_games(plateau, deck);
         assert!(avg_score >= 0); // Score should be non-negative
@@ -194,7 +192,7 @@ use super::*;
         let deck = create_deck();
 
         let tensor = convert_plateau_to_tensor(&plateau, &tile, &deck, /* usize */0, 19/* usize */);
-        assert_eq!(tensor.size(), vec![1, 3, 5, 5]); // Ensure the tensor has the correct shape
+        assert_eq!(tensor.size(), vec![1, 5, 47, 1]); // Ensure the tensor has the correct shape
     }
 
 
@@ -202,11 +200,11 @@ use super::*;
     #[test]
     fn test_placement_tuile_not_valide_take_it_easy() {
         let mut plateau:Plateau=create_plateau_empty();
-        let deckSfuffle:Deck= create_deck();
-        let tile = deckSfuffle.tiles[5].clone();
+        let deck_sfuffle: Deck = create_deck();
+        let tile = deck_sfuffle.tiles[5].clone();
         assert!(placer_tile(&mut plateau, tile.clone(), 1));
         assert_eq!(plateau.tiles[1], tile);
-        let tile = deckSfuffle.tiles[5].clone();
+        let tile = deck_sfuffle.tiles[5].clone();
         assert!(!placer_tile(&mut plateau, tile.clone(), 1));
     }
     #[test]
@@ -215,8 +213,8 @@ use super::*;
         let deck_shuffle: Deck = create_deck();
 
         // G√©n√®re un index al√©atoire
-        let mut rng = rand::thread_rng();
-        let index = rng.gen_range(0..deck_shuffle.tiles.len());
+        let mut rng = rand::rng();
+        let index = rng.random_range(0..deck_shuffle.tiles.len());
 
         // S√©lectionne une tuile al√©atoire
         let tuile = deck_shuffle.tiles[index].clone();
@@ -239,17 +237,18 @@ use super::*;
         let deck_shuffle: Deck = create_deck();
 
         // G√©n√®re un indice al√©atoire
-        let mut rng = rand::thread_rng();
-        let index = rng.gen_range(0..deck_shuffle.tiles.len());
+        let mut rng = rand::rng();
+        let index = rng.random_range(0..deck_shuffle.tiles.len());
 
         // R√©cup√®re la tuile choisie al√©atoirement
         let tuile_choisie = deck_shuffle.tiles[index].clone();
 
         // Supprime la tuile du deck
-        let nouveau_deck = remove_tile_from_deck(&deck_shuffle, &tuile_choisie);
+        let nouveau_deck = replace_tile_in_deck(&deck_shuffle, &tuile_choisie);
+        
 
         // V√©rifie que la nouvelle taille du deck est r√©duite de 1
-        assert_eq!(nouveau_deck.tiles.len(), deck_shuffle.tiles.len() - 1);
+        assert_eq!(27-nouveau_deck.tiles.iter().filter(|&&tile| tile == Tile(0, 0, 0)).count(),26);
 
         // V√©rifie que la tuile choisie n'est plus pr√©sente dans le nouveau deck
         assert!(!nouveau_deck.tiles.contains(&tuile_choisie));
@@ -278,7 +277,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_first_3_plateau_3_1() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
         placer_tile(&mut plateau, deck.tiles[1].clone(), 1);
@@ -288,7 +287,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_first_3_plateau_3_2() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[9].clone(), 0);
         placer_tile(&mut plateau, deck.tiles[10].clone(), 1);
@@ -298,7 +297,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_2_column_plateau_4_2() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[9].clone(), 3);
         placer_tile(&mut plateau, deck.tiles[10].clone(), 4);
@@ -312,7 +311,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_column_center_plateau_5_2() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[9].clone(), 7);
         placer_tile(&mut plateau, deck.tiles[10].clone(), 8);
@@ -327,7 +326,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_column_4_plateau_4_2() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[9].clone(), 12);
         placer_tile(&mut plateau, deck.tiles[10].clone(), 13);
@@ -341,7 +340,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_last_column_3_plateau_3_1() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 16);
         placer_tile(&mut plateau, deck.tiles[1].clone(),17);
@@ -351,7 +350,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_first_diag_plateau_0_3_7() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
         placer_tile(&mut plateau, deck.tiles[4].clone(),3);
@@ -361,7 +360,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_second_diag_plateau_1_4_8_12() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 1);
         placer_tile(&mut plateau, deck.tiles[4].clone(),4);
@@ -372,7 +371,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_third_diag_plateau_2_5_9_13_16() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 2);
         placer_tile(&mut plateau, deck.tiles[4].clone(),5);
@@ -384,7 +383,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_fourth_diag_plateau_6_10_14_17() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 6);
         placer_tile(&mut plateau, deck.tiles[4].clone(),10);
@@ -396,7 +395,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_last_diag_plateau_11_15_18() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 11);
         placer_tile(&mut plateau, deck.tiles[4].clone(),15);
@@ -408,7 +407,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_firdt_diag_left_plateau_7_12_16() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 7);
         placer_tile(&mut plateau, deck.tiles[2].clone(),12);
@@ -420,7 +419,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_second_diag_left_plateau_3_8_13_17() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 3);
         placer_tile(&mut plateau, deck.tiles[2].clone(),8);
@@ -433,7 +432,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_third_diag_left_plateau_0_4_9_14_18() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 0);
         placer_tile(&mut plateau, deck.tiles[2].clone(),4);
@@ -448,7 +447,7 @@ use super::*;
 
     #[test]
     fn test_remplir_plateau_take_it_easy_count_fourth_diag_left_plateau_1_5_10_15() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 1);
         placer_tile(&mut plateau, deck.tiles[2].clone(),5);
@@ -461,7 +460,7 @@ use super::*;
     }
     #[test]
     fn test_remplir_plateau_take_it_easy_count_last_diag_left_plateau_2_6_11() {
-        let mut deck = create_deck();
+        let deck = create_deck();
         let mut plateau = create_plateau_empty();
         placer_tile(&mut plateau, deck.tiles[0].clone(), 2);
         placer_tile(&mut plateau, deck.tiles[2].clone(),6);
@@ -530,9 +529,9 @@ use super::*;
                 break; // No more moves possible
             }
 
-            let mut rng = rand::thread_rng();
-            let position = legal_moves[rng.gen_range(0..legal_moves.len())].clone();
-            let tile_index = rng.gen_range(0..simulated_state.deck.tiles.len());
+            let mut rng = rand::rng();
+            let position = legal_moves[rng.random_range(0..legal_moves.len())].clone();
+            let tile_index = rng.random_range(0..simulated_state.deck.tiles.len());
             let chosen_tile = simulated_state.deck.tiles[tile_index].clone();
             simulated_state = apply_move(simulated_state,chosen_tile, position).unwrap();
         }
@@ -546,16 +545,14 @@ use super::*;
 
         // Game is not over at the beginning
         assert!(!is_game_over(state.clone()));
-
+        let mut position = 0;
         while state.plateau.tiles.contains(&Tile(0, 0, 0)) {
-            for position in 0..state.plateau.tiles.len() {
-                if let Some(empty_tile) = state.deck.tiles.first() {
-                    if let Some(new_state) = apply_move(state.clone(), *empty_tile, position) {
+                if let Some(empty_tile) = state.deck.tiles.iter().filter(|tile| **tile != Tile(0, 0, 0)).collect::<Vec<_>>().first() {
+                    if let Some(new_state) = apply_move(state.clone(), **empty_tile, position) {
                         state = new_state;
-                        break; // Move to the next iteration after placing a tile
                     }
                 }
-            }
+            position += 1;
         }
 
 
@@ -639,7 +636,7 @@ use super::*;
     fn test_backpropagate_with_parent() {
         let mut root = create_mcts_node(create_game_state(), None);
 
-        let mut child = create_mcts_node(create_game_state(), Some(&mut root as *mut _));
+        let child = create_mcts_node(create_game_state(), Some(&mut root as *mut _));
         root.children.push(child);
 
         let  leaf = create_mcts_node(create_game_state(), Some(&mut root.children[0] as *mut _));
@@ -731,10 +728,10 @@ use super::*;
     #[test]
     fn test_backpropagation_step() {
         let mut root = create_mcts_node(create_game_state(), None);
-        let mut child = create_mcts_node(create_game_state(), Some(&mut root as *mut _));
+        let child = create_mcts_node(create_game_state(), Some(&mut root as *mut _));
         root.children.push(child);
 
-        let mut leaf = create_mcts_node(create_game_state(), Some(&mut root.children[0] as *mut _));
+        let leaf = create_mcts_node(create_game_state(), Some(&mut root.children[0] as *mut _));
         root.children[0].children.push(leaf);
 
         let leaf_mut = &mut root.children[0].children[0];
@@ -762,17 +759,17 @@ use super::*;
             // Expansion
             let legal_moves = get_legal_moves(selected_node.state.plateau.clone());
             if !legal_moves.is_empty() {
-                let mut rng = rand::thread_rng();
-                let position = legal_moves[rng.gen_range(0..legal_moves.len())];
-                let tile_index = rng.gen_range(0..selected_node.state.deck.tiles.len());
+                let mut rng = rand::rng();
+                let position = legal_moves[rng.random_range(0..legal_moves.len())];
+                let tile_index = rng.random_range(0..selected_node.state.deck.tiles.len());
                 let chosen_tile = selected_node.state.deck.tiles[tile_index];
-                let deck_size_before = selected_node.state.deck.tiles.len();
+                let deck_size_before = selected_node.state.deck.tiles.iter().filter(|tile| **tile != Tile(0, 0, 0)).collect::<Vec<_>>().len();
                 println!("Deck size before expansion: {}", deck_size_before);
 
                 if let Some(new_state) = apply_move(selected_node.state.clone(), chosen_tile, position) {
                     expand(selected_node.clone(), new_state.clone());
 
-                    let deck_size_after = new_state.deck.tiles.len();
+                    let deck_size_after = new_state.deck.tiles.iter().filter(|tile| **tile != Tile(0, 0, 0)).collect::<Vec<_>>().len();
                     println!("Deck size after expansion: {}", deck_size_after);
 
                     assert_eq!(deck_size_after, deck_size_before - 1, "Deck size did not decrement correctly!");
diff --git a/src/training/session.rs b/src/training/session.rs
index 7b0fbaf..63d48a6 100644
--- a/src/training/session.rs
+++ b/src/training/session.rs
@@ -8,15 +8,13 @@ use crate::game::remove_tile_from_deck::replace_tile_in_deck;
 use crate::game::tile::Tile;
 use crate::mcts::algorithm::mcts_find_best_position_for_tile_with_nn;
 use crate::mcts::mcts_result::MCTSResult;
-use crate::mcts_vs_human::play_mcts_vs_human;
 use crate::neural::policy_value_net::{PolicyNet, ValueNet};
 use crate::neural::training::trainer::train_network_with_game_data;
 use crate::scoring::scoring::result;
 use crate::training::evaluator::evaluate_model;
-use crate::training::websocket::reconnect_websocket;
+use crate::training::websocket::{send_websocket_message};
 use crate::utils::image::generate_tile_image_names;
-use crate::Config;
-use futures_util::{SinkExt, StreamExt};
+use futures_util::{StreamExt};
 use rand::{rng, Rng};
 use std::collections::HashMap;
 use std::sync::Arc;
@@ -24,9 +22,8 @@ use tch::nn;
 use tch::nn::Optimizer;
 use tokio::net::TcpListener;
 use tokio_tungstenite::accept_async;
-use tokio_tungstenite::tungstenite::Message;
-/// Lance une session MCTS vs Humain
 
+/// Lance une session MCTS vs Humain - Version refactoris√©e avec send_websocket_message
 pub async fn train_and_evaluate(
     vs_policy: &nn::VarStore,
     vs_value: &nn::VarStore,
@@ -64,7 +61,6 @@ pub async fn train_and_evaluate(
             );
 
             let mut batch_games_played = 0; // Tracks games processed in this evaluation interval
-
             let max_memory_size = 1000; // Store last 500 games
 
             for game in 0..evaluation_interval {
@@ -74,11 +70,12 @@ pub async fn train_and_evaluate(
                 let mut first_move: Option<(usize, Tile)> = None;
                 let total_turns = 19; // The number of moves in the game
                 let mut current_turn = 0;
+
                 while !is_plateau_full(&plateau) {
                     let tile_index = rng().random_range(0..deck.tiles.len());
                     let chosen_tile = deck.tiles[tile_index];
-                    // ‚úÖ **Send preview before placement**
-                    // ‚úÖ **INSERT YOUR NEW CODE HERE**
+
+                    // ‚úÖ Send preview before placement - REFACTORIS√â
                     let chosen_tile_image = format!(
                         "../image/{}{}{}.png",
                         chosen_tile.0, chosen_tile.1, chosen_tile.2
@@ -87,8 +84,16 @@ pub async fn train_and_evaluate(
                         "next_tile": chosen_tile_image,
                         "plateau_tiles": generate_tile_image_names(&plateau.tiles)
                     });
-                    let serialized = serde_json::to_string(&payload).unwrap();
-                    write.send(Message::Text(serialized)).await.unwrap();
+
+                    // üîÑ REMPLACEMENT: write.send() ‚Üí send_websocket_message()
+                    if let Err(e) = send_websocket_message(
+                        &mut write,
+                        payload.to_string(),
+                        &listener
+                    ).await {
+                        log::error!("Failed to send tile preview: {}", e);
+                        break;
+                    }
 
                     let game_result = mcts_find_best_position_for_tile_with_nn(
                         &mut plateau,
@@ -107,44 +112,42 @@ pub async fn train_and_evaluate(
                     }
                     plateau.tiles[best_position] = chosen_tile;
                     deck = replace_tile_in_deck(&deck, &chosen_tile);
-                    // ‚úÖ INSERT THIS TO SEND SCORE TO CLIENT
+
+                    // ‚úÖ Send score to client - REFACTORIS√â
                     let current_score = result(&plateau);
                     let score_payload = serde_json::json!({
                         "type": "score_update",
                         "current_score": current_score,
                     });
-                    let serialized_score = serde_json::to_string(&score_payload).unwrap();
-                    if let Err(e) = write.send(Message::Text(serialized_score)).await {
-                        log::error!("WebSocket error when sending score: {:?}", e);
-                        if let Some(new_write) = reconnect_websocket(&listener).await {
-                            write = new_write;
-                        } else {
-                            log::error!("Failed to reconnect WebSocket. Exiting...");
-                            break;
-                        }
+
+                    // üîÑ REMPLACEMENT: Logique complexe de reconnexion ‚Üí send_websocket_message()
+                    if let Err(e) = send_websocket_message(
+                        &mut write,
+                        score_payload.to_string(),
+                        &listener
+                    ).await {
+                        log::error!("Failed to send score update: {}", e);
+                        break;
                     }
 
                     game_data.push(game_result); // Store training data
 
-                    // ‚úÖ **INSERT YOUR NEW CODE HERE**
+                    // ‚úÖ Send updated plateau state - REFACTORIS√â
                     let payload_after_placement = serde_json::json!({
                         "next_tile": null, // Clear preview
                         "plateau_tiles": generate_tile_image_names(&plateau.tiles) // new updated state
                     });
-                    let serialized = serde_json::to_string(&payload_after_placement).unwrap();
-
-                    // ‚úÖ Handle WebSocket disconnections
-                    if let Err(e) = write.send(Message::Text(serialized.clone())).await {
-                        log::error!("WebSocket error: {:?}. Attempting to reconnect...", e);
-
-                        // **Reconnect WebSocket**
-                        if let Some(new_write) = reconnect_websocket(&listener).await {
-                            write = new_write;
-                        } else {
-                            log::error!("Failed to reconnect WebSocket. Exiting...");
-                            break;
-                        }
+
+                    // üîÑ REMPLACEMENT: Logique complexe de reconnexion ‚Üí send_websocket_message()
+                    if let Err(e) = send_websocket_message(
+                        &mut write,
+                        payload_after_placement.to_string(),
+                        &listener
+                    ).await {
+                        log::error!("Failed to send plateau update: {}", e);
+                        break;
                     }
+
                     current_turn += 1; // Increment turn counter each time a tile is placed
                 }
 
@@ -213,10 +216,16 @@ pub async fn train_and_evaluate(
                         games_played
                     );
                     log::info!("batch {} - Score moyen: {:.2}", game, moyenne);
-                    write
-                        .send(Message::Text(format!("GAME_RESULT:{}", moyenne)))
-                        .await
-                        .unwrap();
+
+                    // üîÑ REMPLACEMENT: write.send().await.unwrap() ‚Üí send_websocket_message()
+                    let result_message = format!("GAME_RESULT:{}", moyenne);
+                    if let Err(e) = send_websocket_message(
+                        &mut write,
+                        result_message,
+                        &listener
+                    ).await {
+                        log::error!("Failed to send game result: {}", e);
+                    }
                 }
 
                 // Save current game data for future training
diff --git a/src/utils/random_index.rs b/src/utils/random_index.rs
index fe25ce6..53059d0 100644
--- a/src/utils/random_index.rs
+++ b/src/utils/random_index.rs
@@ -1,5 +1,5 @@
 pub fn random_index(max: usize) -> usize {
     use rand::Rng;
-    let mut rng = rand::thread_rng();
-    rng.gen_range(0..max)
+    let mut rng = rand::rng();
+    rng.random_range(0..max)
 }
\ No newline at end of file
